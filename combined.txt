# File: C:\Users\Slyphur\Documents\interceptor\.git\COMMIT_EDITMSG

first touch


# File: C:\Users\Slyphur\Documents\interceptor\.git\config

[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[lfs]
	repositoryformatversion = 0
[remote "origin"]
	url = https://github.com/PatrickSJacobs/interceptor.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main


# File: C:\Users\Slyphur\Documents\interceptor\.git\description

Unnamed repository; edit this file 'description' to name the repository.


# File: C:\Users\Slyphur\Documents\interceptor\.git\FETCH_HEAD

0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6		branch 'main' of https://github.com/PatrickSJacobs/interceptor


# File: C:\Users\Slyphur\Documents\interceptor\.git\HEAD

ref: refs/heads/main


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\applypatch-msg.sample

#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\commit-msg.sample

#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\fsmonitor-watchman.sample

#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\post-update.sample

#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\pre-applypatch.sample

#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\pre-commit.sample

#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\pre-merge-commit.sample

#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\pre-push.sample

#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\pre-rebase.sample

#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\pre-receive.sample

#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\prepare-commit-msg.sample

#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\push-to-checkout.sample

#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\sendemail-validate.sample

#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi


# File: C:\Users\Slyphur\Documents\interceptor\.git\hooks\update.sample

#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0


# File: C:\Users\Slyphur\Documents\interceptor\.git\info\exclude

# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~


# File: C:\Users\Slyphur\Documents\interceptor\.git\logs\HEAD

0000000000000000000000000000000000000000 0cee800667553727ed4b6c12abdae71628aa60f6 Patrick Jacobs <69697965+PatrickSJacobs@users.noreply.github.com> 1739531556 -0800	commit (initial): Initial commit
0cee800667553727ed4b6c12abdae71628aa60f6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 Patrick Jacobs <69697965+PatrickSJacobs@users.noreply.github.com> 1739531808 -0800	commit: first touch


# File: C:\Users\Slyphur\Documents\interceptor\.git\logs\refs\heads\main

0000000000000000000000000000000000000000 0cee800667553727ed4b6c12abdae71628aa60f6 Patrick Jacobs <69697965+PatrickSJacobs@users.noreply.github.com> 1739531556 -0800	commit (initial): Initial commit
0cee800667553727ed4b6c12abdae71628aa60f6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 Patrick Jacobs <69697965+PatrickSJacobs@users.noreply.github.com> 1739531808 -0800	commit: first touch


# File: C:\Users\Slyphur\Documents\interceptor\.git\logs\refs\remotes\origin\HEAD

0000000000000000000000000000000000000000 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739531818 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739534410 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739536314 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739538216 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739540117 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739542153 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739544593 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739628409 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739630251 -0800	remote set-head
0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 unknown <Slyphur@DESKTOP-6NMIO91.(none)> 1739632096 -0800	remote set-head


# File: C:\Users\Slyphur\Documents\interceptor\.git\logs\refs\remotes\origin\main

0000000000000000000000000000000000000000 0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6 Patrick Jacobs <69697965+PatrickSJacobs@users.noreply.github.com> 1739531817 -0800	update by push


# File: C:\Users\Slyphur\Documents\interceptor\.git\refs\heads\main

0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6


# File: C:\Users\Slyphur\Documents\interceptor\.git\refs\remotes\origin\HEAD

ref: refs/remotes/origin/main


# File: C:\Users\Slyphur\Documents\interceptor\.git\refs\remotes\origin\main

0eb386b3b7eea7ca0ec01d10e382a9a6aa4ab7d6


# File: C:\Users\Slyphur\Documents\interceptor\.gitattributes

# Auto detect text files and perform LF normalization
* text=auto


# File: C:\Users\Slyphur\Documents\interceptor\.vscode\settings.json

{
    "cmake.configureOnOpen": true,
    "cmake.configureSettings": {
        "CMAKE_TOOLCHAIN_FILE": "${workspaceFolder}/toolchain.cmake"
    },
    "C_Cpp.default.configurationProvider": "ms-vscode.cmake-tools"
}

# File: C:\Users\Slyphur\Documents\interceptor\build.ps1

# build.ps1
$vsPath = "C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools"
$vsDevShell = "$vsPath\Common7\Tools\Launch-VsDevShell.ps1"

if (Test-Path $vsDevShell) {
    Write-Host "Initializing VS Developer Shell..."
    & $vsDevShell -Arch amd64 -HostArch amd64 -SkipAutomaticLocation

    # Create and enter build directory
    if (Test-Path "build") {
        Remove-Item -Path "build" -Recurse -Force
    }
    New-Item -ItemType Directory -Path "build"
    Push-Location "build"

    # Run CMake
    Write-Host "Running CMake..."
    cmake .. -G Ninja

    if ($LASTEXITCODE -eq 0) {
        # Build the project
        Write-Host "Building..."
        ninja
    }

    Pop-Location
} else {
    Write-Error "Could not find VS Developer Shell at: $vsDevShell"
}

# File: C:\Users\Slyphur\Documents\interceptor\CMakeLists.txt

cmake_minimum_required(VERSION 3.15)
project(PrinterInterceptor)

# Set C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Create the DLL
add_library(PrinterInterceptor SHARED
    src-interceptor/PrinterInterceptor.cpp
    src-interceptor/PrinterInterceptor.def
)

# Set output name
set_target_properties(PrinterInterceptor PROPERTIES
    OUTPUT_NAME "PrinterInterceptor"
)

# Add Windows-specific compile definitions
target_compile_definitions(PrinterInterceptor PRIVATE
    UNICODE
    _UNICODE
    WIN32
    _WINDOWS
    _USRDLL
)

# Link against required Windows libraries
target_link_libraries(PrinterInterceptor PRIVATE
    winspool
) 

# File: C:\Users\Slyphur\Documents\interceptor\install.ps1

# Stop the spooler service
Write-Host "Stopping Print Spooler service..."
Stop-Service -Name "Spooler" -Force

# Create the destination directory if it doesn't exist
$dllPath = "$env:SystemRoot\System32"
if (!(Test-Path $dllPath)) {
    New-Item -ItemType Directory -Path $dllPath -Force
}

# Copy the DLL to System32
Write-Host "Copying DLL to System32..."
Copy-Item "build\PrinterInterceptor.dll" -Destination "$dllPath\PrinterInterceptor.dll" -Force

# Import the registry entries
Write-Host "Installing registry entries..."
reg import "install.reg"

# Start the spooler service
Write-Host "Starting Print Spooler service..."
Start-Service -Name "Spooler"

Write-Host "Installation complete. The port monitor is now installed."
Write-Host "You can now add a printer using one of these ports:"
Write-Host "- INTERCEPT:COM1"
Write-Host "- INTERCEPT:LPT1"
Write-Host "- INTERCEPT:CUSTOMPORT=COM3" 

# File: C:\Users\Slyphur\Documents\interceptor\install.reg

Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\PrinterInterceptor]
@=""
"Driver"="PrinterInterceptor.dll"

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\PrinterInterceptor\Config]
"PortMappings"=""

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\PrinterInterceptor\Ports]

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\PrinterInterceptor\Ports\INTERCEPT:COM1]
"Description"="Intercepted COM1 Port"
"Command"=""
"Arguments"=""
"Timeout"=dword:00000000
"Output"=""
"RunUser"=dword:00000000
"RealPortName"="COM1"

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\PrinterInterceptor\Ports\INTERCEPT:LPT1]
"Description"="Intercepted LPT1 Port"
"Command"=""
"Arguments"=""
"Timeout"=dword:00000000
"Output"=""
"RunUser"=dword:00000000
"RealPortName"="LPT1" 

# File: C:\Users\Slyphur\Documents\interceptor\README.md

Below is an extremely detailed step-by-step guide (a prompt or blueprint) explaining how to implement Approach A: a Full Custom Port Monitor (DLL) for Windows to intercept and modify spool data (e.g., ESC/POS) before it reaches a physical printer. This guide covers the architectural background, development environment setup, core monitor API functions, registry configuration, and advanced considerations like bidirectional I/O and spooler status reporting.

Overview
A port monitor in Windows is a dynamic-link library (DLL) that the printing subsystem (the spooler) loads to handle the final stage of sending data to a port. By writing your own monitor:

You gain access to the raw printer data stream.
You can modify or inspect it before sending it on to the real printer port (USB, COM, etc.).
You can intercept and respond to printer status queries so that the spooler and driver continue functioning normally.
The Windows spooler calls a set of standard entry points in your DLL (like InitializePrintMonitor2, OpenPort, WritePort, etc.). You will implement these functions in C++ using the Windows Driver Kit (WDK), then install and register your DLL as a custom monitor.

1. Development Environment Setup
Install the Windows Driver Kit (WDK)

Ensure it matches the target OS version (e.g., WDK for Windows 10, or the latest WDK if targeting Windows 11).
The WDK integrates with Visual Studio. Use a matching Visual Studio version recommended by the WDK.
Create a New Project

In Visual Studio, create a Dynamic-Link Library (DLL) project.
Set the platform to x64 if you are building for a 64-bit system.
Configure the project to use the WDK headers and libraries.
Include Required Headers

You’ll need standard Windows headers (<Windows.h>) and spooler-specific headers (e.g., winsplp.h, <winspool.h>).
For older spooler models, you may see references to monitor.h or localmon.h in the WDK samples.
Reference WDK Samples

Microsoft has provided sample port monitors in past WDKs (e.g., “localmon” or “serialmon”).
Studying them can clarify how the spooler expects your functions to be structured.
2. Basic Architecture of a Custom Port Monitor
2.1 Required (and Optional) Exported Functions
Historically (and depending on Windows version), you’ll implement one of the following initialization functions:

InitializePrintMonitor2

Modern approach (Windows Vista and later).
Returns a structure containing pointers to your monitor’s function implementations.
InitializePrintMonitor

Older approach.
Used on earlier versions of Windows.
Inside your implementation, you must provide pointers to (or implement directly) several monitor callbacks, typically:

OpenPort / OpenPortEx: Called when the spooler wants to open a port (e.g., your “MyVirtualPort:”).
ClosePort: Called when done with that port handle.
StartDocPort: Called at the start of a print job.
WritePort: The spooler calls this repeatedly to send data.
ReadPort: If your driver needs read-back or bidirectional comms.
EndDocPort: Called at the end of a print job.
GetPrinterDataFromPort: For advanced status retrieval from the device.
SetPortTimeOuts: If needed to configure timeouts for reads/writes.
2.2 Data Flow
Spooler calls OpenPort("MyVirtualPort:") → You return a handle/pointer to a context structure you manage.
Spooler calls StartDocPort(handle, jobId, pDocName, ...) → You initialize job-specific data if needed, possibly open a real device (e.g., \\.\USB001).
Spooler calls WritePort(handle, pData, cbData, &cbWritten) repeatedly → You receive chunks of ESC/POS or other data from the driver.
Here is where you can parse, modify, or log the data.
Then you call WriteFile (or similar) to send it to the real port.
Spooler calls EndDocPort(handle) → You finalize the job, flush any buffers, close the real device if you had it open.
Spooler calls ClosePort(handle) → Release any resources.
3. Step-by-Step Implementation
3.1 Define Your Monitor Structure (for InitializePrintMonitor2)
You’ll typically define a global structure like:

c
Copy
Edit
MONITOR2 MyMonitorFunctions = {
    sizeof(MONITOR2),
    MyOpenPort,
    MyOpenPortEx,
    MyStartDocPort,
    MyWritePort,
    MyReadPort,
    MyEndDocPort,
    MyClosePort,
    MyAddPort,
    MyAddPortEx,
    MyConfigurePort,
    MyDeletePort,
    MyGetPrinterDataFromPort,
    MySetPortTimeOuts,
    // ... possibly more depending on your target Windows version
};
Then implement each function (prefixed with My* or whichever naming scheme you choose).

3.2 DllMain
Your DLL must have a standard DllMain:

c
Copy
Edit
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        // Perform initialization
        break;
    case DLL_PROCESS_DETACH:
        // Cleanup if needed
        break;
    }
    return TRUE;
}
3.3 InitializePrintMonitor2
c
Copy
Edit
PMONITOR2 WINAPI InitializePrintMonitor2(PMONITORINIT pMonitorInit, PHANDLE phMonitor) {
    // Optionally store the spooler callback interface or other data from pMonitorInit
    // e.g., pMonitorInit->cbSize, pMonitorInit->pMonitorReg, etc.
    
    // If you need to store any global state, allocate memory here using pMonitorInit->pfnAlloc
    // and return a handle to that state via phMonitor.

    // Finally, return a pointer to your MONITOR2 structure with function pointers.
    return &MyMonitorFunctions;
}
pMonitorInit is provided by the spooler, containing function pointers you can call for memory allocation, logging, registry access, etc.
phMonitor can be used if you have any global context to store.
3.4 Implementing Core Functions
Let’s detail the critical ones:

OpenPort

c
Copy
Edit
BOOL MyOpenPort(LPWSTR pName, PHANDLE pHandle) {
    // pName will be something like "MyVirtualPort:"
    // Create a context structure to hold port-specific info:
    PORT_CONTEXT *pPortCtx = (PORT_CONTEXT *)AllocSplMem(sizeof(PORT_CONTEXT));
    if (!pPortCtx) return FALSE;

    // Initialize context (store port name, set up logs, etc.)
    wcscpy_s(pPortCtx->portName, MAX_PATH, pName);

    // Return pointer to context in *pHandle so spooler can reference it later.
    *pHandle = (HANDLE)pPortCtx;

    return TRUE;
}
You won’t actually open the physical device (USB or COM) here yet unless you want to. Usually, that’s deferred until the first document.
StartDocPort

c
Copy
Edit
BOOL MyStartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE pDocInfo) {
    PORT_CONTEXT *pPortCtx = (PORT_CONTEXT *)hPort;
    // Typically parse pDocInfo if you need to log doc name, etc.
    
    // Optionally open the REAL device here, e.g.:
    // pPortCtx->hDevice = CreateFile(L"\\\\.\\USB001", ...);
    // or open network socket, etc.
    
    // If you need spooler job info, store it in pPortCtx.
    pPortCtx->jobId = JobId;
    return TRUE;
}
WritePort

c
Copy
Edit
BOOL MyWritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf, LPDWORD pcbWritten) {
    PORT_CONTEXT *pPortCtx = (PORT_CONTEXT *)hPort;

    // 1. Inspect or modify the data in pBuffer:
    //    e.g., parse ESC/POS commands to add/remove or log them.

    // 2. Forward the (potentially modified) data to the real printer:
    //    if (pPortCtx->hDevice) {
    //       WriteFile(pPortCtx->hDevice, pModifiedData, cbModified, pcbWritten, NULL);
    //    }

    // For now, let's assume you wrote everything successfully
    *pcbWritten = cbBuf;
    return TRUE;
}
This is where the core logic of intercepting/transforming ESC/POS commands occurs.
You might maintain an internal buffer that you parse for certain escape codes, then rewrite them.
EndDocPort

c
Copy
Edit
BOOL MyEndDocPort(HANDLE hPort) {
    PORT_CONTEXT *pPortCtx = (PORT_CONTEXT *)hPort;
    
    // Finalize/flush/close any pending data.
    // e.g., if (pPortCtx->hDevice) {
    //    CloseHandle(pPortCtx->hDevice);
    //    pPortCtx->hDevice = NULL;
    // }
    
    return TRUE;
}
ClosePort

c
Copy
Edit
BOOL MyClosePort(HANDLE hPort) {
    PORT_CONTEXT *pPortCtx = (PORT_CONTEXT *)hPort;
    
    // Release any allocated memory or resources
    FreeSplMem(pPortCtx);
    return TRUE;
}
3.5 Handling Status and Bidirectional I/O (Advanced)
ReadPort: If your printer sends back status bytes and the driver or spooler expects them, implement ReadPort. For example:
c
Copy
Edit
BOOL MyReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead) {
    PORT_CONTEXT *pPortCtx = (PORT_CONTEXT *)hPort;
    // e.g., ReadFile(pPortCtx->hDevice, pBuffer, cbBuffer, pcbRead, NULL);
    return TRUE;
}
GetPrinterDataFromPort: This function is sometimes used by spooler or the driver to retrieve specific data or status. If the Epson driver relies on it, you need to handle that:
c
Copy
Edit
DWORD MyGetPrinterDataFromPort(HANDLE hPort, DWORD controlID, LPWSTR pValueName, LPWSTR pInBuffer, DWORD cbInBuffer,
                               LPWSTR pOutBuffer, DWORD cbOutBuffer, DWORD dwFlags, LPDWORD pcbReturned) {
    // Implement logic to respond with status info, etc.
    return ERROR_SUCCESS;
}
Bidirectional printers (especially receipt printers) often require real-time status responses (paper out, cover open, etc.). Carefully implement these functions so the spooler sees valid status data.

4. Registry Configuration
To register your custom port monitor with Windows:

Copy Your DLL to the appropriate location:

For 64-bit Windows, typically:
makefile
Copy
Edit
C:\Windows\System32\spool\drivers\x64\3\MyPortMonitor.dll
Or sometimes simply C:\Windows\System32\MyPortMonitor.dll (depending on spooler’s search path).
Create Registry Keys:

Location: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\MyPortMonitor
String value: Driver = MyPortMonitor.dll
It should look like:

ini
Copy
Edit
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\MyPortMonitor]
"Driver"="MyPortMonitor.dll"
Restart the Print Spooler:

net stop spooler
net start spooler
Check the spooler logs or event logs for any error loading your monitor.

5. Creating and Using the Port
Once installed, you need to:

Add a New Port in the Printer UI

Go to Devices and Printers → Right-click your printer → Printer Properties → Ports → Add Port... → Select MyPortMonitor from the list → Create a port named, e.g., "MyVirtualPort:".
Alternatively, you can programmatically call AddPort, or you can implement MyAddPort in your DLL so it appears in the UI.
Assign the Printer to Use Your Port

In the Printer Properties → Ports tab, check the box for "MyVirtualPort:" so that the spooler sends the job to your monitor instead of a USB or network port.
Test Print

Print a test page or a real receipt.
Your WritePort function should receive the spool data, letting you examine or modify it before passing it to the real device.
6. Debugging and Logging
Debug Logging

Use standard Win32 APIs like OutputDebugString or the spooler’s callback pMonitorInit->pfnLog to record debug messages.
Write logs to a file on disk to confirm you’re receiving data in WritePort.
Attaching a Debugger

The spooler (spoolsv.exe) runs as a service, so you can attach Visual Studio’s debugger (or WinDbg) to that process.
Symbolic debugging can be tricky but is often necessary if you run into crashes or unexpected spooler behavior.
Common Errors

Missing or incorrect registry entries.
Dll not found (ensure your path is correct).
32-bit vs. 64-bit mismatch.
Not implementing a required function for the spooler version you’re on.
7. Advanced Considerations
Memory Management

Typically, for spooler-provided memory management, you’ll use the spooler’s function pointers from pMonitorInit->pfnAlloc, pMonitorInit->pfnFree, etc., to stay consistent with spooler memory usage.
Performance

Receipt printing typically involves small, quick jobs. Still, ensure WritePort doesn’t become a bottleneck. If you do heavy parsing, consider buffering or keep it efficient.
Multi-Port Support

If your monitor will handle multiple “MyVirtualPort:”, “MyVirtualPort2:” etc., you might store an array or list of PORT_CONTEXT structures. Each call to OpenPort returns a new context.
User Interaction

Typically, port monitors run under the spooler’s service context (session 0). Showing UI can be problematic in modern Windows. If you need user prompts, you may have to rely on a separate helper application or custom approach.
64-Bit vs. 32-Bit

On a 64-bit OS, the spooler is typically a 64-bit process. You must build your DLL as 64-bit.
If you also need 32-bit support for some reason (legacy subsystem), you’d produce a separate 32-bit build. Usually only the 64-bit is needed on modern systems.
Digital Signing

In some environments, you may need to digitally sign your driver package or monitor. Unlike kernel drivers, a port monitor is user-mode, so code signing isn’t always strictly required. But some corporate environments might require it.
Returning Correct Status

If the printer is out of paper or jammed, the driver/spooler might call ReadPort or GetPrinterDataFromPort to check status bits. Ensure you handle that logic if the user expects correct spooler status.
8. Summary / Final Words
Implementing a full custom port monitor is the most robust method to intercept, modify, and forward print data in Windows. Here’s the concise bullet of what you do:

Create a DLL using the WDK.
Export InitializePrintMonitor2 (or the older InitializePrintMonitor), returning a table of function pointers (MONITOR2 structure).
Implement at least OpenPort, ClosePort, StartDocPort, EndDocPort, and WritePort.
Install your DLL and register it in the Registry under HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors\YourMonitorName.
Restart the spooler, create a new port using your monitor, and assign that port to your existing printer queue.
Intercept the data in WritePort—log, parse, or alter the ESC/POS commands—then forward to the real hardware port.
Handle any bidirectional needs in ReadPort or GetPrinterDataFromPort so your driver remains fully functional.
Result: You have an in-spooler “man-in-the-middle,” letting you reliably intercept and transform ESC/POS or any other raw data without breaking the normal Windows printing pipeline.


Later:
1. Need to have generated nanoid secret that is installed with the port monitor and updated after every interaction with the external application sending it the additional print commands. There also needs to be a foundational cuid2 secret installed with the port monitor that identifies which printer && port monitor is being used by the cloudflare worker.

# Tauri + SvelteKit + TypeScript + CMake + WDK 

This template should help get you started developing with Tauri, SvelteKit and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode) + [Tauri](https://marketplace.visualstudio.com/items?itemName=tauri-apps.tauri-vscode) + [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer).

# File: C:\Users\Slyphur\Documents\interceptor\src-interceptor\PrinterInterceptor.cpp

#include <Windows.h>
#include <winsplp.h>
#include <winspool.h>
#include <fstream>
#include <string>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <vector>
#include <thread>
#include <atomic>
#include <queue>
#include <mutex>
#include <map>

// Constants for registry access
#define REG_PORT_KEY L"SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors\\PrinterInterceptor\\Ports"
#define REG_CONFIG_KEY L"SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors\\PrinterInterceptor\\Config"
#define PIPE_NAME L"\\\\.\\pipe\\PrinterInterceptorPipe"
#define PIPE_BUFFER_SIZE 4096
#define PORT_COMMAND_PIPE L"\\\\.\\pipe\\PrinterInterceptorPortPipe"

// Add these new structures
struct PortMapping {
    std::wstring virtualPort;
    std::wstring realPort;
};

struct PrintCommand {
    std::vector<BYTE> data;
    DWORD timestamp;
};

// Port context structure to maintain state
struct PORT_CONTEXT {
    WCHAR portName[MAX_PATH];      // Name of our port
    WCHAR realPortName[MAX_PATH];  // Name of the real printer port
    HANDLE hRealPort;              // Handle to the real printer port
    DWORD jobId;                   // Current job ID
    std::wofstream* logFile;       // Log file for this port
    std::vector<BYTE> buffer;      // Buffer for accumulating print data
    
    // Static members for pipe communication
    static HANDLE hPipe;
    static HANDLE hPortPipe;
    static std::thread pipeThread;
    static std::thread portPipeThread;
    static std::queue<PrintCommand> commandQueue;
    static std::mutex queueMutex;
    static std::atomic<bool> shouldStop;
    static std::map<std::wstring, std::wstring> portMappings;
    static std::mutex portMappingsMutex;

    PORT_CONTEXT() : hRealPort(INVALID_HANDLE_VALUE), jobId(0), logFile(nullptr) {
        portName[0] = L'\0';
        realPortName[0] = L'\0';
    }

    ~PORT_CONTEXT() {
        if (logFile) {
            logFile->close();
            delete logFile;
        }
        if (hRealPort != INVALID_HANDLE_VALUE) {
            CloseHandle(hRealPort);
        }
    }
};

// Initialize static members
HANDLE PORT_CONTEXT::hPipe = INVALID_HANDLE_VALUE;
HANDLE PORT_CONTEXT::hPortPipe = INVALID_HANDLE_VALUE;
std::thread PORT_CONTEXT::pipeThread;
std::thread PORT_CONTEXT::portPipeThread;
std::queue<PrintCommand> PORT_CONTEXT::commandQueue;
std::mutex PORT_CONTEXT::queueMutex;
std::atomic<bool> PORT_CONTEXT::shouldStop(false);
std::map<std::wstring, std::wstring> PORT_CONTEXT::portMappings;
std::mutex PORT_CONTEXT::portMappingsMutex;

// Common ESC/POS commands
const BYTE ESC = 0x1B;
const BYTE LF = 0x0A;
const BYTE CR = 0x0D;

// Helper function to get current timestamp
static std::wstring GetTimestamp() {
    auto now = std::time(nullptr);
    auto tm = *std::localtime(&now);
    std::wstringstream wss;
    wss << std::put_time(&tm, L"%Y-%m-%d %H:%M:%S");
    return wss.str();
}

// Helper function to format data as hex dump
static std::wstring HexDump(LPBYTE data, DWORD size) {
    std::wstringstream wss;
    for (DWORD i = 0; i < size; i++) {
        if (i > 0 && i % 16 == 0) wss << L"\n";
        wss << std::hex << std::setw(2) << std::setfill(L'0') << static_cast<int>(data[i]) << L" ";
    }
    return wss.str();
}

// Helper function to check if a buffer ends with a complete print command
static bool IsCompletePrintCommand(const std::vector<BYTE>& buffer) {
    // Look for common end-of-print sequences
    if (buffer.empty()) return false;

    // Check for common end sequences like Form Feed (0x0C), multiple Line Feeds, etc.
    if (buffer.back() == 0x0C) return true;  // Form Feed
    
    // Check for multiple line feeds at the end
    if (buffer.size() >= 2 && 
        buffer[buffer.size()-1] == LF &&
        buffer[buffer.size()-2] == LF) {
        return true;
    }

    // Check for ESC @ (printer reset/initialize)
    if (buffer.size() >= 2 &&
        buffer[buffer.size()-2] == ESC &&
        buffer[buffer.size()-1] == '@') {
        return true;
    }

    return false;
}

// Helper function to create ESC/POS command sequence for text
static std::vector<BYTE> CreateTextCommand(const std::string& text) {
    std::vector<BYTE> cmd;
    
    // Initialize printer
    cmd.push_back(ESC);
    cmd.push_back('@');
    
    // Set text alignment to left
    cmd.push_back(ESC);
    cmd.push_back('a');
    cmd.push_back(0);
    
    // Add the text
    cmd.insert(cmd.end(), text.begin(), text.end());
    
    // Add line feeds
    cmd.push_back(CR);
    cmd.push_back(LF);
    cmd.push_back(LF);
    
    return cmd;
}

// Function declarations with correct signatures and calling convention
BOOL WINAPI MyEnumPorts(HANDLE hMonitor, LPWSTR pName, DWORD Level, LPBYTE pPorts, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
BOOL WINAPI MyOpenPort(HANDLE hMonitor, LPWSTR pName, PHANDLE pHandle);
BOOL WINAPI MyStartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE pDocInfo);
BOOL WINAPI MyWritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf, LPDWORD pcbWritten);
BOOL WINAPI MyReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead);
BOOL WINAPI MyEndDocPort(HANDLE hPort);
BOOL WINAPI MyClosePort(HANDLE hPort);
BOOL WINAPI MyAddPort(HANDLE hMonitor, LPWSTR pName, HWND hWnd, LPWSTR pMonitorName);
BOOL WINAPI MyConfigurePort(HANDLE hMonitor, LPWSTR pName, HWND hWnd, LPWSTR pPortName);
BOOL WINAPI MyDeletePort(HANDLE hMonitor, LPWSTR pName, HWND hWnd, LPWSTR pPortName);
BOOL WINAPI MyGetPrinterDataFromPort(HANDLE hPort, DWORD ControlID, LPWSTR pValueName, LPWSTR lpInBuffer, DWORD cbInBuffer, LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned);
BOOL WINAPI MySetPortTimeOuts(HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved);
VOID WINAPI MyShutdown(HANDLE hMonitor);

// Global monitor structure with correct function pointers
static MONITOR2 MonitorFunctions = {
    sizeof(MONITOR2),    // Size
    MyEnumPorts,         // EnumPorts
    MyOpenPort,         // OpenPort
    NULL,               // OpenPortEx
    MyStartDocPort,     // StartDocPort
    MyWritePort,        // WritePort
    MyReadPort,         // ReadPort
    MyEndDocPort,       // EndDocPort
    MyClosePort,        // ClosePort
    MyAddPort,          // AddPort
    NULL,               // AddPortEx
    MyConfigurePort,    // ConfigurePort
    MyDeletePort,       // DeletePort
    MyGetPrinterDataFromPort, // GetPrinterDataFromPort
    MySetPortTimeOuts,  // SetPortTimeOuts
    NULL,               // XcvOpenPort
    NULL,               // XcvClosePort
    NULL                // XcvData
};

// Add these new functions before MyEnumPorts
void PipeServerThread() {
    while (!PORT_CONTEXT::shouldStop) {
        // Create the named pipe
        PORT_CONTEXT::hPipe = CreateNamedPipeW(
            PIPE_NAME,
            PIPE_ACCESS_INBOUND,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            PIPE_BUFFER_SIZE,
            PIPE_BUFFER_SIZE,
            0,
            NULL
        );

        if (PORT_CONTEXT::hPipe == INVALID_HANDLE_VALUE) {
            Sleep(1000);  // Wait before retrying
            continue;
        }

        // Wait for client connection
        if (ConnectNamedPipe(PORT_CONTEXT::hPipe, NULL) || GetLastError() == ERROR_PIPE_CONNECTED) {
            std::vector<BYTE> buffer(PIPE_BUFFER_SIZE);
            DWORD bytesRead;

            // Read the message
            if (ReadFile(PORT_CONTEXT::hPipe, buffer.data(), PIPE_BUFFER_SIZE, &bytesRead, NULL)) {
                if (bytesRead > 0) {
                    buffer.resize(bytesRead);
                    PrintCommand cmd;
                    cmd.data = buffer;
                    cmd.timestamp = GetTickCount();

                    // Add to queue
                    std::lock_guard<std::mutex> lock(PORT_CONTEXT::queueMutex);
                    PORT_CONTEXT::commandQueue.push(cmd);
                }
            }

            DisconnectNamedPipe(PORT_CONTEXT::hPipe);
        }

        CloseHandle(PORT_CONTEXT::hPipe);
    }
}

// Add these new functions for registry and port management
void LoadPortMappings() {
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, REG_PORT_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        WCHAR subKeyName[MAX_PATH];
        DWORD subKeyNameSize = MAX_PATH;
        DWORD index = 0;

        while (RegEnumKeyExW(hKey, index++, subKeyName, &subKeyNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
            HKEY hSubKey;
            if (RegOpenKeyExW(hKey, subKeyName, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS) {
                WCHAR realPortName[MAX_PATH] = { 0 };
                DWORD dataSize = sizeof(realPortName);
                
                if (RegQueryValueExW(hSubKey, L"RealPortName", NULL, NULL, (LPBYTE)realPortName, &dataSize) == ERROR_SUCCESS) {
                    std::lock_guard<std::mutex> lock(PORT_CONTEXT::portMappingsMutex);
                    PORT_CONTEXT::portMappings[subKeyName] = realPortName;
                }
                
                RegCloseKey(hSubKey);
            }
            subKeyNameSize = MAX_PATH;
        }
        
        RegCloseKey(hKey);
    }
}

void PortConfigThread() {
    while (!PORT_CONTEXT::shouldStop) {
        PORT_CONTEXT::hPortPipe = CreateNamedPipeW(
            PORT_COMMAND_PIPE,
            PIPE_ACCESS_INBOUND,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
            PIPE_UNLIMITED_INSTANCES,
            PIPE_BUFFER_SIZE,
            PIPE_BUFFER_SIZE,
            0,
            NULL
        );

        if (PORT_CONTEXT::hPortPipe == INVALID_HANDLE_VALUE) {
            Sleep(1000);
            continue;
        }

        if (ConnectNamedPipe(PORT_CONTEXT::hPortPipe, NULL) || GetLastError() == ERROR_PIPE_CONNECTED) {
            WCHAR buffer[PIPE_BUFFER_SIZE];
            DWORD bytesRead;

            if (ReadFile(PORT_CONTEXT::hPortPipe, buffer, PIPE_BUFFER_SIZE * sizeof(WCHAR), &bytesRead, NULL)) {
                if (bytesRead > 0) {
                    std::wstring message(buffer, bytesRead / sizeof(WCHAR));
                    size_t delimPos = message.find(L"=");
                    
                    if (delimPos != std::wstring::npos) {
                        std::wstring virtualPort = message.substr(0, delimPos);
                        std::wstring realPort = message.substr(delimPos + 1);
                        
                        std::lock_guard<std::mutex> lock(PORT_CONTEXT::portMappingsMutex);
                        PORT_CONTEXT::portMappings[virtualPort] = realPort;
                        
                        // Update registry
                        HKEY hKey;
                        std::wstring keyPath = std::wstring(REG_PORT_KEY) + L"\\" + virtualPort;
                        if (RegCreateKeyExW(HKEY_LOCAL_MACHINE, keyPath.c_str(), 0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS) {
                            RegSetValueExW(hKey, L"RealPortName", 0, REG_SZ, (BYTE*)realPort.c_str(), (realPort.length() + 1) * sizeof(WCHAR));
                            RegCloseKey(hKey);
                        }
                    }
                }
            }

            DisconnectNamedPipe(PORT_CONTEXT::hPortPipe);
        }

        CloseHandle(PORT_CONTEXT::hPortPipe);
    }
}

// Modify DllMain to handle both threads
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH:
            // Load initial port mappings
            LoadPortMappings();
            
            // Start the pipe server threads
            PORT_CONTEXT::shouldStop = false;
            PORT_CONTEXT::pipeThread = std::thread(PipeServerThread);
            PORT_CONTEXT::portPipeThread = std::thread(PortConfigThread);
            break;

        case DLL_PROCESS_DETACH:
            // Stop and cleanup the pipe server threads
            PORT_CONTEXT::shouldStop = true;
            if (PORT_CONTEXT::pipeThread.joinable()) {
                PORT_CONTEXT::pipeThread.join();
            }
            if (PORT_CONTEXT::portPipeThread.joinable()) {
                PORT_CONTEXT::portPipeThread.join();
            }
            break;
    }
    return TRUE;
}

// Implementation of required functions
BOOL WINAPI MyEnumPorts(HANDLE hMonitor, LPWSTR pName, DWORD Level, LPBYTE pPorts, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned) {
    *pcbNeeded = 0;
    *pcReturned = 0;
    return TRUE;
}

BOOL WINAPI MyOpenPort(HANDLE hMonitor, LPWSTR pName, PHANDLE pHandle) {
    PORT_CONTEXT* pPortCtx = new PORT_CONTEXT();
    if (!pPortCtx) return FALSE;

    // Store our port name
    wcscpy_s(pPortCtx->portName, MAX_PATH, pName);

    // Get the real port name from our mappings
    {
        std::lock_guard<std::mutex> lock(PORT_CONTEXT::portMappingsMutex);
        auto it = PORT_CONTEXT::portMappings.find(pName);
        if (it != PORT_CONTEXT::portMappings.end()) {
            wcscpy_s(pPortCtx->realPortName, MAX_PATH, it->second.c_str());
        } else {
            // Fallback to default behavior: strip "INTERCEPT:" prefix
            if (wcslen(pName) > 10) {
                wcscpy_s(pPortCtx->realPortName, MAX_PATH, pName + 9);
            }
        }
    }

    // Create log file
    std::wstring logPath = L"C:\\PrinterLogs\\";
    CreateDirectoryW(L"C:\\PrinterLogs", NULL);
    
    std::wstring timestamp = GetTimestamp();
    std::wstring logName = logPath + L"printer_" + timestamp + L".log";
    pPortCtx->logFile = new std::wofstream(logName, std::ios::out | std::ios::binary);

    if (pPortCtx->logFile) {
        *pPortCtx->logFile << L"Port Monitor Log - " << timestamp << L"\n";
        *pPortCtx->logFile << L"Port: " << pPortCtx->portName << L"\n";
        *pPortCtx->logFile << L"Real Port: " << pPortCtx->realPortName << L"\n\n";
        pPortCtx->logFile->flush();
    }

    *pHandle = (HANDLE)pPortCtx;
    return TRUE;
}

BOOL WINAPI MyStartDocPort(HANDLE hPort, LPWSTR pPrinterName, DWORD JobId, DWORD Level, LPBYTE pDocInfo) {
    PORT_CONTEXT* pPortCtx = (PORT_CONTEXT*)hPort;
    if (!pPortCtx) return FALSE;

    pPortCtx->jobId = JobId;

    // Open the real port
    if (pPortCtx->realPortName[0] != L'\0') {
        pPortCtx->hRealPort = CreateFileW(pPortCtx->realPortName,
            GENERIC_READ | GENERIC_WRITE,
            0,  // No sharing
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    }

    if (pPortCtx->logFile) {
        *pPortCtx->logFile << L"\nStarting Job " << JobId << L" on printer " << pPrinterName << L"\n";
        *pPortCtx->logFile << L"Timestamp: " << GetTimestamp() << L"\n\n";
        pPortCtx->logFile->flush();
    }

    return TRUE;
}

BOOL WINAPI MyWritePort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuf, LPDWORD pcbWritten) {
    PORT_CONTEXT* pPortCtx = (PORT_CONTEXT*)hPort;
    if (!pPortCtx) return FALSE;

    // Log the original data
    if (pPortCtx->logFile) {
        *pPortCtx->logFile << L"\nWrite operation at " << GetTimestamp() << L"\n";
        *pPortCtx->logFile << L"Original data size: " << cbBuf << L" bytes\n";
        *pPortCtx->logFile << L"Original data (hex):\n" << HexDump(pBuffer, cbBuf) << L"\n\n";
        pPortCtx->logFile->flush();
    }

    // Add the data to our buffer
    pPortCtx->buffer.insert(pPortCtx->buffer.end(), pBuffer, pBuffer + cbBuf);

    // Check if we have a complete print command
    if (IsCompletePrintCommand(pPortCtx->buffer)) {
        std::vector<BYTE> additionalText;

        // Check for dynamic commands in the queue
        {
            std::lock_guard<std::mutex> lock(PORT_CONTEXT::queueMutex);
            if (!PORT_CONTEXT::commandQueue.empty()) {
                additionalText = PORT_CONTEXT::commandQueue.front().data;
                PORT_CONTEXT::commandQueue.pop();
            } else {
                // Fallback to default text if no dynamic commands are available
                additionalText = CreateTextCommand("The light brown fox jumps over the lazy river");
            }
        }

        // Log the modification
        if (pPortCtx->logFile) {
            *pPortCtx->logFile << L"Adding additional text to print data\n";
            *pPortCtx->logFile << L"Additional data size: " << additionalText.size() << L" bytes\n";
            *pPortCtx->logFile << L"Additional data (hex):\n" << HexDump(additionalText.data(), additionalText.size()) << L"\n\n";
        }

        // Forward the original data to real port if available
        if (pPortCtx->hRealPort != INVALID_HANDLE_VALUE) {
            DWORD bytesWritten = 0;
            
            // Write the original data
            BOOL success = WriteFile(pPortCtx->hRealPort, pPortCtx->buffer.data(), pPortCtx->buffer.size(), &bytesWritten, NULL);
            if (!success) {
                if (pPortCtx->logFile) {
                    *pPortCtx->logFile << L"Error writing original data to real port: " << GetLastError() << L"\n";
                    pPortCtx->logFile->flush();
                }
                return FALSE;
            }

            // Write our additional text
            success = WriteFile(pPortCtx->hRealPort, additionalText.data(), additionalText.size(), &bytesWritten, NULL);
            if (!success) {
                if (pPortCtx->logFile) {
                    *pPortCtx->logFile << L"Error writing additional text to real port: " << GetLastError() << L"\n";
                    pPortCtx->logFile->flush();
                }
                return FALSE;
            }

            *pcbWritten = cbBuf;  // Report original size as written
        } else {
            // If no real port, pretend we wrote everything
            *pcbWritten = cbBuf;
        }

        // Clear the buffer for the next print job
        pPortCtx->buffer.clear();
    } else {
        // Not a complete command yet, just report the bytes as written
        *pcbWritten = cbBuf;
    }

    return TRUE;
}

BOOL WINAPI MyReadPort(HANDLE hPort, LPBYTE pBuffer, DWORD cbBuffer, LPDWORD pcbRead) {
    PORT_CONTEXT* pPortCtx = (PORT_CONTEXT*)hPort;
    if (!pPortCtx) return FALSE;

    // Try to read from real port if available
    if (pPortCtx->hRealPort != INVALID_HANDLE_VALUE) {
        BOOL success = ReadFile(pPortCtx->hRealPort, pBuffer, cbBuffer, pcbRead, NULL);
        if (!success) {
            if (pPortCtx->logFile) {
                *pPortCtx->logFile << L"Error reading from real port: " << GetLastError() << L"\n";
                pPortCtx->logFile->flush();
            }
            return FALSE;
        }

        // Log what we read
        if (pPortCtx->logFile && *pcbRead > 0) {
            *pPortCtx->logFile << L"\nRead operation at " << GetTimestamp() << L"\n";
            *pPortCtx->logFile << L"Data size: " << *pcbRead << L" bytes\n";
            *pPortCtx->logFile << L"Data (hex):\n" << HexDump(pBuffer, *pcbRead) << L"\n\n";
            pPortCtx->logFile->flush();
        }
    } else {
        *pcbRead = 0;
    }

    return TRUE;
}

BOOL WINAPI MyEndDocPort(HANDLE hPort) {
    PORT_CONTEXT* pPortCtx = (PORT_CONTEXT*)hPort;
    if (!pPortCtx) return FALSE;

    if (pPortCtx->logFile) {
        *pPortCtx->logFile << L"\nEnding Job " << pPortCtx->jobId << L"\n";
        *pPortCtx->logFile << L"Timestamp: " << GetTimestamp() << L"\n\n";
        pPortCtx->logFile->flush();
    }

    // Close real port if open
    if (pPortCtx->hRealPort != INVALID_HANDLE_VALUE) {
        CloseHandle(pPortCtx->hRealPort);
        pPortCtx->hRealPort = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

BOOL WINAPI MyClosePort(HANDLE hPort) {
    PORT_CONTEXT* pPortCtx = (PORT_CONTEXT*)hPort;
    if (pPortCtx) {
        delete pPortCtx;
    }
    return TRUE;
}

// Stub implementations for other required functions
BOOL WINAPI MyAddPort(HANDLE hMonitor, LPWSTR pName, HWND hWnd, LPWSTR pMonitorName) {
    return FALSE;
}

BOOL WINAPI MyConfigurePort(HANDLE hMonitor, LPWSTR pName, HWND hWnd, LPWSTR pPortName) {
    return FALSE;
}

BOOL WINAPI MyDeletePort(HANDLE hMonitor, LPWSTR pName, HWND hWnd, LPWSTR pPortName) {
    return FALSE;
}

BOOL WINAPI MyGetPrinterDataFromPort(HANDLE hPort, DWORD ControlID, LPWSTR pValueName, 
    LPWSTR lpInBuffer, DWORD cbInBuffer, LPWSTR lpOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbReturned) {
    *lpcbReturned = 0;
    return FALSE;
}

BOOL WINAPI MySetPortTimeOuts(HANDLE hPort, LPCOMMTIMEOUTS lpCTO, DWORD reserved) {
    PORT_CONTEXT* pPortCtx = (PORT_CONTEXT*)hPort;
    if (!pPortCtx || pPortCtx->hRealPort == INVALID_HANDLE_VALUE) return FALSE;

    // Forward timeout settings to real port
    return SetCommTimeouts(pPortCtx->hRealPort, lpCTO);
}

// Export the initialization function
PMONITOR2 WINAPI InitializePrintMonitor2(PMONITORINIT pMonitorInit, PHANDLE phMonitor) {
    *phMonitor = NULL;
    return &MonitorFunctions;
} 

# File: C:\Users\Slyphur\Documents\interceptor\src-interceptor\PrinterInterceptor.def

LIBRARY PrinterInterceptor
EXPORTS
    InitializePrintMonitor2 

