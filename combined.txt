# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/NSIS/install.nsi

/*
 * $Id: install.nsi,v 1.25 2011/12/18 16:42:23 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: install.nsi,v $
 * Revision 1.25  2011/12/18 16:42:23  vfrolov
 * Added ability to build installer with both 32-bit and 64-bit drivers
 *
 * Revision 1.24  2011/12/12 13:17:43  vfrolov
 * Added CNC_INSTALL_SKIP_SETUP_PREINSTALL and CNC_UNINSTALL_SKIP_SETUP_UNINSTALL environment variables
 *
 * Revision 1.23  2011/07/14 15:02:41  vfrolov
 * Added packaging com0com.cat (if file exists)
 *
 * Revision 1.22  2011/07/14 12:12:28  vfrolov
 * Fixed mistaken execution of executables located in installer's folder
 *
 * Revision 1.21  2011/07/12 18:10:11  vfrolov
 * Added launching setupg.exe rather then setupc.exe if .NET is OK
 * Disabled installing ports by default while update
 *
 * Revision 1.20  2011/07/08 10:19:19  vfrolov
 * Added ability to set selections for setup.exe by setting environment variables
 *
 * Revision 1.19  2010/06/01 06:14:09  vfrolov
 * Improved driver updating
 *
 * Revision 1.18  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.17  2009/05/22 11:32:52  vfrolov
 * Added URLInfoAbout, InstallLocation, InstallSource, Language, Version
 * and EstimatedSize to the registry
 * Added Windows version check
 *
 * Revision 1.16  2009/05/21 15:39:34  vfrolov
 * Added DisplayIcon, DisplayVersion, VersionMajor, VersionMinor
 * and QuietUninstallString to the registry
 *
 * Revision 1.15  2009/05/20 13:02:18  vfrolov
 * Changed MUI.nsh to MUI2.nsh
 * Added .NET check and advise
 * Disabled silent installing of linked ports
 *
 * Revision 1.14  2009/01/12 13:16:20  vfrolov
 * Added driver updating
 *
 * Revision 1.13  2008/09/12 12:29:53  vfrolov
 * Added --silent option
 *
 * Revision 1.12  2007/11/30 09:53:37  vfrolov
 * Added license page
 *
 * Revision 1.11  2007/11/23 08:23:29  vfrolov
 * Added popup for uncompatible CPU
 *
 * Revision 1.10  2007/11/22 11:36:41  vfrolov
 * Moved output file to target CPU directory
 * Disabled moving Start Menu shortcuts to all users for Vista
 * Fixed title truncation
 * Added show ReadMe checkbox
 * Added setupg.exe
 *
 * Revision 1.9  2007/11/15 12:12:04  vfrolov
 * Removed Function LaunchSetupCommandPrompt
 * Added MUI_FINISHPAGE_LINK
 *
 * Revision 1.8  2007/10/30 15:06:14  vfrolov
 * Added changing working directory before removing $INSTDIR
 *
 * Revision 1.7  2007/10/25 14:30:27  vfrolov
 * Replaced setup.bat by setupc.exe
 *
 * Revision 1.6  2007/08/08 14:15:16  vfrolov
 * Added missing SetOutPath
 *
 * Revision 1.5  2007/01/22 17:10:32  vfrolov
 * Partially added support for non i386 CPUs
 *
 * Revision 1.4  2006/12/14 08:25:44  vfrolov
 * Added ReadMe.lnk
 *
 * Revision 1.3  2006/11/22 07:58:45  vfrolov
 * Changed uninstall keys
 *
 * Revision 1.2  2006/11/21 11:43:42  vfrolov
 * Added Modern UI
 * Added "CNCA0<->CNCB0" section
 * Added "Launch Setup Command Prompt" on finish page
 *
 * Revision 1.1  2006/10/23 12:26:02  vfrolov
 * Initial revision
 *
 */

;--------------------------------

  !include "MUI2.nsh"
  !include "WinVer.nsh"
  !include "x64.nsh"
  !include WordFunc.nsh
  !insertmacro VersionCompare
  !include "FileFunc.nsh"

;--------------------------------

!ifndef OUTPUT_FILE
  !ifndef ADD_TARGET_CPU_i386
    !ifndef ADD_TARGET_CPU_amd64
      !ifndef ADD_TARGET_CPU_ia64
        !if "$%BUILD_DEFAULT_TARGETS%" == "-386"
          !define OUTPUT_FILE "..\i386\setup.exe"
          !define ADD_TARGET_CPU_i386
        !else if "$%BUILD_DEFAULT_TARGETS%" == "-AMD64"
          !define OUTPUT_FILE "..\amd64\setup.exe"
          !define ADD_TARGET_CPU_amd64
        !else if "$%BUILD_DEFAULT_TARGETS%" == "-amd64"
          !define OUTPUT_FILE "..\amd64\setup.exe"
          !define ADD_TARGET_CPU_amd64
        !else if "$%BUILD_DEFAULT_TARGETS%" == "-IA64"
          !define OUTPUT_FILE "..\ia64\setup.exe"
          !define ADD_TARGET_CPU_ia64
        !else if "$%BUILD_DEFAULT_TARGETS%" == "-ia64"
          !define OUTPUT_FILE "..\ia64\setup.exe"
          !define ADD_TARGET_CPU_ia64
        !else
          !define OUTPUT_FILE "..\i386\setup.exe"
          !define ADD_TARGET_CPU_i386
          !Warning "Using target CPU i386"
        !endif
      !endif
    !endif
  !endif
!endif

!ifndef OUTPUT_FILE
  !Error "Not defined OUTPUT_FILE"
!endif

;--------------------------------

Function GetDotNETVersion
  Push $0
  Push $1

  System::Call "mscoree::GetCORVersion(w .r0, i ${NSIS_MAX_STRLEN}, *i) i .r1 ?u"
  StrCmp $1 0 +2
    StrCpy $0 "v0"

  StrCpy $0 $0 "" 1 # skip "v"

  Pop $1
  Exch $0
FunctionEnd

;--------------------------------

Function AdviseDotNETVersion
  IfSilent 0 +2
    return

  Push $0
  Push $1
  Push $2

  Call GetDotNETVersion
  Pop $0

  StrCpy $1 "2.0"

  ${VersionCompare} $0 $1 $2
  ${If} $2 == 2
    MessageBox MB_OK|MB_ICONINFORMATION \
      "To use GUI-based Setup utility you will need to$\ninstall Microsoft .NET Framework v$1 or newer."
  ${EndIf}

  Pop $2
  Pop $1
  Pop $0
FunctionEnd

;--------------------------------

Function LaunchSetup
  IfSilent 0 +2
    return

  Push $0
  Push $1
  Push $2

  Call GetDotNETVersion
  Pop $0

  StrCpy $1 "2.0"

  ${VersionCompare} $0 $1 $2
  ${If} $2 == 2
    Exec '"$INSTDIR\setupc.exe"'
  ${Else}
    Exec '"$INSTDIR\setupg.exe"'
  ${EndIf}

  Pop $2
  Pop $1
  Pop $0
FunctionEnd

;--------------------------------

!macro MoveFileToDetails file

  Push $0
  Push $1
  Push $2
  Push $3

  StrCpy $0 "${file}"

  FileOpen $1 $0 r
  IfErrors +9

    FileRead $1 $2
    IfErrors +7

    StrCpy $3 $2 2 -2
    StrCmp $3 "$\r$\n" 0 +2
      StrCpy $2 $2 -2

    StrCmp $2 "" +2
      DetailPrint $2

    Goto -7

  FileClose $1
  Delete $0

  Pop $3
  Pop $2
  Pop $1
  Pop $0

!macroend

;--------------------------------

!macro EnvToSel section env

  Push $0
  Push $1

  ReadEnvStr $0 ${env}
  StrCpy $0 $0 1
  ${Select} $0
    ${Case2} "Y" "y"
      SectionGetFlags ${section} $0
      IntOp $0 $0 | ${SF_SELECTED}
      SectionSetFlags ${section} $0
    ${Case2} "N" "n"
      SectionGetFlags ${section} $0
      IntOp $1 ${SF_SELECTED} ~
      IntOp $0 $0 & $1
      SectionSetFlags ${section} $0
  ${EndSelect}
  Pop $1
  Pop $0

!macroend

;--------------------------------

; The name of the installer
Name "Null-modem emulator (com0com)"

; The file to write
;!Warning "Using output file '${OUTPUT_FILE}'"
OutFile "${OUTPUT_FILE}"

; The default installation directory
InstallDir $PROGRAMFILES\com0com

; Registry key to check for directory (so if you install again, it will
; overwrite the old one automatically)
InstallDirRegKey HKLM "Software\com0com" "Install_Dir"

;Vista redirects $SMPROGRAMS to all users without this
RequestExecutionLevel admin

ShowInstDetails show
ShowUninstDetails show

;--------------------------------
; Pages

  !define MUI_WELCOMEPAGE_TITLE_3LINES
  !define MUI_FINISHPAGE_TITLE_3LINES

  !define MUI_FINISHPAGE_RUN
  !define MUI_FINISHPAGE_RUN_TEXT "Launch Setup"
  !define MUI_FINISHPAGE_RUN_FUNCTION LaunchSetup
  !define MUI_FINISHPAGE_RUN_NOTCHECKED

  !define MUI_FINISHPAGE_SHOWREADME ReadMe.txt
  !define MUI_FINISHPAGE_SHOWREADME_NOTCHECKED

  !define MUI_FINISHPAGE_LINK "Visit com0com homepage"
  !define MUI_FINISHPAGE_LINK_LOCATION http://com0com.sourceforge.net/

  !define MUI_FINISHPAGE_NOAUTOCLOSE

  !insertmacro MUI_PAGE_WELCOME
  !insertmacro MUI_PAGE_LICENSE "..\license.txt"
  !insertmacro MUI_PAGE_COMPONENTS
  !insertmacro MUI_PAGE_DIRECTORY
  !insertmacro MUI_PAGE_INSTFILES
  !insertmacro MUI_PAGE_FINISH

  !define MUI_WELCOMEPAGE_TITLE_3LINES
  !define MUI_FINISHPAGE_TITLE_3LINES
  !define MUI_UNFINISHPAGE_NOAUTOCLOSE

  !insertmacro MUI_UNPAGE_WELCOME
  !insertmacro MUI_UNPAGE_CONFIRM
  !insertmacro MUI_UNPAGE_INSTFILES
  !insertmacro MUI_UNPAGE_FINISH

;--------------------------------
; Languages

  !insertmacro MUI_LANGUAGE "English"

;--------------------------------

!macro CpuSection cpu

  !ifdef ADD_TARGET_CPU_${cpu}

    ;!Warning "Adding CPU ${cpu}"

    Section /o "-com0com ${cpu}" sec_com0com_${cpu}

      ; Set output path to the installation directory.
      SetOutPath $INSTDIR

      ; Put target cpu files there
      File "..\${cpu}\com0com.sys"
      File /nonfatal "..\${cpu}\com0com.cat"
      File "..\${cpu}\setup.dll"
      File "..\${cpu}\setupc.exe"

    SectionEnd

  !endif

!macroend

;--------------------------------

!insertmacro CpuSection i386
!insertmacro CpuSection amd64
!insertmacro CpuSection ia64

;--------------------------------

Section "com0com" sec_com0com

  SectionIn RO

  ; Set output path to the installation directory.
  SetOutPath $INSTDIR

  ; Put files there
  File "..\ReadMe.txt"
  File "..\com0com.inf"
  File "..\cncport.inf"
  File "..\comport.inf"
  File "..\setupg\Release\setupg.exe"

  WriteUninstaller "uninstall.exe"

  ; Write the installation path into the registry
  WriteRegStr HKLM SOFTWARE\com0com "Install_Dir" "$INSTDIR"

  ; Write the uninstall keys for Windows
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "DisplayName" "Null-modem emulator (com0com)"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "Publisher" "Vyacheslav Frolov"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "HelpLink" "http://com0com.sourceforge.net/"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "URLUpdateInfo" "http://com0com.sourceforge.net/"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "URLInfoAbout" "http://com0com.sourceforge.net/"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "Readme" "$INSTDIR\ReadMe.txt"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "DisplayIcon" "$INSTDIR\setupg.exe"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "InstallLocation" "$INSTDIR\"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "InstallSource" "$EXEDIR\"
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "Language" $LANGUAGE

  GetDLLVersion "$INSTDIR\com0com.sys" $R0 $R1
  IntOp $R2 $R0 / 0x00010000
  IntOp $R3 $R0 & 0x0000FFFF
  IntOp $R4 $R1 / 0x00010000
  IntOp $R5 $R1 & 0x0000FFFF
  IntOp $R5 $R1 & 0x0000FFFF
  IntOp $R6 $R2 * 0x00000100
  IntOp $R6 $R6 | $R3
  IntOp $R6 $R6 * 0x00000100
  IntOp $R6 $R6 | $R4
  IntOp $R6 $R6 * 0x00000100
  IntOp $R6 $R6 | $R5

  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "DisplayVersion" "$R2.$R3.$R4.$R5"
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "Version" $R6
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "VersionMajor" $R2
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "VersionMinor" $R3

  ${GetSize} "$INSTDIR" "/S=0B" $R0 $R1 $R2
  IntOp $R0 $R0 / 1024  ; in KBytes

  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "EstimatedSize" $R0

  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "UninstallString" '"$INSTDIR\uninstall.exe"'
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "QuietUninstallString" '"$INSTDIR\uninstall.exe" /S'
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "NoModify" 1
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com" "NoRepair" 1

  ReadEnvStr $0 "CNC_INSTALL_SKIP_SETUP_PREINSTALL"
  StrCpy $0 $0 1
  ${Select} $0
    ${Case2} "Y" "y"
      DetailPrint 'Skipped "$INSTDIR\setupc.exe" preinstall/update/infclean'
    ${CaseElse}
      GetTempFileName $0

      StrCpy $1 ""
      IfSilent 0 +2
      StrCpy $1 "--silent"

      ExecWait '"$INSTDIR\setupc.exe" $1 --output "$0" preinstall'
      !insertmacro MoveFileToDetails $0

      ExecWait '"$INSTDIR\setupc.exe" $1 --output "$0" update'
      !insertmacro MoveFileToDetails $0

      ExecWait '"$INSTDIR\setupc.exe" $1 --output "$0" infclean'
      !insertmacro MoveFileToDetails $0
  ${EndSelect}

SectionEnd

;--------------------------------

Section "Start Menu Shortcuts" sec_shortcuts

  CreateDirectory "$SMPROGRAMS\com0com"
  CreateShortCut "$SMPROGRAMS\com0com\Setup Command Prompt.lnk" "$INSTDIR\setupc.exe"
  CreateShortCut "$SMPROGRAMS\com0com\Setup.lnk" "$INSTDIR\setupg.exe"
  CreateShortCut "$SMPROGRAMS\com0com\Uninstall.lnk" "$INSTDIR\uninstall.exe" "" "$INSTDIR\uninstall.exe" 0
  CreateShortCut "$SMPROGRAMS\com0com\ReadMe.lnk" "$INSTDIR\ReadMe.txt"

SectionEnd

;--------------------------------

Section "CNCA0 <-> CNCB0" sec_CNCxCNC_ports

  GetTempFileName $0

  StrCpy $1 ""
  IfSilent 0 +2
  StrCpy $1 "--silent"

  ExecWait '"$INSTDIR\setupc.exe" $1 --output "$0" install 0 - -'
  !insertmacro MoveFileToDetails $0

SectionEnd

;--------------------------------

Section "COM# <-> COM#" sec_COMxCOM_ports

  GetTempFileName $0

  StrCpy $1 ""
  IfSilent 0 +2
  StrCpy $1 "--silent"

  ExecWait '"$INSTDIR\setupc.exe" $1 --output "$0" install PortName=COM# PortName=COM#'
  !insertmacro MoveFileToDetails $0

SectionEnd

;--------------------------------

Function .onInit

  ; Check CPU

  ${If} ${RunningX64}
    !ifdef ADD_TARGET_CPU_amd64
      SectionGetFlags ${sec_com0com_amd64} $0
      IntOp $0 $0 | ${SF_SELECTED}
      SectionSetFlags ${sec_com0com_amd64} $0
    !else
      MessageBox MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION \
        "This package does not include 64-bit driver required for your system.$\n$\nContinue?" \
        /SD IDNO IDYES +2
      Abort
    !endif
  ${Else}
    !ifdef ADD_TARGET_CPU_i386
      SectionGetFlags ${sec_com0com_i386} $0
      IntOp $0 $0 | ${SF_SELECTED}
      SectionSetFlags ${sec_com0com_i386} $0
    !else
      MessageBox MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION \
        "This package does not include 32-bit driver required for your system.$\n$\nContinue?" \
        /SD IDNO IDYES +2
      Abort
    !endif
  ${EndIf}

  ; Check Windows version

  ${IfNot} ${AtLeastWin2000}
    MessageBox MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION \
      "The driver cannot run under below Windows 2000 System.$\n$\nContinue?" \
      /SD IDNO IDYES +2
    Abort
  ${EndIf}

  ; Disable installing ports by default if update or silent install

  ClearErrors
  ReadRegStr $0 HKLM SOFTWARE\com0com "Install_Dir"
  IfErrors 0 disable_ports_begin

  IfSilent disable_ports_begin 0
  Goto disable_ports_end

  disable_ports_begin:
    SectionGetFlags ${sec_CNCxCNC_ports} $0
    IntOp $1 ${SF_SELECTED} ~
    IntOp $0 $0 & $1
    SectionSetFlags ${sec_CNCxCNC_ports} $0
    SectionGetFlags ${sec_COMxCOM_ports} $0
    IntOp $1 ${SF_SELECTED} ~
    IntOp $0 $0 & $1
    SectionSetFlags ${sec_COMxCOM_ports} $0
  disable_ports_end:

  ; Set selections from enviroment

  !insertmacro EnvToSel ${sec_shortcuts}     "CNC_INSTALL_START_MENU_SHORTCUTS"
  !insertmacro EnvToSel ${sec_CNCxCNC_ports} "CNC_INSTALL_CNCA0_CNCB0_PORTS"
  !insertmacro EnvToSel ${sec_COMxCOM_ports} "CNC_INSTALL_COMX_COMX_PORTS"

FunctionEnd

;--------------------------------

Function .onInstSuccess
  Call AdviseDotNETVersion
FunctionEnd

;--------------------------------

; Uninstaller

Section "Uninstall"

  ; Set output path to the installation directory.
  SetOutPath $INSTDIR

  ReadEnvStr $0 "CNC_UNINSTALL_SKIP_SETUP_UNINSTALL"
  StrCpy $0 $0 1
  ${Select} $0
    ${Case2} "Y" "y"
      DetailPrint 'Skipped "$INSTDIR\setupc.exe" uninstall'
    ${CaseElse}
      GetTempFileName $0

      StrCpy $1 ""
      IfSilent 0 +2
      StrCpy $1 "--silent"

      ExecWait '"$INSTDIR\setupc.exe" $1 --output "$0" uninstall'
      !insertmacro MoveFileToDetails $0
  ${EndSelect}

  ; Remove registry keys
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\com0com"
  DeleteRegKey HKLM SOFTWARE\com0com

  ; Remove files and uninstaller
  Delete $INSTDIR\ReadMe.txt
  Delete $INSTDIR\com0com.inf
  Delete $INSTDIR\cncport.inf
  Delete $INSTDIR\comport.inf
  Delete $INSTDIR\com0com.sys
  Delete $INSTDIR\com0com.cat
  Delete $INSTDIR\setup.dll
  Delete $INSTDIR\setupc.exe
  Delete $INSTDIR\setupg.exe
  Delete $INSTDIR\uninstall.exe

  ; Remove shortcuts, if any
  Delete "$SMPROGRAMS\com0com\*.*"

  ; Remove directories used
  RMDir "$SMPROGRAMS\com0com"
  SetOutPath $TEMP
  RMDir "$INSTDIR"

SectionEnd

;--------------------------------

  ;Language strings
  LangString DESC_sec_com0com ${LANG_ENGLISH} "\
    Install com0com files. \
    "
  LangString DESC_sec_shortcuts ${LANG_ENGLISH} "\
    Add shortcuts to the Start Menu. \
    "
  LangString DESC_sec_CNCxCNC_ports ${LANG_ENGLISH} "\
    Install a pair of linked ports by CNCPorts class installer. \
    The CNCPorts class installer sets the port names to CNCA0 and CNCB0. \
    "
  LangString DESC_sec_COMxCOM_ports ${LANG_ENGLISH} "\
    Install a pair of linked ports by Ports class installer. \
    The Ports class installer selects the COM port number for each port and \
    sets the port name to COM#, where # is the selected port number. \
    "

  ;Assign language strings to sections
  !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
    !insertmacro MUI_DESCRIPTION_TEXT ${sec_com0com} $(DESC_sec_com0com)
    !insertmacro MUI_DESCRIPTION_TEXT ${sec_shortcuts} $(DESC_sec_shortcuts)
    !insertmacro MUI_DESCRIPTION_TEXT ${sec_CNCxCNC_ports} $(DESC_sec_CNCxCNC_ports)
    !insertmacro MUI_DESCRIPTION_TEXT ${sec_COMxCOM_ports} $(DESC_sec_COMxCOM_ports)
  !insertmacro MUI_FUNCTION_DESCRIPTION_END

;--------------------------------


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/com0com.inf

;******************************************************************************
;
; com0com.inf
;
; Installation file for the Null-modem emulator driver.
;
; Copyright (c) 2004-2012 Vyacheslav Frolov
;
;******************************************************************************

[Version]
Signature = "$Windows NT$"
Provider = %VF%
Class = CNCPorts
ClassGUID = {df799e12-3c56-421b-b298-b6d3642bc878}
CatalogFile = com0com.cat
;           MM/DD/YYYY
DriverVer = 06/04/2012,3.0.0.0
UninstallInfTag = {df799e12-3c56-421b-b298-b6d3642bc878}

;******************************************************************************
;
; Class section
;
;******************************************************************************

[ClassInstall32]
AddReg = com0com_ClassReg

[com0com_ClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-23

;******************************************************************************
;
; Source and Destination information
;
;******************************************************************************

[SourceDisksNames]
1 = %DiskId1%,,,""

[SourceDisksFiles]
com0com.sys = 1,,

[DestinationDirs]
com0com_CopyDrivers = 12

[com0com_CopyDrivers]
com0com.sys

;******************************************************************************
;
; Driver information
;
;******************************************************************************

[Manufacturer]
%VF% = com0com, NTx86, NTia64, NTamd64

[com0com]
%com0com.BusDesc% = com0com_inst, root\com0com

[com0com.NTx86]
%com0com.BusDesc% = com0com_inst, root\com0com

[com0com.NTia64]
%com0com.BusDesc% = com0com_inst, root\com0com

[com0com.NTamd64]
%com0com.BusDesc% = com0com_inst, root\com0com

;******************************************************************************
;
; Bus install section
;
;******************************************************************************

[com0com_inst]
AddReg = com0com_AddReg
CopyFiles = com0com_CopyDrivers
CopyINF = cncport.inf
;CopyINF = comport.inf

[com0com_inst.Services]
AddService = com0com, %SPSVCINST_ASSOCSERVICE%, com0com_Service_Inst, com0com_EventLog_Inst

[com0com_AddReg]

;******************************************************************************
;
; Common section
;
;******************************************************************************

[com0com_Service_Inst]
DisplayName    = %com0com.SrvDesc%
ServiceType    = %SERVICE_KERNEL_DRIVER%
StartType      = %SERVICE_DEMAND_START%
ErrorControl   = %SERVICE_ERROR_NORMAL%
ServiceBinary  = %12%\com0com.sys

[com0com_EventLog_Inst]
AddReg = com0com_EventLog_AddReg

[com0com_EventLog_AddReg]
HKR,,EventMessageFile,%REG_EXPAND_SZ%,"%%SystemRoot%%\System32\IoLogMsg.dll;%%SystemRoot%%\System32\drivers\com0com.sys"
HKR,,TypesSupported,%REG_DWORD%,7

;******************************************************************************
;
; Strings
;
;******************************************************************************

[Strings]

SPSVCINST_ASSOCSERVICE = 0x00000002

REG_EXPAND_SZ          = 0x00020000
REG_DWORD              = 0x00010001

SERVICE_KERNEL_DRIVER  = 1
SERVICE_DEMAND_START   = 3
SERVICE_ERROR_NORMAL   = 1

DiskId1 = "Installation Disk #1 (com0com - Null-modem emulator)"
VF = "Vyacheslav Frolov"
com0com.BusDesc = "com0com - bus for serial port pair emulator"
com0com.SrvDesc = "com0com - emulates the serial ports interconnected via a null-modem cable"
ClassName = "com0com - serial port emulators"

;******************************************************************************


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/requireAdministrator.manifest

<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
  <ms_asmv2:trustInfo xmlns:ms_asmv2="urn:schemas-microsoft-com:asm.v2">
     <ms_asmv2:security>
        <ms_asmv2:requestedPrivileges>
           <ms_asmv2:requestedExecutionLevel level="requireAdministrator">
           </ms_asmv2:requestedExecutionLevel>
        </ms_asmv2:requestedPrivileges>
     </ms_asmv2:security>
  </ms_asmv2:trustInfo>
</assembly>


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/trace_disable.reg

Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\com0com\Trace]
"TraceFile"=""


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupc/makefile

!INCLUDE $(NTMAKEENV)\makefile.def


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupc/setup.cpp

/*
 * $Id: setup.cpp,v 1.2 2010/03/30 08:06:22 vfrolov Exp $
 *
 * Copyright (c) 2007-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: setup.cpp,v $
 * Revision 1.2  2010/03/30 08:06:22  vfrolov
 * Fixed bugs item #2979007 "setupc command line limited to 200 chars"
 * Reported by Henrik Maier (hwmaier)
 *
 * Revision 1.1  2007/10/25 14:25:34  vfrolov
 * Initial revision
 *
 */

#include <windows.h>

int CALLBACK MainA(const char *pProgName, const char *pCmdLine);

int _cdecl main(int argc, char *argv[])
{
  char cmd[1024] = "";

  for (int i = 1 ; i < argc ; i++) {
    int lenCmd = lstrlen(cmd);

    if (sizeof(cmd)/sizeof(cmd[0]) < lenCmd + 1 + lstrlen(argv[i]) + 1)
      break;

    lstrcpy(cmd + lenCmd, " ");
    lenCmd++;
    lstrcpy(cmd + lenCmd, argv[i]);
  }

  return MainA(argv[0], cmd);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupc/sources

TARGETNAME=setupc
TARGETTYPE=PROGRAM
TARGETPATH=..
UMTYPE=console
UMENTRY=main
UMBASE=0x400000
MSC_WARNING_LEVEL=/W4
USE_MSVCRT=1

SOURCES= \
        setup.cpp \

!IF "$(BUILD_DEFAULT_TARGETS)" == "-386"
TARGET_CPU=i386
!ELSE
!IF "$(BUILD_DEFAULT_TARGETS)" == "-IA64" || "$(BUILD_DEFAULT_TARGETS)" == "-ia64"
TARGET_CPU=ia64
!ELSE
!IF "$(BUILD_DEFAULT_TARGETS)" == "-AMD64" || "$(BUILD_DEFAULT_TARGETS)" == "-amd64"
TARGET_CPU=amd64
!ENDIF
!ENDIF
!ENDIF

TARGETLIBS= \
        ..\$(TARGET_CPU)\setup.lib \


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupc/.cvsignore

obj
objchk*
objfre*


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/cncport.inf

;******************************************************************************
;
; cncport.inf
;
; Installation file for the Null-modem emulator driver.
;
; Copyright (c) 2010-2012 Vyacheslav Frolov
;
;******************************************************************************

[Version]
Signature = "$Windows NT$"
Provider = %VF%
Class = CNCPorts
ClassGUID = {df799e12-3c56-421b-b298-b6d3642bc878}
CatalogFile = com0com.cat
;           MM/DD/YYYY
DriverVer = 06/04/2012,3.0.0.0
UninstallInfTag = {df799e12-3c56-421b-b298-b6d3642bc878}

;******************************************************************************
;
; Driver information
;
;******************************************************************************

[Manufacturer]
%VF% = com0com, NTx86, NTia64, NTamd64

[ControlFlags]
ExcludeFromSelect = com0com\cncport

[com0com]
%com0com.PortDesc% = com0com_inst_port, com0com\cncport

[com0com.NTx86]
%com0com.PortDesc% = com0com_inst_port, com0com\cncport

[com0com.NTia64]
%com0com.PortDesc% = com0com_inst_port, com0com\cncport

[com0com.NTamd64]
%com0com.PortDesc% = com0com_inst_port, com0com\cncport

;******************************************************************************
;
; Port install section
;
;******************************************************************************

[com0com_inst_port]
AddReg = com0com_AddReg
;Include = msports.inf
;Needs = SerialEnumerator.NT

[com0com_inst_port.Services]
AddService = com0com, %SPSVCINST_ASSOCSERVICE%, com0com_Service_Inst, com0com_EventLog_Inst
;Include = msports.inf
;Needs = SerialEnumerator.NT.Services

[com0com_inst_port.HW]
AddReg = com0com_HW_AddReg

[com0com_AddReg]

[com0com_HW_AddReg]
;HKR,,"UpperFilters",0x00010000,"serenum"

;******************************************************************************
;
; Common section
;
;******************************************************************************

[com0com_Service_Inst]
DisplayName    = %com0com.SrvDesc%
ServiceType    = %SERVICE_KERNEL_DRIVER%
StartType      = %SERVICE_DEMAND_START%
ErrorControl   = %SERVICE_ERROR_NORMAL%
ServiceBinary  = %12%\com0com.sys

[com0com_EventLog_Inst]
AddReg = com0com_EventLog_AddReg

[com0com_EventLog_AddReg]
HKR,,EventMessageFile,%REG_EXPAND_SZ%,"%%SystemRoot%%\System32\IoLogMsg.dll;%%SystemRoot%%\System32\drivers\com0com.sys"
HKR,,TypesSupported,%REG_DWORD%,7

;******************************************************************************
;
; Strings
;
;******************************************************************************

[Strings]

SPSVCINST_ASSOCSERVICE = 0x00000002

REG_EXPAND_SZ          = 0x00020000
REG_DWORD              = 0x00010001

SERVICE_KERNEL_DRIVER  = 1
SERVICE_DEMAND_START   = 3
SERVICE_ERROR_NORMAL   = 1

VF = "Vyacheslav Frolov"
com0com.PortDesc = "com0com - serial port emulator"
com0com.SrvDesc = "com0com - emulates the serial ports interconnected via a null-modem cable"

;******************************************************************************


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/include/cncext.h

/*
 * cncext.h
 *
 * Copyright (c) 2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef _INCLUDE_C0C_CNCEXT_H_
#define _INCLUDE_C0C_CNCEXT_H_

#define C0CE_SIGNATURE              "c0c"
#define C0CE_SIGNATURE_SIZE         (sizeof(UCHAR)*4)

/**************************************************************************
  Extended IOCTL_SERIAL_LSRMST_INSERT allows to monitor and get the paired
  port settings as insertion to the data stream
 **************************************************************************/

/*
  Following this value is the baud rate (ULONG) of paired port
*/
#define C0CE_INSERT_RBR             16

/*
  Following this value is the byte size (UCHAR), parity (UCHAR)
  and stop bits (UCHAR) of paired port
*/
#define C0CE_INSERT_RLC             17

/*
  Options (ULONG)
*/

#define C0CE_INSERT_IOCTL_CAPS      0xFFFFFFFF  /* IOCTL returns bitmap of all possible options */

#define C0CE_INSERT_IOCTL_GET       0x01000000  /* IOCTL returns current values of enabled insertions */
#define C0CE_INSERT_IOCTL_RXCLEAR   0x02000000  /* IOCTL clears the driver's input buffer */

#define C0CE_INSERT_ENABLE_LSR      0x00000001  /* enable standard SERIAL_LSRMST_LSR_[NO]DATA insertion */
#define C0CE_INSERT_ENABLE_MST      0x00000002  /* enable standard SERIAL_LSRMST_MST insertion */
#define C0CE_INSERT_ENABLE_RBR      0x00000100  /* enable C0CE_INSERT_RBR insertion */
#define C0CE_INSERT_ENABLE_RLC      0x00000200  /* enable C0CE_INSERT_RLC insertion */
#define C0CE_INSERT_ENABLE_LSR_BI   0x00000400  /* enable SERIAL_LSRMST_LSR_[NO]DATA insertion on BREAK change */

#endif /* _INCLUDE_C0C_CNCEXT_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/include/com0com.h

/*
 * $Id: com0com.h,v 1.13 2011/12/06 16:03:22 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef _INCLUDE_C0C_COM0COM_H_
#define _INCLUDE_C0C_COM0COM_H_

#define C0C_BUS_DEVICE_ID           TEXT_PREF"root\\com0com"
#define C0C_PORT_DEVICE_ID          TEXT_PREF"com0com\\port"
#define C0C_PORT_HW_ID_CNCCLASS     TEXT_PREF"com0com\\cncport"
#define C0C_PORT_HW_ID_COMCLASS     TEXT_PREF"com0com\\comport"
#define C0C_SERVICE                 TEXT_PREF"com0com"
#define C0C_PREF_NT_DEVICE_NAME     TEXT_PREF"\\Device\\"

#define C0C_PORT_NAME_LEN           12
#define C0C_PREF_BUS_NAME           TEXT_PREF"CNCBUS"
#define C0C_PREF_PORT_NAME_A        TEXT_PREF"CNCA"
#define C0C_PREF_PORT_NAME_B        TEXT_PREF"CNCB"
#define C0C_PREF_DEVICE_NAME_A      C0C_PREF_NT_DEVICE_NAME C0C_SERVICE TEXT_PREF"1"
#define C0C_PREF_DEVICE_NAME_B      C0C_PREF_NT_DEVICE_NAME C0C_SERVICE TEXT_PREF"2"
#define C0C_PORT_NAME_COMCLASS      TEXT_PREF"COM#"

#define C0C_REGSTR_VAL_PORT_NUM     TEXT_PREF"PortNum"

#define C0C_PIN_RRTS                0x00000001
#define C0C_PIN_RDTR                0x00000002
#define C0C_PIN_ROUT1               0x00000004
#define C0C_PIN_ROUT2               0x00000008
#define C0C_PIN_ROPEN               0x00000080
#define C0C_PIN_LRTS                0x00000100
#define C0C_PIN_LDTR                0x00000200
#define C0C_PIN_LOUT1               0x00000400
#define C0C_PIN_LOUT2               0x00000800
#define C0C_PIN_LOPEN               0x00008000
#define C0C_PIN_ON                  0x10000000
#define C0C_PIN_NEGATIVE            0x80000000

#define C0C_DEFAULT_PIN_CTS         C0C_PIN_RRTS
#define C0C_DEFAULT_PIN_DSR         C0C_PIN_RDTR
#define C0C_DEFAULT_PIN_DCD         C0C_PIN_RDTR
#define C0C_DEFAULT_PIN_RI          (C0C_PIN_ON|C0C_PIN_NEGATIVE)

#define C0C_DEFAULT_EMUBR           0x00000000
#define C0C_DEFAULT_EMUOVERRUN      0x00000000
#define C0C_DEFAULT_PLUGINMODE      0x00000000
#define C0C_DEFAULT_EXCLUSIVEMODE   0x00000000
#define C0C_DEFAULT_HIDDENMODE      0x00000000
#define C0C_DEFAULT_ALLDATABITS     0x00000000
#define C0C_DEFAULT_EMUNOISE        0x00000000
#define C0C_DEFAULT_ADDRTTO         0x00000000
#define C0C_DEFAULT_ADDRITO         0x00000000

#define C0C_PROBABILITY_ONE         100000000

#endif /* _INCLUDE_C0C_COM0COM_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/setup.bat

@start RunDll32 setup,RunDll %1 %2 %3 %4 %5 %6 %7 %8 %9


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/portnum.h

/*
 * $Id: portnum.h,v 1.1 2006/11/02 16:07:02 vfrolov Exp $
 *
 * Copyright (c) 2006 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: portnum.h,v $
 * Revision 1.1  2006/11/02 16:07:02  vfrolov
 * Initial revision
 *
 *
 */

#ifndef _C0C_PORTNUM_H_
#define _C0C_PORTNUM_H_

int GetPortNum(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData);

LONG SetPortNum(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    int num);

#endif /* _C0C_PORTNUM_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/devutils.cpp

/*
 * $Id: devutils.cpp,v 1.21 2012/01/10 11:24:27 vfrolov Exp $
 *
 * Copyright (c) 2006-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: devutils.cpp,v $
 * Revision 1.21  2012/01/10 11:24:27  vfrolov
 * Added ability to repeate waiting for no pending device
 * installation activities
 *
 * Revision 1.20  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.19  2011/07/15 16:09:05  vfrolov
 * Disabled MessageBox() for silent mode and added default processing
 *
 * Revision 1.18  2011/07/13 17:39:55  vfrolov
 * Fixed result treatment of UpdateDriverForPlugAndPlayDevices()
 *
 * Revision 1.17  2010/07/29 12:18:43  vfrolov
 * Fixed waiting stuff
 *
 * Revision 1.16  2010/07/15 18:11:09  vfrolov
 * Fixed --wait option for Ports class
 *
 * Revision 1.15  2010/07/12 18:14:44  vfrolov
 * Fixed driver update duplication
 *
 * Revision 1.14  2010/06/07 07:03:31  vfrolov
 * Added wrapper UpdateDriver() for UpdateDriverForPlugAndPlayDevices()
 *
 * Revision 1.13  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.12  2009/09/21 08:54:05  vfrolov
 * Added DI_NEEDRESTART check
 *
 * Revision 1.11  2009/02/16 10:36:16  vfrolov
 * Done --silent option more silent
 *
 * Revision 1.10  2009/02/11 07:35:21  vfrolov
 * Added --no-update option
 *
 * Revision 1.9  2007/11/27 16:35:49  vfrolov
 * Added state check before enabling
 *
 * Revision 1.8  2007/10/01 15:01:35  vfrolov
 * Added pDevInstID parameter to InstallDevice()
 *
 * Revision 1.7  2007/09/25 12:42:49  vfrolov
 * Fixed update command (bug if multiple pairs active)
 * Fixed uninstall command (restore active ports on cancell)
 *
 * Revision 1.6  2007/09/14 12:58:44  vfrolov
 * Removed INSTALLFLAG_FORCE
 * Added UpdateDriverForPlugAndPlayDevices() retrying
 *
 * Revision 1.5  2007/02/15 08:48:45  vfrolov
 * Fixed 1658441 - Installation Failed
 * Thanks to Michael A. Smith
 *
 * Revision 1.4  2006/11/10 14:07:40  vfrolov
 * Implemented remove command
 *
 * Revision 1.3  2006/11/02 16:20:44  vfrolov
 * Added usage the fixed port numbers
 *
 * Revision 1.2  2006/10/13 10:26:35  vfrolov
 * Some defines moved to ../include/com0com.h
 * Changed name of device object (for WMI)
 *
 * Revision 1.1  2006/07/28 12:16:42  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "msg.h"
#include "devutils.h"
#include "utils.h"

///////////////////////////////////////////////////////////////
struct EnumParams {
  EnumParams() {
    pDevProperties = NULL;
    pDevCallBack = NULL;
    pDevCallBackParam = NULL;
    pStack = NULL;
    count = 0;
    pRebootRequired = NULL;
  }

  PCDevProperties pDevProperties;
  PCNC_DEV_CALLBACK pDevCallBack;
  void *pDevCallBackParam;
  Stack *pStack;
  int count;
  BOOL *pRebootRequired;
};

typedef EnumParams *PEnumParams;

struct DevParams {
  DevParams(PEnumParams _pEnumParams) {
    pEnumParams = _pEnumParams;
  }

  PEnumParams pEnumParams;
  DevProperties devProperties;
};

typedef DevParams *PDevParams;
///////////////////////////////////////////////////////////////
static const char *SetStr(char **ppDst, const char *pSrc)
{
  if (*ppDst) {
    LocalFree(*ppDst);
    *ppDst = NULL;
  }

  if (pSrc) {
    int len = lstrlen(pSrc) + 1;

    *ppDst = (char *)LocalAlloc(LPTR, len * sizeof(pSrc[0]));

    if (*ppDst) {
      SNPRINTF(*ppDst, len, "%s", pSrc);
    } else {
      SetLastError(ERROR_NOT_ENOUGH_MEMORY);
      ShowLastError(MB_OK|MB_ICONSTOP, "LocalAlloc(%lu)", (unsigned long)(len * sizeof(pSrc[0])));
    }
  }

  return *ppDst;
}
///////////////////////////////////////////////////////////////
const char *DevProperties::DevId(const char *_pDevId)
{
  return SetStr(&pDevId, _pDevId);
}

const char *DevProperties::PhObjName(const char *_pPhObjName)
{
  return SetStr(&pPhObjName, _pPhObjName);
}

const char *DevProperties::Location(const char *_pLocation)
{
  return SetStr(&pLocation, _pLocation);
}
///////////////////////////////////////////////////////////////
typedef int CNC_DEV_ROUTINE(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PDevParams pDevParams);

typedef CNC_DEV_ROUTINE *PCNC_DEV_ROUTINE;

static int EnumDevices(
    PCNC_ENUM_FILTER pFilter,
    DWORD flags,
    PCNC_DEV_ROUTINE pDevRoutine,
    PEnumParams pEnumParams)
{
  HDEVINFO hDevInfo;

  hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_ALLCLASSES|flags);

  if (hDevInfo == INVALID_HANDLE_VALUE) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiGetClassDevs()");
    return IDCANCEL;
  }

  SP_DEVINFO_DATA devInfoData;

  devInfoData.cbSize = sizeof(devInfoData);

  int res = IDCONTINUE;

  for (int i = 0 ; SetupDiEnumDeviceInfo(hDevInfo, i, &devInfoData) ; i++) {
    char hardwareId[40];

    if (!SetupDiGetDeviceRegistryProperty(hDevInfo, &devInfoData, SPDRP_HARDWAREID, NULL, (PBYTE)hardwareId, sizeof(hardwareId), NULL)) {
      memset(hardwareId, 0, sizeof(hardwareId));
      SNPRINTF(hardwareId, sizeof(hardwareId)/sizeof(hardwareId[0]), "UNKNOWN HARDWAREID" "\0");
    }

    if (!pFilter(hardwareId))
      continue;

    const char *pHardwareId = hardwareId;

    if (pEnumParams->pDevProperties && pEnumParams->pDevProperties->DevId()) {
      while (lstrcmpi(pHardwareId, pEnumParams->pDevProperties->DevId()) != 0) {
        pHardwareId = pHardwareId + lstrlen(pHardwareId) + 1;

        if (!*pHardwareId) {
          pHardwareId = NULL;
          break;
        }
      }

      if (!pHardwareId)
        continue;
    }

    DevParams devParams(pEnumParams);

    if (!devParams.devProperties.DevId(pHardwareId)) {
      res = IDCANCEL;
      break;
    }

    char location[40];

    if (SetupDiGetDeviceRegistryProperty(hDevInfo, &devInfoData, SPDRP_LOCATION_INFORMATION, NULL, (PBYTE)location, sizeof(location), NULL)) {
      if (!devParams.devProperties.Location(location)) {
        res = IDCANCEL;
        break;
      }
    }

    if (pEnumParams->pDevProperties &&
        pEnumParams->pDevProperties->Location() && (!devParams.devProperties.Location() ||
        lstrcmpi(devParams.devProperties.Location(), pEnumParams->pDevProperties->Location())))
    {
      continue;
    }

    char name[40];

    if (SetupDiGetDeviceRegistryProperty(hDevInfo, &devInfoData, SPDRP_PHYSICAL_DEVICE_OBJECT_NAME, NULL, (PBYTE)name, sizeof(name), NULL)) {
      if (!devParams.devProperties.PhObjName(name)) {
        res = IDCANCEL;
        break;
      }
    }

    if (pEnumParams->pDevProperties &&
        pEnumParams->pDevProperties->PhObjName() && (!devParams.devProperties.PhObjName() ||
        lstrcmpi(devParams.devProperties.PhObjName(), pEnumParams->pDevProperties->PhObjName())))
    {
      continue;
    }

    res = pDevRoutine(hDevInfo, &devInfoData, &devParams);

    if (res != IDCONTINUE)
      break;
  }

  DWORD err = GetLastError();

  SetupDiDestroyDeviceInfoList(hDevInfo);

  SetLastError(err);

  return res;
}
///////////////////////////////////////////////////////////////
static bool UpdateRebootRequired(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, BOOL *pRebootRequired)
{
  if (!pRebootRequired)
    return TRUE;

  if (*pRebootRequired)
    return TRUE;

  ULONG status = 0;
  ULONG problem = 0;

  *pRebootRequired =
      CM_Get_DevNode_Status(&status, &problem, pDevInfoData->DevInst, 0) == CR_SUCCESS &&
      (status & DN_NEED_RESTART) != 0;

  //if (*pRebootRequired)
  //  Trace("Enumerated status=0x%lX problem=0x%lX\n", status, problem);

  if (*pRebootRequired)
    return TRUE;

  SP_DEVINSTALL_PARAMS installParams;

  memset(&installParams, 0, sizeof(installParams));
  installParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

  if (!SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &installParams)) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiGetDeviceInstallParams()");
    return FALSE;
  }

  *pRebootRequired = (installParams.Flags & (DI_NEEDREBOOT|DI_NEEDRESTART)) ? TRUE : FALSE;

  //if (*pRebootRequired)
  //  Trace("Enumerated Flags=0x%lX\n", installParams.Flags);

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool ChangeState(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, DWORD stateChange)
{
  SP_PROPCHANGE_PARAMS propChangeParams;

  memset(&propChangeParams, 0, sizeof(propChangeParams));
  propChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
  propChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
  propChangeParams.StateChange = stateChange;
  propChangeParams.Scope = DICS_FLAG_CONFIGSPECIFIC;
  propChangeParams.HwProfile = 0;

  if (!SetupDiSetClassInstallParams(hDevInfo, pDevInfoData, (SP_CLASSINSTALL_HEADER *)&propChangeParams, sizeof(propChangeParams))) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiSetClassInstallParams()");
    return FALSE;
  }

  if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE, hDevInfo, pDevInfoData)) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiCallClassInstaller(DIF_PROPERTYCHANGE)");
    return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool IsDisabled(PSP_DEVINFO_DATA pDevInfoData)
{
  ULONG status = 0;
  ULONG problem = 0;

  if (CM_Get_DevNode_Status(&status, &problem, pDevInfoData->DevInst, 0) != CR_SUCCESS)
    return FALSE;

  return (status & DN_HAS_PROBLEM) != 0 && problem == CM_PROB_DISABLED;
}
///////////////////////////////////////////////////////////////
static bool IsEnabled(PSP_DEVINFO_DATA pDevInfoData)
{
  ULONG status = 0;
  ULONG problem = 0;

  if (CM_Get_DevNode_Status(&status, &problem, pDevInfoData->DevInst, 0) != CR_SUCCESS)
    return FALSE;

  return (status & (DN_HAS_PROBLEM|DN_NEED_RESTART)) == 0;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_ROUTINE EnumDevice;
static int EnumDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, PDevParams pDevParams)
{
  /*
  Trace("Enumerated %s %s %s\n",
        pDevParams->devProperties.Location(),
        pDevParams->devProperties.DevId(),
        pDevParams->devProperties.PhObjName());
  */

  int res = IDCONTINUE;

  if (pDevParams->pEnumParams->pDevCallBack) {
    if (!pDevParams->pEnumParams->pDevCallBack(         hDevInfo,
                                                        pDevInfoData,
                                                        &pDevParams->devProperties,
                                                        pDevParams->pEnumParams->pRebootRequired,
                                                        pDevParams->pEnumParams->pDevCallBackParam))
    {
      res = IDCANCEL;
    }
  }

  pDevParams->pEnumParams->count++;

  return res;
}

int EnumDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    PCNC_DEV_CALLBACK pDevCallBack,
    void *pDevCallBackParam)
{
  EnumParams enumParams;

  enumParams.pDevProperties = pDevProperties;
  enumParams.pRebootRequired = pRebootRequired;
  enumParams.pDevCallBack = pDevCallBack;
  enumParams.pDevCallBackParam = pDevCallBackParam;

  if (EnumDevices(pFilter, DIGCF_PRESENT, EnumDevice, &enumParams) != IDCONTINUE)
    return -1;

  return enumParams.count;
}
///////////////////////////////////////////////////////////////
int DisableDevice(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    Stack *pDevPropertiesStack)
{
  if (IsDisabled(pDevInfoData))
    return IDCONTINUE;

  BOOL rebootRequired = FALSE;

  if (!UpdateRebootRequired(hDevInfo, pDevInfoData, &rebootRequired))
    return IDCANCEL;

  //if (rebootRequired && pRebootRequired)
  //  *pRebootRequired = TRUE;

  if (!ChangeState(hDevInfo, pDevInfoData, DICS_DISABLE))
    return IDCANCEL;

  Trace("Disabled %s %s %s\n",
        pDevProperties->Location(),
        pDevProperties->DevId(),
        pDevProperties->PhObjName());

  if (!rebootRequired) {
    if (!UpdateRebootRequired(hDevInfo, pDevInfoData, &rebootRequired))
      return IDCANCEL;

    if (rebootRequired) {
      Trace("Can't stop device %s %s %s\n",
            pDevProperties->Location(),
            pDevProperties->DevId(),
            pDevProperties->PhObjName());

      int res;

      res = ShowMsg(MB_CANCELTRYCONTINUE,
                        "Can't stop device %s %s %s.\n"
                        "Close application that use this device and Try Again.\n"
                        "Or Continue and then reboot system.\n",
                        pDevProperties->Location(),
                        pDevProperties->DevId(),
                        pDevProperties->PhObjName());

      if (res == 0)
        res = IDCONTINUE;

      if (res != IDCONTINUE) {
        if (!ChangeState(hDevInfo, pDevInfoData, DICS_ENABLE))
          return IDCANCEL;

        Trace("Enabled %s %s %s\n",
              pDevProperties->Location(),
              pDevProperties->DevId(),
              pDevProperties->PhObjName());

        return res;
      }

      if (pRebootRequired)
        *pRebootRequired = TRUE;
    }
  }

  if (pDevPropertiesStack) {
    DevProperties *pDevProp = new DevProperties(*pDevProperties);

    if (pDevProp) {
      StackEl *pElem = new StackEl(pDevProp);

      if (pElem)
        pDevPropertiesStack->Push(pElem);
      else
        delete pDevProp;
    }
  }

  return IDCONTINUE;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_ROUTINE DisableDevice;
static int DisableDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, PDevParams pDevParams)
{
  int res = DisableDevice(hDevInfo,
                          pDevInfoData,
                          &pDevParams->devProperties,
                          pDevParams->pEnumParams->pRebootRequired,
                          pDevParams->pEnumParams->pStack);

  if (res == IDCONTINUE)
    pDevParams->pEnumParams->count++;

  return res;
}

bool DisableDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    Stack *pDevPropertiesStack)
{
  EnumParams enumParams;

  int res;

  enumParams.pRebootRequired = pRebootRequired;
  enumParams.pDevProperties = pDevProperties;
  enumParams.pStack = pDevPropertiesStack;

  do {
    res = EnumDevices(pFilter, DIGCF_PRESENT, DisableDevice, &enumParams);
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  if (!WaitNoPendingInstallEvents(10))
    Sleep(1000);

  return TRUE;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_ROUTINE EnableDevice;
static int EnableDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, PDevParams pDevParams)
{
  if (IsEnabled(pDevInfoData))
    return IDCONTINUE;

  if (ChangeState(hDevInfo, pDevInfoData, DICS_ENABLE)) {
    Trace("Enabled %s %s %s\n",
          pDevParams->devProperties.Location(),
          pDevParams->devProperties.DevId(),
          pDevParams->devProperties.PhObjName());
  }

  UpdateRebootRequired(hDevInfo, pDevInfoData, pDevParams->pEnumParams->pRebootRequired);

  return IDCONTINUE;
}

bool EnableDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired)
{
  EnumParams enumParams;

  int res;

  enumParams.pRebootRequired = pRebootRequired;
  enumParams.pDevProperties = pDevProperties;

  do {
    res = EnumDevices(pFilter, DIGCF_PRESENT, EnableDevice, &enumParams);
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_ROUTINE RestartDevice;
static int RestartDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, PDevParams pDevParams)
{
  if (!ChangeState(hDevInfo, pDevInfoData, DICS_PROPCHANGE))
    return IDCANCEL;

  BOOL rebootRequired = FALSE;

  if (!UpdateRebootRequired(hDevInfo, pDevInfoData, &rebootRequired))
    return IDCANCEL;

  if (rebootRequired) {
    Trace("Can't reastart device %s %s %s\n",
          pDevParams->devProperties.Location(),
          pDevParams->devProperties.DevId(),
          pDevParams->devProperties.PhObjName());

    if (pDevParams->pEnumParams->pRebootRequired && !*pDevParams->pEnumParams->pRebootRequired) {
      int res;

      res = ShowMsg(MB_CANCELTRYCONTINUE,
                        "Can't reastart device %s %s %s.\n"
                        "Close application that use this device and Try Again.\n"
                        "Or Continue and then reboot system.\n",
                        pDevParams->devProperties.Location(),
                        pDevParams->devProperties.DevId(),
                        pDevParams->devProperties.PhObjName());

      if (res == 0)
        res = IDCONTINUE;

      if (res != IDCONTINUE) {
        if (!ChangeState(hDevInfo, pDevInfoData, DICS_ENABLE))
          return IDCANCEL;

        return res;
      }

      *pDevParams->pEnumParams->pRebootRequired = TRUE;
    }
  } else {
    Trace("Restarted %s %s %s\n",
        pDevParams->devProperties.Location(),
        pDevParams->devProperties.DevId(),
        pDevParams->devProperties.PhObjName());

    pDevParams->pEnumParams->count++;
  }

  return IDCONTINUE;
}

bool RestartDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired)
{
  EnumParams enumParams;

  int res;

  enumParams.pRebootRequired = pRebootRequired;
  enumParams.pDevProperties = pDevProperties;

  do {
    res = EnumDevices(pFilter, DIGCF_PRESENT, RestartDevice, &enumParams);
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool RemoveDevice(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired)
{
  if (!SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, pDevInfoData)) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiCallClassInstaller(DIF_REMOVE, %s, %s)",
                  pDevProperties->DevId(), pDevProperties->PhObjName());
    return FALSE;
  }

  Trace("Removed %s %s %s\n", pDevProperties->Location(), pDevProperties->DevId(), pDevProperties->PhObjName());

  return UpdateRebootRequired(hDevInfo, pDevInfoData, pRebootRequired);
}
///////////////////////////////////////////////////////////////
static CNC_DEV_ROUTINE RemoveDevice;
static int RemoveDevice(HDEVINFO hDevInfo, PSP_DEVINFO_DATA pDevInfoData, PDevParams pDevParams)
{
  if (!RemoveDevice(hDevInfo, pDevInfoData, &pDevParams->devProperties, pDevParams->pEnumParams->pRebootRequired))
    return IDCANCEL;

  pDevParams->pEnumParams->count++;

  return IDCONTINUE;
}

bool RemoveDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired)
{
  EnumParams enumParams;

  int res;

  enumParams.pRebootRequired = pRebootRequired;
  enumParams.pDevProperties = pDevProperties;

  do {
    res = EnumDevices(pFilter, 0, RemoveDevice, &enumParams);
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  if (!enumParams.count)
    Trace("No devices found\n");

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool ReenumerateDeviceNode(PSP_DEVINFO_DATA pDevInfoData)
{
  return CM_Reenumerate_DevNode(pDevInfoData->DevInst, 0) == CR_SUCCESS;
}
///////////////////////////////////////////////////////////////
int UpdateDriver(
    const char *pInfFilePath,
    const char *pHardwareId,
    DWORD flags,
    bool mandatory,
    BOOL *pRebootRequired)
{
  DWORD updateErr = ERROR_SUCCESS;

  for (int i = 0 ; i < 10 ; i++) {
    if (UpdateDriverForPlugAndPlayDevices(0, pHardwareId, pInfFilePath, flags, pRebootRequired))
    {
      updateErr = ERROR_SUCCESS;
    } else {
      updateErr = GetLastError();

      if (updateErr == ERROR_SHARING_VIOLATION) {
        Trace(".");
        Sleep(1000);
        continue;
      }
      else
      if (!mandatory) {
        if (updateErr == ERROR_NO_SUCH_DEVINST) {
          updateErr = ERROR_SUCCESS;
        }
        else
        if (updateErr == ERROR_NO_MORE_ITEMS && (flags & INSTALLFLAG_FORCE) == 0) {
          updateErr = ERROR_SUCCESS;
        }
      }
    }

    if (i)
      Trace("\n");

    break;
  }

  if (updateErr != ERROR_SUCCESS) {
    if (updateErr == ERROR_FILE_NOT_FOUND) {
      LONG err;
      HKEY hKey;

      err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, 0, KEY_READ, &hKey);

      if (err == ERROR_SUCCESS)
        RegCloseKey(hKey);

      if (err == ERROR_FILE_NOT_FOUND) {
        int res = ShowMsg(MB_CANCELTRYCONTINUE,
                          "Can't update driver. Possible it's because your Windows registry is corrupted and\n"
                          "there is not the following key:\n"
                          "\n"
                          "HKEY_LOCAL_MACHINE\\" REGSTR_PATH_RUNONCE "\n"
                          "\n"
                          "Continue to add the key to the registry.\n");

        if (res == 0)
          return IDCANCEL;

        if (res == IDCONTINUE) {
          err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, 0, NULL, 0, KEY_WRITE, NULL, &hKey, NULL);

          if (err == ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return IDTRYAGAIN;
          } else {
            ShowLastError(MB_OK|MB_ICONSTOP, "RegCreateKeyEx()");
            return IDCANCEL;
          }
        }

        return res;
      }
    }

    return ShowError(MB_CANCELTRYCONTINUE, updateErr,
                     "UpdateDriverForPlugAndPlayDevices(\"%s\", \"%s\", 0x%lX)",
                     pHardwareId, pInfFilePath, (long)flags);
  }

  return IDCONTINUE;
}
///////////////////////////////////////////////////////////////
static int TryInstallDevice(
    const char *pInfFilePath,
    const char *pDevId,
    const char *pDevInstID,
    PCNC_DEV_CALLBACK pDevCallBack,
    void *pDevCallBackParam,
    bool updateDriver,
    BOOL *pRebootRequired)
{
  GUID classGUID;
  char className[32];

  if (!SetupDiGetINFClass(pInfFilePath, &classGUID, className, sizeof(className)/sizeof(className[0]), 0)) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiGetINFClass(%s)", pInfFilePath);
    return IDCANCEL;
  }

  //Trace("className=%s\n", className);

  HDEVINFO hDevInfo;

  hDevInfo = SetupDiCreateDeviceInfoList(&classGUID, 0);

  if (hDevInfo == INVALID_HANDLE_VALUE) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiCreateDeviceInfoList()");
    return IDCANCEL;
  }

  int res = IDCONTINUE;
  SP_DEVINFO_DATA devInfoData;

  devInfoData.cbSize = sizeof(devInfoData);

  if (!pDevInstID) {
    if (StrCmpNI(pDevId, "root\\", 5) == 0) {
      /*
       * root\<enumerator-specific-device-ID>
       */

      if (!SetupDiCreateDeviceInfo(hDevInfo, pDevId + 5, &classGUID, NULL, 0, DICD_GENERATE_ID, &devInfoData))
        res = IDCANCEL;
    } else {
      SetLastError(ERROR_INVALID_DEVINST_NAME);
      res = IDCANCEL;
    }
  }
  else
  if (StrChr(pDevInstID, '\\')) {
    /*
     * <enumerator>\<enumerator-specific-device-ID>\<instance-specific-ID>
     */

    if (!SetupDiCreateDeviceInfo(hDevInfo, pDevInstID, &classGUID, NULL, 0, 0, &devInfoData))
      res = IDCANCEL;

    if (res != IDCONTINUE && GetLastError() == ERROR_DEVINST_ALREADY_EXISTS) {
      char *pTmpDevInstID = NULL;

      if (SetStr(&pTmpDevInstID, pDevInstID)) {
        char *pSave;
        char *p;

        p = STRTOK_R(pTmpDevInstID, "\\", &pSave);

        if (p && !lstrcmp(p, REGSTR_KEY_ROOTENUM)) {
          p = STRTOK_R(NULL, "\\", &pSave);

          if (SetupDiCreateDeviceInfo(hDevInfo, p, &classGUID, NULL, 0, DICD_GENERATE_ID, &devInfoData))
            res = IDCONTINUE;
        }

        SetStr(&pTmpDevInstID, NULL);
      } else {
        SetLastError(ERROR_DEVINST_ALREADY_EXISTS);
      }
    }
  } else {
    /*
     * <enumerator-specific-device-ID>
     */

    if (!SetupDiCreateDeviceInfo(hDevInfo, pDevInstID, &classGUID, NULL, 0, DICD_GENERATE_ID, &devInfoData))
      res = IDCANCEL;
  }

  if (res != IDCONTINUE) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiCreateDeviceInfo()");
    goto exit1;
  }

  char hardwareId[MAX_DEVICE_ID_LEN + 1 + 1];

  SNPRINTF(hardwareId, sizeof(hardwareId)/sizeof(hardwareId[0]) - 1, "%s", pDevId);

  int hardwareIdLen;

  hardwareIdLen = lstrlen(hardwareId) + 1 + 1;
  hardwareId[hardwareIdLen - 1] = 0;

  if (!SetupDiSetDeviceRegistryProperty(hDevInfo, &devInfoData, SPDRP_HARDWAREID,
                                        (LPBYTE)hardwareId, hardwareIdLen * sizeof(hardwareId[0])))
  {
    res = IDCANCEL;
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiSetDeviceRegistryProperty()");
    goto exit1;
  }

  if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE, hDevInfo, &devInfoData)) {
    res = IDCANCEL;
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupDiCallClassInstaller()");
    goto exit1;
  }

  if (pDevCallBack) {
    DevProperties devProperties;

    if (!devProperties.DevId(pDevId)) {
      res = IDCANCEL;
      goto exit2;
    }

    if (!pDevCallBack(hDevInfo, &devInfoData, &devProperties, NULL, pDevCallBackParam)) {
      res = IDCANCEL;
      goto exit2;
    }
  }

  if (updateDriver)
    res = UpdateDriver(pInfFilePath, pDevId, 0, TRUE, pRebootRequired);

exit2:

  if (res != IDCONTINUE) {
    if (!SetupDiCallClassInstaller(DIF_REMOVE, hDevInfo, &devInfoData))
      ShowLastError(MB_OK|MB_ICONWARNING, "SetupDiCallClassInstaller()");
  }

exit1:

  SetupDiDestroyDeviceInfoList(hDevInfo);

  return res;
}

bool InstallDevice(
    const char *pInfFilePath,
    const char *pDevId,
    const char *pDevInstID,
    PCNC_DEV_CALLBACK pDevCallBack,
    void *pDevCallBackParam,
    bool updateDriver,
    BOOL *pRebootRequired)
{
  int res;

  do {
    res = TryInstallDevice(pInfFilePath, pDevId, pDevInstID, pDevCallBack, pDevCallBackParam, updateDriver, pRebootRequired);
  } while (res == IDTRYAGAIN);

  return res == IDCONTINUE;
}
///////////////////////////////////////////////////////////////
bool WaitNoPendingInstallEvents(int timeLimit, bool repeate)
{
  typedef DWORD  (WINAPI *PWAITNOPENDINGINSTALLEVENTS)(IN DWORD);
  static PWAITNOPENDINGINSTALLEVENTS pWaitNoPendingInstallEvents = NULL;

  if(!pWaitNoPendingInstallEvents) {
    HMODULE hModule = GetModuleHandle("setupapi.dll");

    if (!hModule)
      return FALSE;

    pWaitNoPendingInstallEvents =
        (PWAITNOPENDINGINSTALLEVENTS)GetProcAddress(hModule, "CMP_WaitNoPendingInstallEvents");

    if (!pWaitNoPendingInstallEvents)
      return FALSE;
  }

  if (int(DWORD(timeLimit * 1000)/1000) != timeLimit)
    timeLimit = -1;

  bool inTrace = FALSE;
  DWORD startTime = GetTickCount();

  for (int count = 0 ;;) {
    DWORD res = pWaitNoPendingInstallEvents(0);

    if (res == WAIT_OBJECT_0) {
      if (++count < 5) {
        Sleep(100);
        continue;
      }

      if (inTrace)
        Trace(" OK\n");

      SetLastError(ERROR_SUCCESS);
      break;
    }

    count = 0;

    if (res != WAIT_TIMEOUT) {
      ShowLastError(MB_OK|MB_ICONWARNING, "CMP_WaitNoPendingInstallEvents()");
      if (inTrace)
        Trace(" FAIL\n");
      return FALSE;
    }

    DWORD timeElapsed = GetTickCount() - startTime;

    if (timeLimit != -1 && timeElapsed >= DWORD(timeLimit * 1000)) {
      if (inTrace) {
        Trace(" timeout\n");
        inTrace = FALSE;
      }

      if (!Silent() && repeate) {
        if (ShowMsg(MB_YESNO,
            "The device installation activities are still pending.\n"
            "Continue to wait?\n") == IDYES)
        {
          startTime = GetTickCount();
        } else {
          repeate = FALSE;
        }

        continue;
      }

      SetLastError(ERROR_TIMEOUT);
      break;
    }

    if (!inTrace) {
      if (timeLimit != -1)
        Trace("Waiting for no pending device installation activities (%u secs) ", (unsigned)timeLimit);
      else
        Trace("Waiting for no pending device installation activities (perpetually) ");

      inTrace = TRUE;
    }

    Sleep(1000);

    Trace(".");
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/utils.h

/*
 * $Id: utils.h,v 1.9 2011/12/15 15:51:48 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: utils.h,v $
 * Revision 1.9  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.8  2010/07/30 09:15:04  vfrolov
 * Added STRDUP()
 *
 * Revision 1.7  2008/12/25 16:56:25  vfrolov
 * Added MatchPattern()
 *
 * Revision 1.6  2008/12/24 15:22:44  vfrolov
 * Added BusyMask::Clear() and BusyMask::DelNum()
 *
 * Revision 1.5  2007/09/25 12:28:22  vfrolov
 * Implemented Stack class
 *
 * Revision 1.4  2007/01/11 15:03:43  vfrolov
 * Added STRTOK_R()
 *
 * Revision 1.3  2006/11/03 13:17:28  vfrolov
 * Fixed LocalReAlloc() usage
 * Added return value to BusyMask::AddNum()
 *
 * Revision 1.2  2006/11/02 16:09:13  vfrolov
 * Added StrToInt() and class BusyMask
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_UTILS_H_
#define _C0C_UTILS_H_

///////////////////////////////////////////////////////////////
int VSNPRINTF(char *pBuf, int size, const char *pFmt, va_list va);
int SNPRINTF(char *pBuf, int size, const char *pFmt, ...);
char *STRTOK_R(char *pStr, const char *pDelims, char **ppSave);
bool StrToInt(const char *pStr, int *pNum);
bool MatchPattern(const char *pPattern, const char *pStr);
char *STRDUP(const char *pSrcStr, bool showErrors = TRUE);
///////////////////////////////////////////////////////////////
class BusyMask {
public:
  BusyMask() : pBusyMask(NULL), busyMaskLen(0) {}
  ~BusyMask() { Clear(); }

  void Clear();
  bool AddNum(int num);
  void DelNum(int num);
  bool IsFreeNum(int num) const;
  int GetFirstFreeNum() const;
private:
  PBYTE pBusyMask;
  SIZE_T busyMaskLen;
};

class StackEl {
public:
  StackEl(PVOID _pData) : pData(_pData), pNext(NULL) {}
  PVOID pData;
private:
  StackEl *pNext;

  friend class Stack;
};

class Stack {
public:
  Stack() : pFirst(NULL) {}
  bool Push(StackEl *pElem)
  {
    if (!pElem)
      return FALSE;
    pElem->pNext = pFirst;
    pFirst = pElem;
    return TRUE;
  }
  StackEl *Pop()
  {
    StackEl *pTop = pFirst;
    if (pTop) {
      pFirst = pTop->pNext;
      pTop->pNext = NULL;
    }
    return pTop;
  }
private:
  StackEl *pFirst;
};
///////////////////////////////////////////////////////////////

#endif /* _C0C_UTILS_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/devutils.h

/*
 * $Id: devutils.h,v 1.14 2012/01/10 11:24:27 vfrolov Exp $
 *
 * Copyright (c) 2006-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: devutils.h,v $
 * Revision 1.14  2012/01/10 11:24:27  vfrolov
 * Added ability to repeate waiting for no pending device
 * installation activities
 *
 * Revision 1.13  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.12  2011/07/13 17:39:56  vfrolov
 * Fixed result treatment of UpdateDriverForPlugAndPlayDevices()
 *
 * Revision 1.11  2010/07/29 12:18:43  vfrolov
 * Fixed waiting stuff
 *
 * Revision 1.10  2010/07/15 18:11:10  vfrolov
 * Fixed --wait option for Ports class
 *
 * Revision 1.9  2010/06/07 07:03:31  vfrolov
 * Added wrapper UpdateDriver() for UpdateDriverForPlugAndPlayDevices()
 *
 * Revision 1.8  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.7  2009/02/11 07:35:22  vfrolov
 * Added --no-update option
 *
 * Revision 1.6  2007/10/01 15:01:35  vfrolov
 * Added pDevInstID parameter to InstallDevice()
 *
 * Revision 1.5  2007/09/25 12:42:49  vfrolov
 * Fixed update command (bug if multiple pairs active)
 * Fixed uninstall command (restore active ports on cancell)
 *
 * Revision 1.4  2007/09/17 14:35:06  vfrolov
 * Fixed typo
 *
 * Revision 1.3  2006/11/10 14:07:40  vfrolov
 * Implemented remove command
 *
 * Revision 1.2  2006/11/02 16:20:44  vfrolov
 * Added usage the fixed port numbers
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_DEVUTILS_H_
#define _C0C_DEVUTILS_H_

///////////////////////////////////////////////////////////////
class DevProperties {
  public:
    DevProperties() : pDevId(NULL), pPhObjName(NULL), pLocation(NULL) {}
    DevProperties(const DevProperties &o)
      : pDevId(NULL), pPhObjName(NULL), pLocation(NULL) { *this = o; }
    ~DevProperties() { DevId(NULL); PhObjName(NULL); Location(NULL); }

    DevProperties &operator=(const DevProperties &o)
    {
      DevId(o.DevId()); PhObjName(o.PhObjName()); Location(o.Location());
      return *this;
    }

    const char *DevId(const char *_pDevId);
    const char *PhObjName(const char *_pPhObjName);
    const char *Location(const char *_pLocation);

    const char *DevId() const { return pDevId; }
    const char *PhObjName() const { return pPhObjName; }
    const char *Location() const { return pLocation; }

  private:
    char *pDevId;
    char *pPhObjName;
    char *pLocation;
};

typedef const DevProperties *PCDevProperties;

class Stack;

///////////////////////////////////////////////////////////////
typedef bool CNC_DEV_CALLBACK(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    void *pParam);

typedef CNC_DEV_CALLBACK *PCNC_DEV_CALLBACK;
///////////////////////////////////////////////////////////////
typedef bool CNC_ENUM_FILTER(const char *pHardwareId);
typedef CNC_ENUM_FILTER *PCNC_ENUM_FILTER;
///////////////////////////////////////////////////////////////
int EnumDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    PCNC_DEV_CALLBACK pDevCallBack,
    void *pDevCallBackParam);

int DisableDevice(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    Stack *pDevPropertiesStack);

bool DisableDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    Stack *pDevPropertiesStack);

bool EnableDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired);

bool RestartDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired);

bool RemoveDevice(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired);

bool RemoveDevices(
    PCNC_ENUM_FILTER pFilter,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired);

bool ReenumerateDeviceNode(
    PSP_DEVINFO_DATA pDevInfoData);

int UpdateDriver(
    const char *pInfFilePath,
    const char *pHardwareId,
    DWORD flags,
    bool mandatory,
    BOOL *pRebootRequired);

bool InstallDevice(
    const char *pInfFilePath,
    const char *pDevId,
    const char *pDevInstID,
    PCNC_DEV_CALLBACK pDevCallBack,
    void *pDevCallBackParam,
    bool updateDriver,
    BOOL *pRebootRequired);

bool WaitNoPendingInstallEvents(
    int timeLimit,
    bool repeate = FALSE);
///////////////////////////////////////////////////////////////

#endif /* _C0C_DEVUTILS_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/utils.cpp

/*
 * $Id: utils.cpp,v 1.10 2011/12/15 15:51:48 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: utils.cpp,v $
 * Revision 1.10  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.9  2010/07/30 09:15:04  vfrolov
 * Added STRDUP()
 *
 * Revision 1.8  2008/12/25 16:56:25  vfrolov
 * Added MatchPattern()
 *
 * Revision 1.7  2008/12/24 15:22:44  vfrolov
 * Added BusyMask::Clear() and BusyMask::DelNum()
 *
 * Revision 1.6  2007/09/20 12:37:06  vfrolov
 * Added SetLastError(ERROR_NOT_ENOUGH_MEMORY)
 *
 * Revision 1.5  2007/05/29 15:22:00  vfrolov
 * Fixed buffer overflow
 *
 * Revision 1.4  2007/01/11 15:03:43  vfrolov
 * Added STRTOK_R()
 *
 * Revision 1.3  2006/11/03 13:17:28  vfrolov
 * Fixed LocalReAlloc() usage
 * Added return value to BusyMask::AddNum()
 *
 * Revision 1.2  2006/11/02 16:09:13  vfrolov
 * Added StrToInt() and class BusyMask
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "utils.h"
#include "msg.h"

///////////////////////////////////////////////////////////////
int VSNPRINTF(char *pBuf, int size, const char *pFmt, va_list va)
{
  char buf[1025];

  int res1 = wvsprintf(buf, pFmt, va);
  buf[sizeof(buf)/sizeof(buf[0]) - 1] = 0;

  lstrcpyn(pBuf, buf, size);

  int res2 = lstrlen(pBuf);

  return res2 == res1 ? res1 : -1;
}
///////////////////////////////////////////////////////////////
int SNPRINTF(char *pBuf, int size, const char *pFmt, ...)
{
  va_list va;

  va_start(va, pFmt);

  int res1 = VSNPRINTF(pBuf, size, pFmt, va);

  va_end(va);

  return res1;
}
///////////////////////////////////////////////////////////////
static bool IsDelim(char c, const char *pDelims)
{
  while (*pDelims) {
    if (c == *pDelims++)
      return TRUE;
  }

  return FALSE;
}

char *STRTOK_R(char *pStr, const char *pDelims, char **ppSave)
{
  if (!pStr)
    pStr = *ppSave;

  while (IsDelim(*pStr, pDelims))
    pStr++;

  if (!*pStr) {
    *ppSave = pStr;
    return NULL;
  }

  char *pToken = pStr;

  while (*pStr && !IsDelim(*pStr, pDelims))
    pStr++;

  if (*pStr)
    *pStr++ = 0;

  *ppSave = pStr;

  return pToken;
}
///////////////////////////////////////////////////////////////
bool StrToInt(const char *pStr, int *pNum)
{
  bool res = FALSE;
  int num;
  int sign = 1;

  switch (*pStr) {
    case '-':
      sign = -1;
    case '+':
      pStr++;
      break;
  }

  for (num = 0 ;; pStr++) {
    switch (*pStr) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        num = num*10 + (*pStr - '0');
        res = TRUE;
        continue;
      case 0:
        break;
      default:
        res = FALSE;
    }
    break;
  }

  if (pNum)
    *pNum = num*sign;

  return res;
}
///////////////////////////////////////////////////////////////
bool MatchPattern(const char *pPattern, const char *pStr)
{
  for (;;) {
    switch (*pPattern) {
      case '*':
        pPattern++;
        do {
          if (MatchPattern(pPattern, pStr))
            return TRUE;
        } while (*pStr++);

        return FALSE;
      case '?':
        if (!*pStr)
          return FALSE;

        pStr++;
        pPattern++;
        break;
      default:
        if (*pPattern != *pStr)
          return FALSE;

        if (!*pStr)
          return TRUE;

        pStr++;
        pPattern++;
    }
  }
}
///////////////////////////////////////////////////////////////
char *STRDUP(const char *pSrcStr, bool showErrors)
{
  char *pDstStr;
  int len = lstrlen(pSrcStr) + 1;

  pDstStr = (char *)LocalAlloc(LPTR, len*sizeof(pDstStr[0]));

  if (pDstStr != NULL) {
    SNPRINTF(pDstStr, len, "%s", pSrcStr);
  } else {
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    if (showErrors)
      ShowLastError(MB_OK|MB_ICONSTOP, "LocalAlloc(%lu)", (unsigned long)(len*sizeof(pDstStr[0])));
  }

  return pDstStr;
}
///////////////////////////////////////////////////////////////
void BusyMask::Clear()
{
  if (pBusyMask) {
    LocalFree(pBusyMask);
    pBusyMask = NULL;
    busyMaskLen = 0;
  }
}

bool BusyMask::AddNum(int num)
{
  ULONG maskNum = num/(sizeof(*pBusyMask)*8);

  if (maskNum >= busyMaskLen) {
    SIZE_T newBusyMaskLen = maskNum + 1;
    PBYTE pNewBusyMask;

    if (!pBusyMask)
      pNewBusyMask = (PBYTE)LocalAlloc(LPTR, newBusyMaskLen);
    else
      pNewBusyMask = (PBYTE)LocalReAlloc(pBusyMask, newBusyMaskLen, LMEM_ZEROINIT|LMEM_MOVEABLE);

    if (pNewBusyMask) {
      pBusyMask = pNewBusyMask;
      busyMaskLen = newBusyMaskLen;
    } else {
      SetLastError(ERROR_NOT_ENOUGH_MEMORY);
      return FALSE;
    }
  }

  ULONG mask = 1 << (num%(sizeof(*pBusyMask)*8));

  pBusyMask[maskNum] |= mask;

  return TRUE;
}

void BusyMask::DelNum(int num)
{
  ULONG maskNum = num/(sizeof(*pBusyMask)*8);

  if (maskNum >= busyMaskLen)
    return;

  ULONG mask = 1 << (num%(sizeof(*pBusyMask)*8));

  pBusyMask[maskNum] &= ~mask;
}

bool BusyMask::IsFreeNum(int num) const
{
  ULONG maskNum = num/(sizeof(*pBusyMask)*8);

  if (maskNum >= busyMaskLen)
    return TRUE;

  ULONG mask = 1 << (num%(sizeof(*pBusyMask)*8));

  return (pBusyMask[maskNum] & mask) == 0;
}

int BusyMask::GetFirstFreeNum() const
{
  int num;

  for (num = 0 ; !IsFreeNum(num) ; num++)
    ;

  return num;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/params.h

/*
 * $Id: params.h,v 1.14 2012/01/31 05:48:32 vfrolov Exp $
 *
 * Copyright (c) 2006-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: params.h,v $
 * Revision 1.14  2012/01/31 05:48:32  vfrolov
 * Deprecated invoking of system-supplied advanced settings dialog box
 *
 * Revision 1.13  2011/12/29 14:34:23  vfrolov
 * Implemented RealPortName=COM<n> for PortName=COM#
 *
 * Revision 1.12  2011/12/27 11:38:13  vfrolov
 * Superseded incorrect PortParameters::ClassChanged()
 *
 * Revision 1.11  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.10  2011/12/06 16:03:22  vfrolov
 * Added cleaning high data bits for less then 8 bit data
 * Added AllDataBits option to force 8 bit data
 *
 * Revision 1.9  2010/05/31 07:58:14  vfrolov
 * Added ability to invoke the system-supplied advanced settings dialog box
 *
 * Revision 1.8  2008/09/17 07:58:32  vfrolov
 * Added AddRTTO and AddRITO parameters
 *
 * Revision 1.7  2008/06/26 13:39:19  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.6  2008/05/04 09:53:51  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.5  2007/10/19 16:09:55  vfrolov
 * Implemented --detail-prms option
 *
 * Revision 1.4  2007/07/03 14:39:49  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.3  2007/06/01 16:32:04  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.2  2006/10/27 13:11:58  vfrolov
 * Added PortParameters::FillPortName()
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_PARAMS_H_
#define _C0C_PARAMS_H_

struct Bit;

class PortParameters {
  public:
    PortParameters(const char *pService, const char *pPhPortName);

    void Init();
    LONG Load();
    LONG Save();
    bool InitRealPortName(const char *pRealPortName = "");
    bool ParseParametersStr(const char *pParameters);
    bool FillParametersStr(char *pParameters, int size, bool detail);
    bool FillPortName(char *pPortName, int size);
    bool FillRealPortName(char *pRealPortName, int size);
    bool Changed() const { return maskChanged != 0; }

    static const char *PortParameters::GetHelp();

  protected:
    bool FillParametersKey(char *pRegKey, int size);
    DWORD *GetDwPtr(DWORD bit);
    void LoadDw(HKEY hKey, DWORD bit);
    LONG SaveDw(HKEY hKey, DWORD bit);

    bool SetPortName(const char *pNewPortName);
    bool SetRealPortName(const char *pNewRealPortName);
    bool SetFlag(const char *pNewVal, DWORD bit);
    bool SetPin(const char *pNewVal, DWORD bit);
    bool SetProbability(const char *pNewVal, DWORD bit);
    bool SetUnsigned(const char *pNewVal, DWORD bit);
    bool SetBit(const char *pVal, const Bit &bit);

    DWORD maskChanged;
    DWORD maskExplicit;
    char portName[20];
    char realPortName[20];
    DWORD emuBR;
    DWORD emuOverrun;
    DWORD plugInMode;
    DWORD exclusiveMode;
    DWORD hiddenMode;
    DWORD allDataBits;
    DWORD pinCTS;
    DWORD pinDSR;
    DWORD pinDCD;
    DWORD pinRI;
    DWORD emuNoise;
    DWORD addRTTO;
    DWORD addRITO;

    char service[20];
    char phPortName[20];
};

#endif /* _C0C_PARAMS_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/portnum.cpp

/*
 * $Id: portnum.cpp,v 1.1 2006/11/02 16:07:02 vfrolov Exp $
 *
 * Copyright (c) 2006 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: portnum.cpp,v $
 * Revision 1.1  2006/11/02 16:07:02  vfrolov
 * Initial revision
 *
 *
 */

#include "precomp.h"
#include "portnum.h"

#define TEXT_PREF
#include "../include/com0com.h"

///////////////////////////////////////////////////////////////
int GetPortNum(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData)
{
  HKEY hKey;

  hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);

  if (hKey == INVALID_HANDLE_VALUE)
    return -1;

  int num;
  DWORD len;
  DWORD portNum;

  len = sizeof(portNum);

  if (RegQueryValueEx(hKey, C0C_REGSTR_VAL_PORT_NUM, NULL, NULL, (PBYTE)&portNum, &len) == ERROR_SUCCESS)
    num = portNum;
  else
    num = -1;

  RegCloseKey(hKey);

  return num;
}
///////////////////////////////////////////////////////////////
LONG SetPortNum(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    int num)
{
  HKEY hKey;

  hKey = SetupDiCreateDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL);

  if (hKey == INVALID_HANDLE_VALUE)
    return GetLastError();

  DWORD portNum = num;

  LONG err = RegSetValueEx(hKey, C0C_REGSTR_VAL_PORT_NUM, NULL, REG_DWORD, (PBYTE)&portNum, sizeof(portNum));

  RegCloseKey(hKey);

  return err;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/precomp.h

/*
 * $Id: precomp.h,v 1.2 2007/10/01 14:56:39 vfrolov Exp $
 *
 * Copyright (c) 2006-2007 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: precomp.h,v $
 * Revision 1.2  2007/10/01 14:56:39  vfrolov
 * Added shlwapi
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <newdev.h>
#include <cfgmgr32.h>
#include <regstr.h>
#pragma warning(push, 3)
#include <setupapi.h>
#include <shlwapi.h>
#pragma warning(pop)

#endif /* _PRECOMP_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/inffile.h

/*
 * $Id: inffile.h,v 1.4 2011/12/15 15:51:48 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: inffile.h,v $
 * Revision 1.4  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.3  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.2  2006/10/19 13:28:50  vfrolov
 * Added InfFile::UninstallAllInfFiles()
 *
 * Revision 1.1  2006/07/28 12:16:42  vfrolov
 * Initial revision
 *
 *
 */

#ifndef _C0C_INFFILE_H_
#define _C0C_INFFILE_H_

class InfFile {
  public:
    struct InfFileField {
      const char *pSection;
      const char *pKey;
      int         nField;
      const char *pFieldValue;
    };

    struct InfFileUninstall {
      const InfFile::InfFileField *pRequiredFields;
      bool queryConfirmation;
    };

  public:
    InfFile(const char *pInfName, const char *pNearPath);
    ~InfFile();

    bool Test(const InfFileField *pFields, bool showErrors = TRUE) const;

    const char *Path() const { return pPath; }
    const char *OemPath(bool showErrors = TRUE) const;
    const char *ClassGUID(bool showErrors = TRUE) const;
    const char *Class(bool showErrors = TRUE) const;
    const char *Provider(bool showErrors = TRUE) const;
    const char *DriverVer(bool showErrors = TRUE) const;
    const char *UninstallInfTag(bool showErrors = TRUE) const;

    bool UninstallFiles(const char *pFilesSection) const;

    bool InstallOEMInf() const;
    bool UninstallOEMInf() const;

    static bool UninstallAllInfFiles(
        const InfFileUninstall *pInfFileUninstallList,
        const char *const *ppOemPathExcludeList);

  protected:
    char *pPath;
    mutable char *pOemPath;
    mutable char *pClassGUID;
    mutable char *pClass;
    mutable char *pProvider;
    mutable char *pDriverVer;
    mutable char *pUninstallInfTag;
    mutable HINF hInf;
};

#endif /* _C0C_PARAMS_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/makefile

!INCLUDE $(NTMAKEENV)\makefile.def


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/setup.cpp

/*
 * $Id: setup.cpp,v 1.55 2012/01/31 05:47:22 vfrolov Exp $
 *
 * Copyright (c) 2006-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: setup.cpp,v $
 * Revision 1.55  2012/01/31 05:47:22  vfrolov
 * Deprecated invoking of system-supplied advanced settings dialog box
 * Allowed re-use port name while migration from Ports class to CNCPorts class
 *
 * Revision 1.54  2012/01/10 11:24:27  vfrolov
 * Added ability to repeate waiting for no pending device
 * installation activities
 *
 * Revision 1.53  2011/12/29 14:34:23  vfrolov
 * Implemented RealPortName=COM<n> for PortName=COM#
 *
 * Revision 1.52  2011/12/28 06:23:50  vfrolov
 * Added setting friendly names for ports after changing port class
 *
 * Revision 1.51  2011/12/27 11:38:13  vfrolov
 * Superseded incorrect PortParameters::ClassChanged()
 *
 * Revision 1.50  2011/12/23 05:37:21  vfrolov
 * Implemented setting friendly names for ports
 * Added options -no-update-fnames and --show-fnames
 * Added commands updatefnames and listfnames
 *
 * Revision 1.49  2011/12/21 13:24:12  vfrolov
 * Added using DeviceDesc to set FriendlyName
 *
 * Revision 1.48  2011/12/15 16:43:20  vfrolov
 * Added parameters parsing result check
 *
 * Revision 1.47  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.46  2011/07/15 16:09:05  vfrolov
 * Disabled MessageBox() for silent mode and added default processing
 *
 * Revision 1.45  2011/07/13 17:39:56  vfrolov
 * Fixed result treatment of UpdateDriverForPlugAndPlayDevices()
 *
 * Revision 1.44  2010/07/30 09:19:29  vfrolov
 * Added STRDUP()
 *
 * Revision 1.43  2010/07/29 12:18:43  vfrolov
 * Fixed waiting stuff
 *
 * Revision 1.42  2010/07/19 11:23:54  vfrolov
 * Added install command w/o prms to update driver
 * Added ability to use --wait option with any command
 *
 * Revision 1.41  2010/07/15 18:11:10  vfrolov
 * Fixed --wait option for Ports class
 *
 * Revision 1.40  2010/07/12 18:14:44  vfrolov
 * Fixed driver update duplication
 *
 * Revision 1.39  2010/06/07 07:03:31  vfrolov
 * Added wrapper UpdateDriver() for UpdateDriverForPlugAndPlayDevices()
 *
 * Revision 1.38  2010/06/01 06:14:10  vfrolov
 * Improved driver updating
 *
 * Revision 1.37  2010/05/31 07:58:14  vfrolov
 * Added ability to invoke the system-supplied advanced settings dialog box
 *
 * Revision 1.36  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.35  2010/03/30 08:05:15  vfrolov
 * Fixed bugs item #2979007 "setupc command line limited to 200 chars"
 * Reported by Henrik Maier (hwmaier)
 *
 * Revision 1.34  2010/03/11 13:40:57  vfrolov
 * Fixed size typo, bug #2968585
 * Thanks Xlnt (xlnt9568)
 *
 * Revision 1.33  2009/11/16 08:43:44  vfrolov
 * Fixed endless loop if no ports logged in ComDB
 *
 * Revision 1.32  2009/09/18 11:21:31  vfrolov
 * Added --wait option
 *
 * Revision 1.31  2009/09/18 07:48:11  vfrolov
 * Added missing argv[0] shift
 *
 * Revision 1.30  2009/02/16 10:32:56  vfrolov
 * Added Silent() and PromptReboot()
 *
 * Revision 1.29  2009/02/11 07:35:22  vfrolov
 * Added --no-update option
 *
 * Revision 1.28  2009/01/12 12:48:05  vfrolov
 * Fixed typo
 *
 * Revision 1.27  2008/12/25 16:58:45  vfrolov
 * Implemented busynames command
 *
 * Revision 1.26  2008/12/24 15:32:22  vfrolov
 * Added logging COM port numbers in the COM port database
 *
 * Revision 1.25  2008/09/12 12:21:49  vfrolov
 * Added --silent option
 *
 * Revision 1.24  2008/09/12 09:55:59  vfrolov
 * Fixed help cutting
 *
 * Revision 1.23  2008/04/02 10:28:24  vfrolov
 * Added reload command
 *
 * Revision 1.22  2007/11/27 16:32:54  vfrolov
 * Added disable and enable options
 *
 * Revision 1.21  2007/10/19 16:09:55  vfrolov
 * Implemented --detail-prms option
 *
 * Revision 1.20  2007/10/15 13:49:04  vfrolov
 * Added entry point MainA
 *
 * Revision 1.19  2007/10/05 07:28:26  vfrolov
 * Added listing pairs w/o PortNum
 *
 * Revision 1.18  2007/10/01 15:44:19  vfrolov
 * Added check for install two ports with the same name
 *
 * Revision 1.17  2007/10/01 15:01:35  vfrolov
 * Added pDevInstID parameter to InstallDevice()
 *
 * Revision 1.16  2007/09/25 12:42:49  vfrolov
 * Fixed update command (bug if multiple pairs active)
 * Fixed uninstall command (restore active ports on cancell)
 *
 * Revision 1.15  2007/07/03 14:42:10  vfrolov
 * Added friendly name setting for bus device
 *
 * Revision 1.14  2007/06/14 16:14:19  vfrolov
 * Added test for "in use" in the COM port database
 *
 * Revision 1.13  2007/05/29 15:30:41  vfrolov
 * Fixed big hepl text interrupt
 *
 * Revision 1.12  2007/01/11 15:05:03  vfrolov
 * Replaced strtok() by STRTOK_R()
 *
 * Revision 1.11  2006/11/21 11:36:06  vfrolov
 * Added --output option
 *
 * Revision 1.10  2006/11/10 14:07:40  vfrolov
 * Implemented remove command
 *
 * Revision 1.9  2006/11/03 16:13:29  vfrolov
 * Added port name length checkings
 *
 * Revision 1.8  2006/11/03 13:22:07  vfrolov
 * Added checking of BusyMask::AddNum() return value
 *
 * Revision 1.7  2006/11/02 16:20:44  vfrolov
 * Added usage the fixed port numbers
 *
 * Revision 1.6  2006/10/27 13:23:49  vfrolov
 * Added check if port name is already used for other device
 * Fixed incorrect port restart
 * Fixed prompts
 *
 * Revision 1.5  2006/10/23 12:08:31  vfrolov
 * Added interactive mode
 * Added more help
 * Added SetTitle() calls
 *
 * Revision 1.4  2006/10/19 13:28:50  vfrolov
 * Added InfFile::UninstallAllInfFiles()
 *
 * Revision 1.3  2006/10/13 10:26:35  vfrolov
 * Some defines moved to ../include/com0com.h
 * Changed name of device object (for WMI)
 *
 * Revision 1.2  2006/08/25 10:36:48  vfrolov
 * Added C0C_PREF_PORT_NAME_A and C0C_PREF_PORT_NAME_B defines
 * Added deleting Class subkeys
 *
 * Revision 1.1  2006/07/28 12:16:42  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "inffile.h"
#include "params.h"
#include "devutils.h"
#include "msg.h"
#include "utils.h"
#include "portnum.h"
#include "comdb.h"
#include <msports.h>

#define TEXT_PREF
#include "../include/com0com.h"

#define C0C_INF_NAME             "com0com.inf"
#define C0C_INF_NAME_CNCPORT     "cncport.inf"
#define C0C_INF_NAME_COMPORT     "comport.inf"
#define C0C_CNCCLASS_GUID        "{df799e12-3c56-421b-b298-b6d3642bc878}"
#define C0C_COMCLASS_GUID        "{4d36e978-e325-11ce-bfc1-08002be10318}"
#define C0C_PROVIDER             "Vyacheslav Frolov"
#define C0C_REGKEY_EVENTLOG      REGSTR_PATH_SERVICES "\\Eventlog\\System\\" C0C_SERVICE
#define C0C_COPY_DRIVERS_SECTION "com0com_CopyDrivers"

#define C0C_SETUP_TITLE          "Setup for com0com"
///////////////////////////////////////////////////////////////
static const InfFile::InfFileField requiredFieldsInfBusInstall[] = {
  { "Version",         "ClassGUID",          1, C0C_CNCCLASS_GUID },
  { "Version",         "Provider",           1, C0C_PROVIDER },
  { "Version",         "UninstallInfTag",    1, C0C_CNCCLASS_GUID },
  { "Manufacturer",    NULL,                 1, C0C_SERVICE },
  { NULL },
};

static const InfFile::InfFileField requiredFieldsInfCNCPortInstall[] = {
  { "Version",         "ClassGUID",          1, C0C_CNCCLASS_GUID },
  { "Version",         "Provider",           1, C0C_PROVIDER },
  { "Version",         "UninstallInfTag",    1, C0C_CNCCLASS_GUID },
  { "Manufacturer",    NULL,                 1, C0C_SERVICE },
  { NULL },
};

static const InfFile::InfFileField requiredFieldsInfCOMPortInstall[] = {
  { "Version",         "ClassGUID",          1, C0C_COMCLASS_GUID },
  { "Version",         "Provider",           1, C0C_PROVIDER },
  { "Version",         "UninstallInfTag",    1, C0C_CNCCLASS_GUID },
  { "Manufacturer",    NULL,                 1, C0C_SERVICE },
  { NULL },
};

struct InfFileInstall {
  const char *pInfName;
  const char *pCopyDriversSection;
  const char *pHardwareId;
  bool preinstallClass;
  const InfFile::InfFileField *pRequiredFields;
};

static const InfFileInstall infFileInstallList[] = {
  { C0C_INF_NAME,          C0C_COPY_DRIVERS_SECTION,  C0C_BUS_DEVICE_ID,        TRUE,  requiredFieldsInfBusInstall },
  { C0C_INF_NAME_CNCPORT,  NULL,                      C0C_PORT_HW_ID_CNCCLASS,  FALSE, requiredFieldsInfCNCPortInstall },
  { C0C_INF_NAME_COMPORT,  NULL,                      C0C_PORT_HW_ID_COMCLASS,  FALSE, requiredFieldsInfCOMPortInstall },
  { NULL },
};
///////////////////////////////////////////////////////////////
static const InfFile::InfFileField requiredFieldsInfUnnstallInfTag[] = {
  { "Version",         "UninstallInfTag",    1, C0C_CNCCLASS_GUID },
  { "Manufacturer",    NULL,                 1, C0C_SERVICE },
  { NULL },
};

static const InfFile::InfFileField requiredFieldsInfUnnstallCNCOld[] = {
  { "Version",         "ClassGUID",          1, C0C_CNCCLASS_GUID },
  { "Version",         "Provider",           1, C0C_PROVIDER },
  { "Version",         "CatalogFile",        1, "com0com.cat" },
  { NULL },
};

static const InfFile::InfFileField requiredFieldsInfUnnstallCNCClass[] = {
  { "Version",         "ClassGUID",          1, C0C_CNCCLASS_GUID },
  { NULL },
};

static const InfFile::InfFileField requiredFieldsInfUnnstallCOMClass[] = {
  { "Version",         "ClassGUID",          1, C0C_COMCLASS_GUID },
  { "Manufacturer",    NULL,                 1, C0C_SERVICE },
  { NULL },
};

static const InfFile::InfFileUninstall infFileUnnstallList[] = {
  { requiredFieldsInfUnnstallInfTag,    FALSE },
  { requiredFieldsInfUnnstallCNCOld,    FALSE },
  { requiredFieldsInfUnnstallCNCClass,  TRUE },
  { requiredFieldsInfUnnstallCOMClass,  TRUE },
  { NULL },
};
///////////////////////////////////////////////////////////////
static int timeout = 0;
static bool repeate_timeout = FALSE;
static bool detailPrms = FALSE;
static bool no_update = FALSE;
static bool no_update_fnames = FALSE;
static bool show_fnames = FALSE;
///////////////////////////////////////////////////////////////
bool IsComClass(const char *pPortName)
{
  return lstrcmpi(pPortName, C0C_PORT_NAME_COMCLASS) == 0;
}
///////////////////////////////////////////////////////////////
static CNC_ENUM_FILTER EnumFilter;
static bool EnumFilter(const char *pHardwareId)
{
  if (!pHardwareId)
    return FALSE;

  if (lstrcmpi(pHardwareId, C0C_BUS_DEVICE_ID) == 0 ||
      lstrcmpi(pHardwareId, C0C_PORT_DEVICE_ID) == 0)
  {
    //Trace("CNC %s\n", pHardwareId);
    return TRUE;
  }

  return FALSE;
}
///////////////////////////////////////////////////////////////
static bool FillPortDevProperties(DevProperties &devProperties, int iBus, bool isA)
{
  char phDevName[40];

  SNPRINTF(phDevName, sizeof(phDevName)/sizeof(phDevName[0]), "%s%d",
    isA ? C0C_PREF_DEVICE_NAME_A : C0C_PREF_DEVICE_NAME_B, iBus);

  if (!devProperties.DevId(C0C_PORT_DEVICE_ID))
    return FALSE;

  if (!devProperties.PhObjName(phDevName))
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool IsValidPortNum(int num)
{
  if (num < 0)
    return FALSE;

  char buf[C0C_PORT_NAME_LEN + 1];

  if (SNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), C0C_PREF_BUS_NAME "%d", num) < 0 ||
      SNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), C0C_PREF_PORT_NAME_A "%d", num) < 0 ||
      SNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), C0C_PREF_PORT_NAME_B "%d", num) < 0)
  {
    int res = ShowMsg(MB_OKCANCEL|MB_ICONWARNING, "The port number %d is too big.\n", num);

    if (res == IDCANCEL || res == 0)
      return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool IsValidPortName(
    const char *pPortName)
{
  int res;
  int len = lstrlen(pPortName);

  if (len <= 0) {
    ShowMsg(MB_OK|MB_ICONSTOP, "The port name is empty.\n");
    return FALSE;
  }
  else
  if (len > C0C_PORT_NAME_LEN) {
    res = ShowMsg(MB_OKCANCEL|MB_ICONWARNING,
                  "The length of port name %s\n"
                  "is too big (greater then %d).\n",
                  pPortName, C0C_PORT_NAME_LEN);

    if (res == IDCANCEL || res == 0)
      return FALSE;
  }

  do {
    res = IDCONTINUE;

    char phDevName[80];

    if (!QueryDosDevice(pPortName, phDevName, sizeof(phDevName)/sizeof(phDevName[0]))) {
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        continue;

      phDevName[0] = 0;
    }

    res = ShowMsg(MB_CANCELTRYCONTINUE,
                  "The port name %s is already used for other device %s.\n",
                  pPortName, phDevName);

  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  do {
    res = IDCONTINUE;

    bool inUse;

    if (!ComDbGetInUse(pPortName, inUse)) {
      res = IDCANCEL;
      continue;
    }

    if (inUse) {
      res = ShowMsg(MB_CANCELTRYCONTINUE,
                    "The port name %s is already logged as \"in use\"\n"
                    "in the COM port database.\n",
                    pPortName);
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
static VOID UpdateFriendlyNameBus(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    int num)
{
  char portName[2][20];

  for (int j = 0 ; j < 2 ; j++) {
    char phPortName[20];

    SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s%d",
             j ? C0C_PREF_PORT_NAME_B : C0C_PREF_PORT_NAME_A, num);

    PortParameters portParameters(C0C_SERVICE, phPortName);

    if (portParameters.Load() == ERROR_SUCCESS)
      portParameters.FillPortName(portName[j], sizeof(portName[j])/sizeof(portName[j][0]));
    else
      SNPRINTF(portName[j], sizeof(portName[j])/sizeof(portName[j][0]), "%s", phPortName);
  }

  char friendlyNameOld[120];

  if (!SetupDiGetDeviceRegistryProperty(hDevInfo, pDevInfoData, SPDRP_FRIENDLYNAME, NULL,
                                        (LPBYTE)friendlyNameOld, sizeof(friendlyNameOld), NULL))
  {
    SNPRINTF(friendlyNameOld, sizeof(friendlyNameOld)/sizeof(friendlyNameOld[0]), "");
  }

  if (show_fnames)
    Trace("       " C0C_PREF_BUS_NAME "%d FriendlyName=\"%s\"\n", num, friendlyNameOld);

  if (!no_update_fnames) {
    char deviceDesc[80];

    if (!SetupDiGetDeviceRegistryProperty(hDevInfo, pDevInfoData, SPDRP_DEVICEDESC, NULL,
                                          (LPBYTE)deviceDesc, sizeof(deviceDesc), NULL))
    {
      SNPRINTF(deviceDesc, sizeof(deviceDesc)/sizeof(deviceDesc[0]),
               "com0com - bus for serial port pair emulator");
    }

    char friendlyName[120];

    SNPRINTF(friendlyName, sizeof(friendlyName)/sizeof(friendlyName[0]),
             "%s %d (%s <-> %s)",
             deviceDesc, num, portName[0], portName[1]);

    if (lstrcmp(friendlyName, friendlyNameOld) != 0) {
      if (SetupDiSetDeviceRegistryProperty(hDevInfo, pDevInfoData, SPDRP_FRIENDLYNAME,
                                      (LPBYTE)friendlyName, (lstrlen(friendlyName) + 1) * sizeof(*friendlyName)))
      {
        if (show_fnames)
          Trace("update " C0C_PREF_BUS_NAME "%d FriendlyName=\"%s\"\n", num, friendlyName);
      }
    }
  }
}
///////////////////////////////////////////////////////////////
static VOID SetFriendlyNamePort(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    const char *pPhObjName)
{
  //Trace("SetFriendlyNamePort pPhObjName=%s\n", pPhObjName);

  if (!pPhObjName)
    return;

  char phPortName[20];

  for (int j = 0 ;; j++) {
    if (j > 1)
      return;

    const char *pPref = (j ? C0C_PREF_DEVICE_NAME_B : C0C_PREF_DEVICE_NAME_A);
    int lenPref = lstrlen(pPref);

    if (lenPref >= lstrlen(pPhObjName))
      continue;

    if (memcmp(pPhObjName, pPref, lenPref*sizeof(pPref[0])) != 0)
      continue;

    int num;

    if (!StrToInt(pPhObjName + lenPref, &num) || num < 0)
      continue;

    SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s%d",
             j ? C0C_PREF_PORT_NAME_B : C0C_PREF_PORT_NAME_A, num);

    break;
  }

  //Trace("SetFriendlyNamePort phPortName=%s\n", phPortName);

  char portName[20];
  PortParameters portParameters(C0C_SERVICE, phPortName);

  if (portParameters.Load() == ERROR_SUCCESS)
    portParameters.FillPortName(portName, sizeof(portName)/sizeof(portName[0]));
  else
    SNPRINTF(portName, sizeof(portName)/sizeof(portName[0]), "%s", phPortName);

  //Trace("SetFriendlyNamePort portName=%s\n", portName);

  char friendlyNameOld[120];

  if (!SetupDiGetDeviceRegistryProperty(hDevInfo, pDevInfoData, SPDRP_FRIENDLYNAME, NULL,
                                        (LPBYTE)friendlyNameOld, sizeof(friendlyNameOld), NULL))
  {
    SNPRINTF(friendlyNameOld, sizeof(friendlyNameOld)/sizeof(friendlyNameOld[0]), "");
  }

  if (show_fnames)
    Trace("       %s FriendlyName=\"%s\"\n", phPortName, friendlyNameOld);

  if (IsComClass(portName)) {
    HKEY hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);

    if (hKey == INVALID_HANDLE_VALUE)
      return;

    DWORD len = sizeof(portName);

    LONG err = RegQueryValueEx(hKey, "PortName", NULL, NULL, (PBYTE)portName, &len);

    RegCloseKey(hKey);

    if (err != ERROR_SUCCESS)
      return;
  }

  if (!no_update_fnames) {
    char deviceDesc[80];

    if (!SetupDiGetDeviceRegistryProperty(hDevInfo, pDevInfoData, SPDRP_DEVICEDESC, NULL,
                                          (LPBYTE)deviceDesc, sizeof(deviceDesc), NULL))
    {
      SNPRINTF(deviceDesc, sizeof(deviceDesc)/sizeof(deviceDesc[0]),
               "com0com - serial port emulator");
    }

    char friendlyName[120];

    SNPRINTF(friendlyName, sizeof(friendlyName)/sizeof(friendlyName[0]), "%s %s (%s)", deviceDesc, phPortName, portName);

    //Trace("SetFriendlyNamePort friendlyName=%s\n", friendlyName);

    if (lstrcmp(friendlyName, friendlyNameOld) != 0) {
      if (SetupDiSetDeviceRegistryProperty(hDevInfo, pDevInfoData, SPDRP_FRIENDLYNAME,
                                      (LPBYTE)friendlyName, (lstrlen(friendlyName) + 1) * sizeof(*friendlyName)))
      {
        if (show_fnames)
          Trace("update %s FriendlyName=\"%s\"\n", phPortName, friendlyName);
      }
    }
  }
}
///////////////////////////////////////////////////////////////
static CNC_DEV_CALLBACK UpdateFriendlyNamePort;
static bool UpdateFriendlyNamePort(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL * /*pRebootRequired*/,
    void * /*pParam*/)
{
  if (!lstrcmp(pDevProperties->DevId(), C0C_PORT_DEVICE_ID)) {
    SetFriendlyNamePort(hDevInfo, pDevInfoData, pDevProperties->PhObjName());
    return TRUE;
  }

  // we never should be here
  return FALSE;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_CALLBACK UpdateFriendlyNamesBus;
static bool UpdateFriendlyNamesBus(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    void *pParam)
{
  if (!lstrcmp(pDevProperties->DevId(), C0C_BUS_DEVICE_ID)) {
    int num = GetPortNum(hDevInfo, pDevInfoData);

    if (*(int *)pParam == num || *(int *)pParam == -1) {
      UpdateFriendlyNameBus(hDevInfo, pDevInfoData, num);

      for (int j = 0 ; j < 2 ; j++) {
        DevProperties devProperties;

        if (!FillPortDevProperties(devProperties, num, j == 0))
          return FALSE;

        EnumDevices(EnumFilter, &devProperties, pRebootRequired, UpdateFriendlyNamePort, NULL);
      }
    }

    return TRUE;
  }

  // we never should be here
  return FALSE;
}
///////////////////////////////////////////////////////////////
static VOID CleanDevPropertiesStack(
    Stack &stack,
    bool enable,
    BOOL *pRebootRequired)
{
  for (;;) {
    StackEl *pElem = stack.Pop();

    if (!pElem)
      break;

    DevProperties *pDevProperties = (DevProperties *)pElem->pData;

    delete pElem;

    if (pDevProperties) {
      if (enable && pDevProperties->PhObjName())
        EnableDevices(EnumFilter, pDevProperties, pRebootRequired);

      delete pDevProperties;
    }
  }
}
///////////////////////////////////////////////////////////////
static CNC_DEV_CALLBACK LoadRealPortName;
static bool LoadRealPortName(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL * /*pRebootRequired*/,
    void *pParam)
{
  if (!lstrcmp(pDevProperties->DevId(), C0C_PORT_DEVICE_ID)) {
    HKEY hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);

    if (hKey != INVALID_HANDLE_VALUE) {
      char portNameOld[20];
      DWORD len = sizeof(portNameOld);

      LONG err = RegQueryValueEx(hKey, "PortName", NULL, NULL, (PBYTE)portNameOld, &len);

      if (err == ERROR_SUCCESS)
        ((PortParameters *)pParam)->InitRealPortName(portNameOld);

      RegCloseKey(hKey);
    }

    return TRUE;
  }

  // we never should be here
  return FALSE;
}

static CNC_DEV_CALLBACK UpdateRealPortName;
static bool UpdateRealPortName(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL * /*pRebootRequired*/,
    void *pParam)
{
  if (!lstrcmp(pDevProperties->DevId(), C0C_PORT_DEVICE_ID)) {
    HKEY hKey = SetupDiOpenDevRegKey(hDevInfo, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ|KEY_WRITE);

    if (hKey != INVALID_HANDLE_VALUE) {
      char portNameOld[20];
      DWORD len = sizeof(portNameOld);

      LONG err = RegQueryValueEx(hKey, "PortName", NULL, NULL, (PBYTE)portNameOld, &len);

      if (err == ERROR_SUCCESS) {
        const char*pPortNameNew = (const char*)pParam;

        if (ComDbClaim(pPortNameNew)) {
          err = RegSetValueEx(hKey, "PortName", 0, REG_SZ,
                              (PBYTE)pPortNameNew, (lstrlen(pPortNameNew) + 1) * sizeof(pPortNameNew[0]));

          if (err == ERROR_SUCCESS) {
            ComDbRelease((const char*)portNameOld);
            SetFriendlyNamePort(hDevInfo, pDevInfoData, pDevProperties->PhObjName());
          } else {
            ComDbRelease(pPortNameNew);
          }
        }
      }

      RegCloseKey(hKey);
    }

    return TRUE;
  }

  // we never should be here
  return FALSE;
}

struct ChangeDeviceParams {
  ChangeDeviceParams(
    const char *_pPhPortName,
    const char *_pParameters)
  : pPhPortName(_pPhPortName), pParameters(_pParameters), changed(FALSE) {}

  const char *pPhPortName;
  const char *pParameters;
  bool changed;
};

static CNC_DEV_CALLBACK ChangeDevice;
static bool ChangeDevice(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties /*pDevProperties*/,
    BOOL *pRebootRequired,
    void *pParam)
{
  int i = GetPortNum(hDevInfo, pDevInfoData);

  if (i >= 0) {
    const char *pPhPortName = ((ChangeDeviceParams *)pParam)->pPhPortName;
    const char *pParameters = ((ChangeDeviceParams *)pParam)->pParameters;

    for (int j = 0 ; j < 2 ; j++) {
      char buf[200];
      char phPortName[20];

      SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s%d",
               j ? C0C_PREF_PORT_NAME_B : C0C_PREF_PORT_NAME_A, i);

      PortParameters portParameters(C0C_SERVICE, phPortName);
      LONG err = portParameters.Load();

      if (err != ERROR_SUCCESS) {
        portParameters.FillParametersStr(buf, sizeof(buf)/sizeof(buf[0]), detailPrms);
        Trace("       %s %s\n", phPortName, buf);
        ShowError(MB_OK|MB_ICONWARNING, err, "portParameters.Load(%s)", phPortName);
        continue;
      }

      char portNameOld[20];

      if (!portParameters.FillPortName(portNameOld, sizeof(portNameOld)/sizeof(portNameOld[0])))
        continue;

      bool isComClassOld = IsComClass(portNameOld);

      DevProperties devProperties;

      if (!FillPortDevProperties(devProperties, i, j == 0))
        continue;

      if (isComClassOld)
        EnumDevices(EnumFilter, &devProperties, pRebootRequired, LoadRealPortName, &portParameters);

      portParameters.FillParametersStr(buf, sizeof(buf)/sizeof(buf[0]), detailPrms);

      Trace("       %s %s\n", phPortName, buf);

      if (!pPhPortName || lstrcmpi(pPhPortName, phPortName) != 0 || !pParameters)
        continue;

      char realPortNameOld[20];

      if (!portParameters.FillRealPortName(realPortNameOld, sizeof(realPortNameOld)/sizeof(realPortNameOld[0])))
        continue;

      if (!portParameters.ParseParametersStr(pParameters))
        continue;

      char portNameNew[20];

      if (!portParameters.FillPortName(portNameNew, sizeof(portNameNew)/sizeof(portNameNew[0])))
        continue;

      if (lstrcmpi(portNameNew, portNameOld) != 0) {
        if (!isComClassOld || lstrcmpi("", realPortNameOld) == 0 || lstrcmpi(portNameNew, realPortNameOld) != 0) {
          if (!IsValidPortName(portNameNew))
            continue;
        }
      }

      bool isComClassNew = IsComClass(portNameNew);

      if (!isComClassNew || !isComClassOld) {
        realPortNameOld[0] = 0;
        portParameters.InitRealPortName();   // ignore RealPortName param
      }

      if (!portParameters.Changed())
        continue;

      char realPortNameNew[20];

      if (!portParameters.FillRealPortName(realPortNameNew, sizeof(realPortNameNew)/sizeof(realPortNameNew[0])))
        continue;

      if (lstrcmpi(realPortNameNew, realPortNameOld) != 0) {
        if (!IsValidPortName(realPortNameNew) || !ComDbIsValidName(realPortNameNew))
          continue;
      }

      err = portParameters.Save();

      if (err != ERROR_SUCCESS) {
        ShowError(MB_OK|MB_ICONWARNING, err, "portParameters.Save(%s)", phPortName);
        continue;
      }

      ((ChangeDeviceParams *)pParam)->changed = TRUE;

      portParameters.FillParametersStr(buf, sizeof(buf)/sizeof(buf[0]), detailPrms);
      Trace("change %s %s\n", phPortName, buf);

      if (lstrcmpi(portNameNew, portNameOld) != 0)
        UpdateFriendlyNameBus(hDevInfo, pDevInfoData, i);

      if (isComClassNew != isComClassOld) {
        Trace("Changed port class for %s (renamed %s to %s)\n", phPortName, portNameOld, portNameNew);
        DisableDevices(EnumFilter, &devProperties, pRebootRequired, NULL);  // show msg if in use
        RemoveDevices(EnumFilter, &devProperties, pRebootRequired);
        ReenumerateDeviceNode(pDevInfoData);
        EnumDevices(EnumFilter, &devProperties, pRebootRequired, UpdateFriendlyNamePort, NULL);
      } else {
        if (lstrcmpi(portNameNew, portNameOld) != 0)
          EnumDevices(EnumFilter, &devProperties, pRebootRequired, UpdateFriendlyNamePort, NULL);

        if (lstrcmpi(realPortNameNew, realPortNameOld) != 0)
          EnumDevices(EnumFilter, &devProperties, pRebootRequired, UpdateRealPortName, realPortNameNew);

        RestartDevices(EnumFilter, &devProperties, pRebootRequired);
      }
    }
  } else {
    Trace("       " C0C_PREF_PORT_NAME_A "?\n");
    Trace("       " C0C_PREF_PORT_NAME_B "?\n");
  }

  return TRUE;
}

bool Change(const char *pPhPortName, const char *pParameters)
{
  BOOL rebootRequired = FALSE;
  ChangeDeviceParams params(pPhPortName, pParameters);

  DevProperties devProperties;
  if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
    return FALSE;

  EnumDevices(EnumFilter, &devProperties, &rebootRequired, ChangeDevice, &params);

  if (params.changed)
    ComDbSync(EnumFilter);

  if (rebootRequired)
    PromptReboot();

  return TRUE;
}
///////////////////////////////////////////////////////////////
struct RemoveDeviceParams {
  RemoveDeviceParams(int _num) : num(_num), res(IDCANCEL) {}

  int num;
  int res;
};

static CNC_DEV_CALLBACK RemoveDevice;
static bool RemoveDevice(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL *pRebootRequired,
    void *pParam)
{
  int i = GetPortNum(hDevInfo, pDevInfoData);

  if (i == ((RemoveDeviceParams *)pParam)->num) {
    ((RemoveDeviceParams *)pParam)->res =
        DisableDevice(hDevInfo, pDevInfoData, pDevProperties, pRebootRequired, NULL);

    if (((RemoveDeviceParams *)pParam)->res != IDCONTINUE)
      return FALSE;

    return RemoveDevice(hDevInfo, pDevInfoData, pDevProperties, pRebootRequired);
  }

  return TRUE;
}

bool Remove(int num)
{
  int res;
  BOOL rebootRequired = FALSE;

  do {
    RemoveDeviceParams removeDeviceParams(num);

    DevProperties devProperties;
    if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
      return FALSE;

    EnumDevices(EnumFilter, &devProperties, &rebootRequired, RemoveDevice, &removeDeviceParams);

    res = removeDeviceParams.res;

  } while (res == IDTRYAGAIN);

  if (res == IDCONTINUE) {
    for (int j = 0 ; j < 2 ; j++) {
      char phPortName[20];

      SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s%d",
               j ? C0C_PREF_PORT_NAME_B : C0C_PREF_PORT_NAME_A, num);

      DevProperties devProperties;

      if (!devProperties.DevId(C0C_PORT_DEVICE_ID))
        return FALSE;

      if (!devProperties.Location(phPortName))
        return FALSE;

      RemoveDevices(EnumFilter, &devProperties, NULL);
    }
  }

  ComDbSync(EnumFilter);

  if (rebootRequired)
    PromptReboot();

  return (res == IDCONTINUE);
}
///////////////////////////////////////////////////////////////
bool Preinstall(const InfFileInstall *pInfFileInstallList)
{
  for (
      const InfFileInstall *pInfFileInstall = pInfFileInstallList ;
      pInfFileInstall->pInfName != NULL ;
      pInfFileInstall++)
  {
    InfFile infFile(pInfFileInstall->pInfName, pInfFileInstall->pInfName);

    if (pInfFileInstall->preinstallClass) {
      int res;

      do {
        res = IDCONTINUE;

        if (SetupDiInstallClass(NULL, infFile.Path(), Silent() ? 0 : DI_QUIETINSTALL, NULL)) {
          Trace("Installed Class %s\n", infFile.ClassGUID());
        } else {
          res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupDiInstallClass()");
        }
      } while (res == IDTRYAGAIN);

      if (res != IDCONTINUE)
        goto err;
    }

    if (!infFile.InstallOEMInf())
      goto err;
  }

  return TRUE;

err:

  Trace("\nPreinstall not completed!\n");

  return FALSE;
}
///////////////////////////////////////////////////////////////
bool Reload(
    const char *pHardwareId,
    const char *pInfFilePath,
    BOOL *pRebootRequired)
{
  Stack stack;
  BOOL rebootRequired = FALSE;

  DevProperties devProperties;
  if (!devProperties.DevId(pHardwareId))
    return FALSE;

  if (!DisableDevices(EnumFilter, &devProperties, &rebootRequired, &stack)) {
    CleanDevPropertiesStack(stack, TRUE, &rebootRequired);
    return FALSE;
  }

  if (pHardwareId && pInfFilePath && !no_update) {
    int res;

    do {
      res = UpdateDriver(pInfFilePath, pHardwareId, INSTALLFLAG_FORCE, FALSE, &rebootRequired);
    } while (res == IDTRYAGAIN);

    if (res != IDCONTINUE) {
      CleanDevPropertiesStack(stack, TRUE, &rebootRequired);
      return FALSE;
    }
  }

  CleanDevPropertiesStack(stack, TRUE, &rebootRequired);

  ComDbSync(EnumFilter);

  if (rebootRequired) {
    if (pRebootRequired != NULL)
      *pRebootRequired = TRUE;
    else
      PromptReboot();
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool Update(const InfFileInstall *pInfFileInstallList)
{
  bool ok = TRUE;
  BOOL rebootRequired = FALSE;

  for (
      const InfFileInstall *pInfFileInstall = pInfFileInstallList ;
      pInfFileInstall->pInfName != NULL ;
      pInfFileInstall++)
  {
    InfFile infFile(pInfFileInstall->pInfName, pInfFileInstall->pInfName);

    if (!Reload(pInfFileInstall->pHardwareId, infFile.Path(), &rebootRequired))
      ok = FALSE;
  }

  if (!ok) {
    Trace("\nUpdate not completed!\n");
  } else {
    DevProperties devProperties;

    if (devProperties.DevId(C0C_BUS_DEVICE_ID)) {
      int num = -1;

      EnumDevices(EnumFilter, &devProperties, &rebootRequired, UpdateFriendlyNamesBus, &num);
    }

    if (rebootRequired) {
      PromptReboot();
    }
  }

  return ok;
}
///////////////////////////////////////////////////////////////
bool Disable()
{
  BOOL rebootRequired = FALSE;

  DevProperties devProperties;
  if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
    return FALSE;

  if (!DisableDevices(EnumFilter, &devProperties, &rebootRequired, NULL))
    return FALSE;

  if (rebootRequired)
    PromptReboot();

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool Enable()
{
  BOOL rebootRequired = FALSE;

  DevProperties devProperties;
  if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
    return FALSE;

  if (!EnableDevices(EnumFilter, &devProperties, &rebootRequired)) {
    return FALSE;
  }

  if (rebootRequired)
    PromptReboot();

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool Install(const char *pInfFilePath)
{
  if (no_update)
    return TRUE;

  BOOL rebootRequired = FALSE;

  int res;

  do {
    res = UpdateDriver(pInfFilePath, C0C_BUS_DEVICE_ID, 0, FALSE, &rebootRequired);
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  ComDbSync(EnumFilter);

  DevProperties devProperties;

  if (devProperties.DevId(C0C_BUS_DEVICE_ID)) {
    int num = -1;

    EnumDevices(EnumFilter, &devProperties, &rebootRequired, UpdateFriendlyNamesBus, &num);
  }

  if (rebootRequired)
    PromptReboot();

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool UpdateFriendlyNames(bool update)
{
  bool no_update_fnames_save = no_update_fnames;

  if (!update)
    no_update_fnames = TRUE;

  bool show_fnames_save = show_fnames;

  show_fnames = TRUE;

  BOOL rebootRequired = FALSE;

  DevProperties devProperties;

  if (devProperties.DevId(C0C_BUS_DEVICE_ID)) {
    int num = -1;

    EnumDevices(EnumFilter, &devProperties, &rebootRequired, UpdateFriendlyNamesBus, &num);
  }

  if (rebootRequired)
    PromptReboot();

  show_fnames = show_fnames_save;
  no_update_fnames = no_update_fnames_save;

  return TRUE;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_CALLBACK InstallDeviceCallBack;
static bool InstallDeviceCallBack(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties pDevProperties,
    BOOL * /*pRebootRequired*/,
    void *pParam)
{
  if (!lstrcmp(pDevProperties->DevId(), C0C_BUS_DEVICE_ID)) {
    int res;
    int num = *(int *)pParam;

    do {
      res = IDCONTINUE;

      LONG err = SetPortNum(hDevInfo, pDevInfoData, num);

      if (err != ERROR_SUCCESS)
        res = ShowError(MB_CANCELTRYCONTINUE, err, "SetPortNum(%d)", num);

    } while (res == IDTRYAGAIN);

    if (res != IDCONTINUE)
      return FALSE;

    return TRUE;
  }

  return FALSE;
}

static bool InstallBusDevice(const char *pInfFilePath, int num)
{
  BOOL rebootRequired = FALSE;

  if (!InstallDevice(pInfFilePath, C0C_BUS_DEVICE_ID, NULL, InstallDeviceCallBack, &num, !no_update, &rebootRequired))
    return FALSE;

  DevProperties devProperties;

  if (devProperties.DevId(C0C_BUS_DEVICE_ID))
    EnumDevices(EnumFilter, &devProperties, &rebootRequired, UpdateFriendlyNamesBus, &num);

  if (rebootRequired)
    PromptReboot();

  return TRUE;
}

static CNC_DEV_CALLBACK AddDeviceToBusyMask;
static bool AddDeviceToBusyMask(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties /*pDevProperties*/,
    BOOL * /*pRebootRequired*/,
    void *pParam)
{
  int i = GetPortNum(hDevInfo, pDevInfoData);

  if (i >= 0) {
    if (!((BusyMask *)pParam)->AddNum(i)) {
      if (ShowLastError(MB_OKCANCEL|MB_ICONWARNING, "AddDeviceToBusyMask(%d)", i) != IDOK)
        return FALSE;
    }
  }

  return TRUE;
}

static int AllocPortNum(int num)
{
  BusyMask busyMask;

  DevProperties devProperties;
  if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
    return -1;

  if (EnumDevices(EnumFilter, &devProperties, NULL, AddDeviceToBusyMask, &busyMask) < 0)
    return -1;

  return busyMask.IsFreeNum(num) ? num : busyMask.GetFirstFreeNum();
}

bool Install(const char *pInfFilePath, const char *pParametersA, const char *pParametersB, int num)
{
  int i;
  int res;

  do {
    res = IDCONTINUE;

    i = AllocPortNum(num >= 0 ? num : 0);

    if (i < 0)
      goto err;

    if (num >= 0 && num != i) {
      res = ShowMsg(MB_CANCELTRYCONTINUE|MB_ICONWARNING,
                    "The identifiers " C0C_PREF_PORT_NAME_A "%d and "
                    C0C_PREF_PORT_NAME_B "%d are already used for other ports\n"
                    "so ports with identifiers " C0C_PREF_PORT_NAME_A "%d and "
                    C0C_PREF_PORT_NAME_B "%d will be installed instead.\n",
                    num, num, i, i);
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    goto err;

  if (!IsValidPortNum(i))
    goto err;

  char portName[2][20];

  for (int j = 0 ; j < 2 ; j++) {
    char phPortName[20];
    const char *pParameters;

    pParameters = j ? pParametersB : pParametersA;

    SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s%d",
             j ? C0C_PREF_PORT_NAME_B : C0C_PREF_PORT_NAME_A, i);

    PortParameters portParameters(C0C_SERVICE, phPortName);

    LONG err = portParameters.Load();

    if (err == ERROR_SUCCESS) {
      if (!portParameters.ParseParametersStr(pParameters))
        goto err;

      portParameters.FillPortName(portName[j], sizeof(portName[j])/sizeof(portName[j][0]));

      if (!IsValidPortName(portName[j]))
        goto err;

      portParameters.InitRealPortName();   // ignore RealPortName param

      if (portParameters.Changed()) {
        err = portParameters.Save();

        if (err != ERROR_SUCCESS)
          ShowError(MB_OK|MB_ICONWARNING, err, "portParameters.Save(%s)", phPortName);
      }
    } else {
      ShowError(MB_OK|MB_ICONWARNING, err, "portParameters.Load(%s)", phPortName);
      SNPRINTF(portName[j], sizeof(portName[j])/sizeof(portName[j][0]), "%s", phPortName);
    }

    char buf[200];

    portParameters.FillParametersStr(buf, sizeof(buf)/sizeof(buf[0]), detailPrms);

    Trace("       %s %s\n", phPortName, buf);
  }

  if (lstrcmpi(portName[0], portName[1]) == 0 && !IsComClass(portName[0]) &&
      ShowMsg(MB_OKCANCEL|MB_ICONWARNING,
              "The same port name %s is used for both ports.\n",
              portName[0]) != IDOK)
  {
    goto err;
  }

  if (!InstallBusDevice(pInfFilePath, i))
    goto err;

  ComDbSync(EnumFilter);

  return TRUE;

err:

  Trace("\nInstall not completed!\n");

  return FALSE;
}
///////////////////////////////////////////////////////////////
bool Uninstall(
    const InfFileInstall *pInfFileInstallList,
    const InfFile::InfFileUninstall *pInfFileUninstallList)
{
  BOOL rebootRequired = FALSE;
  DevProperties devProperties;

  devProperties = DevProperties();
  if (!devProperties.DevId(C0C_PORT_DEVICE_ID))
    goto err;

  {
    Stack stack;

    if (!DisableDevices(EnumFilter, &devProperties, &rebootRequired, &stack)) {
      CleanDevPropertiesStack(stack, TRUE, &rebootRequired);
      goto err;
    }

    CleanDevPropertiesStack(stack, FALSE, &rebootRequired);
  }

  devProperties = DevProperties();
  if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
    goto err;

  if (!RemoveDevices(EnumFilter, &devProperties, &rebootRequired))
    goto err;

  if (!RemoveDevices(EnumFilter, NULL, NULL))
    goto err;

  ComDbSync(EnumFilter);

  if (rebootRequired) {
    PromptReboot();
    goto err;
  }

  int res;
  bool notDeleted;
  LONG err;

  do {
    notDeleted = TRUE;
    res = IDCONTINUE;

    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM) {
      do {
        res = IDCONTINUE;

        SC_HANDLE hSrv = OpenService(hSCM, C0C_SERVICE, DELETE|SERVICE_QUERY_STATUS);

        if (hSrv) {
          SERVICE_STATUS srvStatus;

          if (QueryServiceStatus(hSrv, &srvStatus)) {
            if (srvStatus.dwCurrentState == SERVICE_STOPPED) {
              if (Silent() ||
                  ShowMsg(MB_YESNO,
                  "The deleting %s service will remove your manual settings.\n"
                  "Would you like to delete service?\n",
                  C0C_SERVICE) == IDYES)
              {
                if (DeleteService(hSrv)) {
                  Trace("Deleted Service %s\n", C0C_SERVICE);
                  notDeleted = FALSE;
                } else {
                  res = ShowLastError(MB_CANCELTRYCONTINUE, "DeleteService(%s)", C0C_SERVICE);
                }
              }
            } else {
              res = ShowMsg(MB_CANCELTRYCONTINUE,
                            "Service %s is not stopped (state %ld).\n",
                            C0C_SERVICE, (long)srvStatus.dwCurrentState);
            }
          } else {
            res = ShowLastError(MB_CANCELTRYCONTINUE, "QueryServiceStatus(%s)", C0C_SERVICE);
          }

          if (!CloseServiceHandle(hSrv))
            ShowLastError(MB_OK|MB_ICONWARNING, "CloseServiceHandle(hSrv)");
        } else {
          if (GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) {
            Trace("Service %s not installed\n", C0C_SERVICE);
            notDeleted = FALSE;
          } else {
            res = ShowLastError(MB_CANCELTRYCONTINUE, "OpenService(%s)", C0C_SERVICE);
          }
        }
      } while (res == IDTRYAGAIN);

      if (!CloseServiceHandle(hSCM))
        ShowLastError(MB_OK|MB_ICONWARNING, "CloseServiceHandle(hSCM)");
    } else {
      res = ShowLastError(MB_CANCELTRYCONTINUE, "OpenSCManager()");
    }
  } while (res == IDTRYAGAIN);

  if (notDeleted)
    Trace("WARNING: Service %s not deleted\n", C0C_SERVICE);

  if (res != IDCONTINUE)
    goto err;

  do {
    notDeleted = TRUE;
    res = IDCONTINUE;

    err = RegDeleteKey(HKEY_LOCAL_MACHINE, C0C_REGKEY_EVENTLOG);

    if (err == ERROR_SUCCESS) {
      Trace("Deleted EventLog %s\n", C0C_SERVICE);
      notDeleted = FALSE;
    }
    else
    if (err == ERROR_FILE_NOT_FOUND) {
      Trace("EventLog %s not installed\n", C0C_SERVICE);
      notDeleted = FALSE;
    }
    else {
      res = ShowError(MB_CANCELTRYCONTINUE, err, "RegDeleteKey(%s)", C0C_REGKEY_EVENTLOG);
    }
  } while (res == IDTRYAGAIN);

  if (notDeleted)
    Trace("WARNING: Key %s not deleted\n", C0C_REGKEY_EVENTLOG);

  if (res != IDCONTINUE)
    goto err;

  do {
    notDeleted = TRUE;
    res = IDCONTINUE;

    HKEY hKey = SetupDiOpenClassRegKey(NULL, DELETE);

    if (hKey != INVALID_HANDLE_VALUE) {
      do {
        res = IDCONTINUE;

        err = RegDeleteKey(hKey, C0C_CNCCLASS_GUID);

        if (err != ERROR_SUCCESS) {
          HKEY hClassGuidKey;
          err = RegOpenKeyEx(hKey, C0C_CNCCLASS_GUID, 0, KEY_READ, &hClassGuidKey);

          if (err == ERROR_SUCCESS) {
            for (;;) {
              char subKey[MAX_PATH + 1];
              DWORD subKeySize = sizeof(subKey)/sizeof(subKey[0]);

              err = RegEnumKeyEx(hClassGuidKey, 0, subKey, &subKeySize, NULL, NULL, NULL, NULL);

              if (err != ERROR_SUCCESS)
                break;

              err = RegDeleteKey(hClassGuidKey, subKey);

              if (err == ERROR_SUCCESS)
                Trace("Deleted Class subkey %s\\%s\n", C0C_CNCCLASS_GUID, subKey);
              else
              if (err != ERROR_FILE_NOT_FOUND) {
                ShowError(MB_OK|MB_ICONWARNING, err, "RegDeleteKey(%s\\%s)", C0C_CNCCLASS_GUID, subKey);
                break;
              }
            }

            err = RegCloseKey(hClassGuidKey);

            if (err != ERROR_SUCCESS)
              ShowError(MB_OK|MB_ICONWARNING, err, "RegCloseKey()");
          }

          err = RegDeleteKey(hKey, C0C_CNCCLASS_GUID);
        }

        if (err == ERROR_SUCCESS) {
          Trace("Deleted Class %s\n", C0C_CNCCLASS_GUID);
          notDeleted = FALSE;
        }
        else
        if (err == ERROR_FILE_NOT_FOUND) {
          Trace("Class %s not installed\n", C0C_CNCCLASS_GUID);
          notDeleted = FALSE;
        }
        else {
          res = ShowError(MB_CANCELTRYCONTINUE, err, "RegDeleteKey(%s)", C0C_CNCCLASS_GUID);
        }
      } while (res == IDTRYAGAIN);

      err = RegCloseKey(hKey);

      if (err != ERROR_SUCCESS)
        ShowError(MB_OK|MB_ICONWARNING, err, "RegCloseKey()");
    } else {
      res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupDiOpenClassRegKey(NULL)");
    }
  } while (res == IDTRYAGAIN);

  if (notDeleted)
    Trace("WARNING: Class %s not deleted\n", C0C_CNCCLASS_GUID);

  if (res != IDCONTINUE)
    goto err;

  for (
      const InfFileInstall *pInfFileInstall = pInfFileInstallList ;
      pInfFileInstall->pInfName != NULL ;
      pInfFileInstall++)
  {
    InfFile infFile(pInfFileInstall->pInfName, pInfFileInstall->pInfName);

    if (!infFile.UninstallOEMInf())
      goto err;

    if (pInfFileInstall->pCopyDriversSection != NULL) {
      if (!infFile.UninstallFiles(pInfFileInstall->pCopyDriversSection))
        goto err;
    }
  }

  if (!InfFile::UninstallAllInfFiles(pInfFileUninstallList, NULL))
    goto err;

  return TRUE;

err:

  Trace("\nUninstall not completed!\n");

  return FALSE;
}
///////////////////////////////////////////////////////////////
bool InfClean(
    const InfFileInstall *pInfFileInstallList,
    const InfFile::InfFileUninstall *pInfFileUninstallList)
{
  bool ok = TRUE;
  InfFile **pInfFiles = NULL;
  const char **ppOemPathExcludeList = NULL;
  int numInfFiles = 0;

  for (
      const InfFileInstall *pInfFileInstall = pInfFileInstallList ;
      pInfFileInstall->pInfName != NULL ;
      pInfFileInstall++)
  {
    InfFile *pInfFile = new InfFile(pInfFileInstall->pInfName, pInfFileInstall->pInfName);

    if (pInfFile->OemPath() == NULL) {
      delete pInfFile;
      continue;
    }

    InfFile **pNewInfFiles;

    if (!pInfFiles)
      pNewInfFiles = (InfFile **)LocalAlloc(LPTR, (numInfFiles + 1) * sizeof(InfFile *));
    else
      pNewInfFiles = (InfFile **)LocalReAlloc(pInfFiles, (numInfFiles + 1) * sizeof(InfFile *), LMEM_ZEROINIT|LMEM_MOVEABLE);

    if (!pNewInfFiles) {
      ShowError(MB_OK|MB_ICONSTOP, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (numInfFiles + 1) * sizeof(InfFile *));
      ok = FALSE;
      goto end;
    }

    pInfFiles = pNewInfFiles;
    pInfFiles[numInfFiles++] = pInfFile;
  }

  if (pInfFiles != NULL) {
    ppOemPathExcludeList = (const char **)LocalAlloc(LPTR, (numInfFiles + 1) * sizeof(const char *));

    if (!ppOemPathExcludeList) {
      ShowError(MB_OK|MB_ICONSTOP, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (numInfFiles + 1) * sizeof(const char *));
      ok = FALSE;
      goto end;
    }

    for (int i = 0 ; i < numInfFiles ; i++)
      ppOemPathExcludeList[i] = pInfFiles[i]->OemPath();
  }


  if (!InfFile::UninstallAllInfFiles(pInfFileUninstallList, ppOemPathExcludeList)) {
    ok = FALSE;
    goto end;
  }

end:

  if (ppOemPathExcludeList != NULL)
    LocalFree((HLOCAL)ppOemPathExcludeList);

  if (pInfFiles != NULL) {
    for (int i = 0 ; i < numInfFiles ; i++) {
      delete pInfFiles[i];
    }

    LocalFree((HLOCAL)pInfFiles);
  }

  if (!ok)
    Trace("\nCleaning not completed!\n");

  return ok;
}
///////////////////////////////////////////////////////////////
bool ShowBusyNames(const char *pPattern)
{
  char *pPatternUp;

  pPatternUp = STRDUP(pPattern);

  if (!pPatternUp)
    return FALSE;

  CharUpper(pPatternUp);

  char *pNames = NULL;
  DWORD iNamesEnd = 0;

  for (int i = 0 ; i < 2 ; i++) {
    char *pBuf = NULL;

    for (DWORD size = 1024 ; size >= 1024 ; size += 1024) {
      char *pBufNew;

      if (!pBuf)
        pBufNew = (char *)LocalAlloc(LPTR, size);
      else
        pBufNew = (char *)LocalReAlloc(pBuf, size, LMEM_ZEROINIT|LMEM_MOVEABLE);

      if (!pBufNew) {
        if (pBuf) {
          LocalFree(pBuf);
          pBuf = NULL;
        }

        if (ShowError(MB_OKCANCEL, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (unsigned long)size) != IDOK) {
          if (pNames)
            LocalFree(pNames);

          LocalFree(pPatternUp);
          return FALSE;
        }

        break;
      }

      pBuf = pBufNew;

      DWORD res = (i != 0
                   ? QueryDosDevice(NULL, pBuf, size/sizeof(pBuf[0]))
                   : ComDbQueryNames(pBuf, size/sizeof(pBuf[0])));

      if (!res) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
          continue;

        LocalFree(pBuf);
        pBuf = NULL;

        if (GetLastError() == ERROR_FILE_NOT_FOUND)
          break;

        if (ShowLastError(MB_OKCANCEL,
            i != 0 ? "QueryDosDevice()" : "ComDbNames()") != IDOK)
        {
          if (pNames)
            LocalFree(pNames);

          LocalFree(pPatternUp);
          return FALSE;
        }

        break;
      }

      // Workaround for succeeds even if buffer cannot hold all returned information

      if ((size/sizeof(pBuf[0]) - res) > 100)
        break;
    }

    if (pBuf) {
      for (char *pName = pBuf ; *pName ; pName += lstrlen(pName) + 1) {
        static const char strangeChars[] = ":#&$?!{}()[]/\\ \t\r\n";

        if (strpbrk(pName, strangeChars))
          continue;  // skip strange names

        CharUpper(pName);

        if (!MatchPattern(pPatternUp, pName))
          continue;

        if (pNames) {
          char *pNamesName;

          for (pNamesName = pNames ; *pNamesName ; pNamesName += lstrlen(pNamesName) + 1) {
            if (!lstrcmp(pNamesName, pName))
              break;
          }

          if (*pNamesName)
            continue;
        }

        DWORD iNamesEndNew = iNamesEnd + lstrlen(pName) + 1;
        DWORD sizeNamesNew = (iNamesEndNew + 1) * sizeof(pNames[0]);

        char *pNamesNew;

        if (!pNames)
          pNamesNew = (char *)LocalAlloc(LPTR, sizeNamesNew);
        else
          pNamesNew = (char *)LocalReAlloc(pNames, sizeNamesNew, LMEM_ZEROINIT|LMEM_MOVEABLE);

        if (!pNamesNew) {
          if (ShowError(MB_OKCANCEL, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (unsigned long)sizeNamesNew) != IDOK) {
            if (pNames)
              LocalFree(pNames);

            LocalFree(pPatternUp);
            return FALSE;
          }

          break;
        }

        pNames = pNamesNew;

        lstrcpy(pNames + iNamesEnd, pName);

        iNamesEnd = iNamesEndNew;
      }

      LocalFree(pBuf);
    }
  }

  if (pNames) {
    for (char *pName = pNames ; *pName ; pName += lstrlen(pName) + 1)
      Trace("%s\n", pName);

    LocalFree(pNames);
  }

  LocalFree(pPatternUp);

  return TRUE;
}
///////////////////////////////////////////////////////////////
void Help(const char *pProgName)
{
  SetTitle(C0C_SETUP_TITLE " (HELP)");

  ConsoleWrite(
    C0C_SETUP_TITLE "\n"
    "\n");
  ConsoleWrite(
    "Usage:\n"
    "  %s%s[options] <command>\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "\n"
    "Options:\n"
    "  --output <file>              - file for output, default is console\n"
    "  --wait [+]<to>               - wait <to> seconds for install completion. If\n"
    "                                 <to> has '+' prefix then ask user to continue\n"
    "                                 waiting after <to> seconds elapsing\n"
    "                                 (by default <to> is 0 - no wait)\n"
    "  --detail-prms                - show detailed parameters\n"
    "  --silent                     - suppress dialogs if possible\n"
    "  --no-update                  - do not update driver while install command\n"
    "                                 execution (the other install command w/o this\n"
    "                                 option expected later)\n"
    "  --no-update-fnames           - do not update friendly names\n"
    "  --show-fnames                - show friendly names activity\n"
    );
  ConsoleWrite(
    "\n"
    "Commands:\n"
    "  install <n> <prmsA> <prmsB>  - install a pair of linked ports with\n"
    "   or                            identifiers " C0C_PREF_PORT_NAME_A "<n> and "
                                      C0C_PREF_PORT_NAME_B "<n>\n"
    "  install <prmsA> <prmsB>        (by default <n> is the first not used number),\n"
    "                                 set their parameters to <prmsA> and <prmsB>\n"
    "  install                      - can be used to update driver after execution\n"
    "                                 of install commands with --no-update option\n"
    "  remove <n>                   - remove a pair of linked ports with\n"
    "                                 identifiers " C0C_PREF_PORT_NAME_A "<n> and "
                                      C0C_PREF_PORT_NAME_B "<n>\n"
    "  disable all                  - disable all ports in current hardware profile\n"
    "  enable all                   - enable all ports in current hardware profile\n"
    );
  ConsoleWrite(
    "  change <portid> <prms>       - set parameters <prms> for port with\n"
    "                                 identifier <portid>\n"
    "  list                         - for each port show its identifier and\n"
    "                                 parameters\n"
    "  preinstall                   - preinstall driver\n"
    "  update                       - update driver\n"
    "  reload                       - reload driver\n"
    "  uninstall                    - uninstall all ports and the driver\n"
    "  infclean                     - clean old INF files\n"
    "  busynames <pattern>          - show names that already in use and match the\n"
    "                                 <pattern> (wildcards: '*' and '?')\n"
    "  updatefnames                 - update friendly names\n"
    "  listfnames                   - for each bus and port show its identifier and\n"
    "                                 friendly name\n"
    );
  ConsoleWrite(
    "  quit                         - quit\n"
    "  help                         - print this help\n"
    );
  ConsoleWrite(
    "\n");

  const char *pStr = PortParameters::GetHelp();

  while (*pStr) {
    char buf[100];

    SNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), "%s", pStr);
    pStr += lstrlen(buf);

    ConsoleWrite("%s", buf);
  }

  ConsoleWrite(
    "\n"
    "If parameter 'PortName=" C0C_PORT_NAME_COMCLASS "' is used then the Ports class installer will be\n"
    "invoked to set the real port name. The Ports class installer selects the COM\n"
    "port number and sets the real port name to COM<n>, where <n> is the selected\n"
    "port number. Thereafter use parameter RealPortName=COM<n> to change the real\n"
    "port name.\n"
    );

  ConsoleWrite(
    "\n"
    "Examples:\n"
    );
  ConsoleWrite(
    "  %s%sinstall - -\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%sinstall 5 * *\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%sremove 0\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%sinstall PortName=COM2 PortName=COM4\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%sinstall PortName=COM5,EmuBR=yes,EmuOverrun=yes -\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%schange " C0C_PREF_PORT_NAME_A "0 EmuBR=yes,EmuOverrun=yes\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%schange " C0C_PREF_PORT_NAME_A "0 PortName=-\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%slist\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%suninstall\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "  %s%sbusynames COM?*\n"
    , pProgName, (pProgName && *pProgName) ? " " : "");
  ConsoleWrite(
    "\n");
}
///////////////////////////////////////////////////////////////
static int Complete(bool ok)
{
  if (ok) {
    if (timeout > 0)
      WaitNoPendingInstallEvents(timeout, repeate_timeout);

    return 0;
  }

  return 1;
}

int Main(int argc, const char* argv[])
{
  if (!SetOutputFile(NULL))
    return 1;

  Silent(FALSE);
  timeout = 0;
  repeate_timeout = FALSE;
  detailPrms = FALSE;
  no_update = FALSE;
  no_update_fnames = FALSE;
  show_fnames = FALSE;

  while (argc > 1) {
    if (*argv[1] != '-')
      break;

    if (!strcmp(argv[1], "--output") && argc > 2) {
      if (!SetOutputFile(argv[2]))
        return 1;
      argv[2] = argv[0];
      argv += 2;
      argc -= 2;
    }
    else
    if (!strcmp(argv[1], "--wait") && argc > 2) {
      int num;

      if (!StrToInt(argv[2], &num) || num < 0) {
        ConsoleWrite("Invalid option %s %s\n", argv[1], argv[2]);
        return 1;
      }

      timeout = num;

      if (argv[2][0] == '+')
        repeate_timeout = TRUE;

      argv[2] = argv[0];
      argv += 2;
      argc -= 2;
    }
    else
    if (!strcmp(argv[1], "--detail-prms")) {
      detailPrms = TRUE;
      argv[1] = argv[0];
      argv++;
      argc--;
    }
    else
    if (!strcmp(argv[1], "--silent")) {
      Silent(TRUE);
      argv[1] = argv[0];
      argv++;
      argc--;
    }
    else
    if (!strcmp(argv[1], "--no-update")) {
      no_update = TRUE;
      argv[1] = argv[0];
      argv++;
      argc--;
    }
    else
    if (!strcmp(argv[1], "--no-update-fnames")) {
      no_update_fnames = TRUE;
      argv[1] = argv[0];
      argv++;
      argc--;
    }
    else
    if (!strcmp(argv[1], "--show-fnames")) {
      show_fnames = TRUE;
      argv[1] = argv[0];
      argv++;
      argc--;
    }
    else {
      ConsoleWrite("Invalid option %s\n", argv[1]);
      return 1;
    }
  }

  if (argc == 1) {
    return Complete(TRUE);
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "help")) {
    Help(argv[0]);
    return Complete(TRUE);
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "quit")) {
    return Complete(TRUE);
  }
  else
  if (argc == 3 && !lstrcmpi(argv[1], "busynames")) {
    SetTitle(C0C_SETUP_TITLE " (BUSY NAMES)");
    return Complete(ShowBusyNames(argv[2]));
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "list")) {
    SetTitle(C0C_SETUP_TITLE " (LIST)");
    return Complete(Change(NULL, NULL));
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "updatefnames")) {
    SetTitle(C0C_SETUP_TITLE " (UPDATE FRIENDLY NAMES)");
    return Complete(UpdateFriendlyNames(TRUE));
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "listfnames")) {
    SetTitle(C0C_SETUP_TITLE " (LIST FRIENDLY NAMES)");
    return Complete(UpdateFriendlyNames(FALSE));
  }
  else
  if (argc == 4 && !lstrcmpi(argv[1], "change")) {
    SetTitle(C0C_SETUP_TITLE " (CHANGE)");
    return Complete(Change(argv[2], argv[3]));
  }
  else
  if (argc == 3 && !lstrcmpi(argv[1], "remove")) {
    SetTitle(C0C_SETUP_TITLE " (REMOVE)");

    int num;

    if (StrToInt(argv[2], &num) && num >= 0)
      return Complete(Remove(num));
  }
  else
  if (argc == 3 && !lstrcmpi(argv[1], "disable")) {
    SetTitle(C0C_SETUP_TITLE " (DISABLE)");

    if (!lstrcmpi(argv[2], "all"))
      return Complete(Disable());
  }
  else
  if (argc == 3 && !lstrcmpi(argv[1], "enable")) {
    SetTitle(C0C_SETUP_TITLE " (ENABLE)");

    if (!lstrcmpi(argv[2], "all"))
      return Complete(Enable());
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "reload")) {
    SetTitle(C0C_SETUP_TITLE " (RELOAD)");
    return Complete(Reload(C0C_BUS_DEVICE_ID, NULL, NULL));
  }

  for (
      const InfFileInstall *pInfFileInstall = infFileInstallList ;
      pInfFileInstall->pInfName != NULL ;
      pInfFileInstall++)
  {
    InfFile infFile(pInfFileInstall->pInfName, pInfFileInstall->pInfName);
    if (!infFile.Test(pInfFileInstall->pRequiredFields))
      return 1;
  }

  if (argc == 2 && !lstrcmpi(argv[1], "preinstall")) {
    SetTitle(C0C_SETUP_TITLE " (PREINSTALL)");
    return Complete(Preinstall(infFileInstallList));
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "uninstall")) {
    SetTitle(C0C_SETUP_TITLE " (UNINSTALL)");
    return Complete(Uninstall(infFileInstallList, infFileUnnstallList));
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "infclean")) {
    SetTitle(C0C_SETUP_TITLE " (INF CLEAN)");
    return Complete(InfClean(infFileInstallList, infFileUnnstallList));
  }
  else
  if (argc == 2 && !lstrcmpi(argv[1], "update")) {
    SetTitle(C0C_SETUP_TITLE " (UPDATE)");
    return Complete(Update(infFileInstallList));
  }

  InfFile infFile(C0C_INF_NAME, C0C_INF_NAME);

  const char *pPath = infFile.Path();

  if (!pPath)
    return 1;

  if (argc == 2 && !lstrcmpi(argv[1], "install")) {
    SetTitle(C0C_SETUP_TITLE " (INSTALL)");
    return Complete(Install(pPath));
  }
  else
  if (argc == 4 && !lstrcmpi(argv[1], "install")) {
    SetTitle(C0C_SETUP_TITLE " (INSTALL)");
    return Complete(Install(pPath, argv[2], argv[3], -1));
  }
  else
  if (argc == 5 && !lstrcmpi(argv[1], "install")) {
    SetTitle(C0C_SETUP_TITLE " (INSTALL)");

    int num;

    if (StrToInt(argv[2], &num) && num >= 0)
      return Complete(Install(pPath, argv[3], argv[4], num));
  }

  ConsoleWrite("Invalid command\n");

  return 1;
}
///////////////////////////////////////////////////////////////
static int ParseCmd(char *pCmd, const char* argv[], int sizeArgv)
{
  int argc;

  argc = 0;

  char *pSave;

  for (char *pArg = STRTOK_R(pCmd, " \t\r\n", &pSave) ; pArg ; pArg = STRTOK_R(NULL, " \t\r\n", &pSave)) {
    if ((argc + 2) > sizeArgv)
      break;

    if (*pArg == '"')
      pArg++;

    char *pEnd = pArg + lstrlen(pArg);

    if (pEnd-- != pArg && *pEnd == '"')
      *pEnd = 0;

    argv[argc++] = pArg;
  }

  argv[argc] = NULL;

  return argc;
}
///////////////////////////////////////////////////////////////
int CALLBACK MainA(const char *pProgName, const char *pCmdLine)
{
  SetTitle(C0C_SETUP_TITLE);

  char cmd[1024];

  SNPRINTF(cmd, sizeof(cmd)/sizeof(cmd[0]), "%s", pCmdLine);

  int argc;
  const char* argv[10];

  argc = ParseCmd(cmd, argv + 1, sizeof(argv)/sizeof(argv[0]) - 1) + 1;

  if (argc == 1) {
    ConsoleWrite("Enter 'help' to get info about usage of " C0C_SETUP_TITLE ".\n\n");

    argv[0] = "";

    for (;;) {
      argv[1] = NULL;

      ConsoleWriteRead(cmd, sizeof(cmd)/sizeof(cmd[0]), "command> ");

      argc = ParseCmd(cmd, argv + 1, sizeof(argv)/sizeof(argv[0]) - 1) + 1;

      if (argc == 2 && !lstrcmpi(argv[1], "quit"))
        return 0;

      Main(argc, argv);
    }
  }

  argv[0] = pProgName;

  return Main(argc, argv);
}
///////////////////////////////////////////////////////////////
int CALLBACK RunDllA(HWND /*hWnd*/, HINSTANCE /*hInst*/, LPSTR pCmdLine, int /*nCmdShow*/)
{
  int res = MainA("rundll32 setup,RunDll", pCmdLine);

  if (!GetOutputFile()) {
    char buf[10];

    ConsoleWriteRead(buf, sizeof(buf)/sizeof(buf[0]), "\nPress <RETURN> to continue\n");
  }

  return res;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/setup.rc

/*
 * $Id: setup.rc,v 1.1 2006/07/28 12:16:43 vfrolov Exp $
 *
 * Copyright (c) 2006 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: setup.rc,v $
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 *
 */

#include <windows.h>
#include "..\sys\version.h"

#define VER_FILEVERSION             C0C_V1,C0C_V2,C0C_V3,C0C_V4
#define VER_PRODUCTVERSION_STR      C0C_VERSION_STR
#define VER_LEGALCOPYRIGHT_YEARS    C0C_COPYRIGHT_YEARS

#define VER_COMPANYNAME_STR         "Vyacheslav Frolov\0"
#define VER_LEGALCOPYRIGHT_STR      "Copyright (c) " VER_LEGALCOPYRIGHT_YEARS " " VER_COMPANYNAME_STR
#define VER_PRODUCTNAME_STR         "Setup for com0com"
#ifdef DBG
  #define VER_DEBUG_STR             " (debug version)"
  #define VER_FILEFLAGS             VS_FF_DEBUG
#else
  #define VER_DEBUG_STR             ""
  #define VER_FILEFLAGS             0
#endif
#define VER_FILEDESCRIPTION_STR     VER_PRODUCTNAME_STR VER_DEBUG_STR
#define VER_INTERNALNAME_STR        "setup\0"
#define VER_ORIGINALFILENAME_STR    "setup.dll\0"
#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             0

#include <common.ver>


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/comdb.cpp

/*
 * $Id: comdb.cpp,v 1.5 2011/12/29 14:34:23 vfrolov Exp $
 *
 * Copyright (c) 2008-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: comdb.cpp,v $
 * Revision 1.5  2011/12/29 14:34:23  vfrolov
 * Implemented RealPortName=COM<n> for PortName=COM#
 *
 * Revision 1.4  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.3  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.2  2008/12/25 16:57:33  vfrolov
 * Added ComDbQueryNames()
 *
 * Revision 1.1  2008/12/24 15:20:35  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "params.h"
#include "devutils.h"
#include "msg.h"
#include "utils.h"
#include "portnum.h"
#include "comdb.h"
#include <msports.h>

#define TEXT_PREF
#include "../include/com0com.h"
///////////////////////////////////////////////////////////////
static const char comDbLocalKey[] = REGSTR_PATH_SERVICES "\\" C0C_SERVICE "\\COM Name Arbiter";
static const char comDbLocalName[] = "ComDB";
///////////////////////////////////////////////////////////////
static WORD name2num(const char *pPortName)
{
  int num;

  if ((pPortName[0] != 'C' && pPortName[0] != 'c') ||
      (pPortName[1] != 'O' && pPortName[1] != 'o') ||
      (pPortName[2] != 'M' && pPortName[2] != 'm') ||
      pPortName[3] == '0' ||
      !StrToInt(pPortName + 3, &num) ||
      num <= 0 ||
      num > COMDB_MAX_PORTS_ARBITRATED)
  {
    return 0;
  }

  return (WORD)num;
}
///////////////////////////////////////////////////////////////
static bool LoadComDb(BusyMask &comDb)
{
  comDb.Clear();

  int res;

  do {
    res = IDCONTINUE;

    HCOMDB  hComDB;
    LONG err;

    err = ComDBOpen(&hComDB);

    if (err != ERROR_SUCCESS) {
      res = ShowLastError(MB_CANCELTRYCONTINUE, "ComDBOpen()");
      continue;
    }

    DWORD maxPortsReported;

    err = ComDBGetCurrentPortUsage(hComDB, NULL, 0, CDB_REPORT_BITS, &maxPortsReported);

    if (err != ERROR_SUCCESS) {
      ComDBClose(hComDB);
      res = ShowError(MB_CANCELTRYCONTINUE, err, "ComDBGetCurrentPortUsage()");
      continue;
    }

    DWORD bufSize = (maxPortsReported + 7)/8;
    BYTE *pBuf = (BYTE *)LocalAlloc(LPTR, bufSize);

    if (!pBuf) {
      ComDBClose(hComDB);

      res = ShowError(MB_CANCELTRYCONTINUE, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (unsigned long)bufSize);
      continue;
    }

    err = ComDBGetCurrentPortUsage(hComDB, pBuf, bufSize, CDB_REPORT_BITS, &maxPortsReported);
    ComDBClose(hComDB);

    if (err != ERROR_SUCCESS) {
      LocalFree(pBuf);
      res = ShowError(MB_CANCELTRYCONTINUE, err, "ComDBGetCurrentPortUsage()");
      continue;
    }

    for (DWORD num = 0 ; num < maxPortsReported ; num++) {
      if (((pBuf[num/8] >> (num%8)) & 1) != 0)
        comDb.AddNum(num);
    }

    LocalFree(pBuf);

  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE) {
    SetLastError(ERROR_CANCELLED);
    return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool ClaimReleasePort(DWORD num, bool claim)
{
  if (num == 0) {
    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
  }

  int res;

  do {
    res = IDCONTINUE;

    HCOMDB  hComDB;
    LONG err;

    err = ComDBOpen(&hComDB);

    if (err != ERROR_SUCCESS) {
      res = ShowLastError(MB_RETRYCANCEL, "ComDBOpen()");
      continue;
    }

    if (claim) {
      err = ComDBClaimPort(hComDB, num, FALSE, NULL);

      if (err != ERROR_SUCCESS) {
        ComDBClose(hComDB);

        if (err == ERROR_SHARING_VIOLATION)
          res = IDCANCEL;
        else
          res = ShowError(MB_RETRYCANCEL, err, "ComDBClaimPort(COM%u)", (unsigned)num);

        continue;
      } else {
        Trace("ComDB: COM%u - logged as \"in use\"\n", unsigned(num));
      }
    } else {
      err = ComDBReleasePort(hComDB, num);

      if (err != ERROR_SUCCESS) {
        ComDBClose(hComDB);

        res = ShowError(MB_RETRYCANCEL, err, "ComDBReleasePort(COM%u)", (unsigned)num);
        continue;
      } else {
        Trace("ComDB: COM%u - released\n", unsigned(num));
      }
    }

    ComDBClose(hComDB);
  } while (res == IDRETRY);

  if (res != IDCONTINUE) {
    SetLastError(ERROR_CANCELLED);
    return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool LoadComDbLocal(BusyMask &comDb)
{
  comDb.Clear();

  int res;

  do {
    res = IDCONTINUE;

    LONG err;
    HKEY hKey;

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       comDbLocalKey,
                       0,
                       KEY_READ,
                       &hKey);

    if (err != ERROR_SUCCESS) {
      if (err != ERROR_FILE_NOT_FOUND)
        res = ShowError(MB_CANCELTRYCONTINUE, err, "RegOpenKeyEx(%s)", comDbLocalKey);

      continue;
    }

    DWORD bufSize = 1;

    err = RegQueryValueEx(hKey,
                          comDbLocalName,
                          NULL,
                          NULL,
                          NULL,
                          &bufSize);

    if (err != ERROR_SUCCESS) {
      RegCloseKey(hKey);

      if (err != ERROR_FILE_NOT_FOUND)
        res = ShowError(MB_CANCELTRYCONTINUE, err, "RegQueryValueEx(%s\\%s)", comDbLocalKey, comDbLocalName);

      continue;
    }

    BYTE *pBuf = (BYTE *)LocalAlloc(LPTR, bufSize);

    if (!pBuf) {
      RegCloseKey(hKey);

      res = ShowError(MB_CANCELTRYCONTINUE, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (unsigned long)bufSize);
      continue;
    }

    err = RegQueryValueEx(hKey,
                          comDbLocalName,
                          NULL,
                          NULL,
                          pBuf,
                          &bufSize);

    RegCloseKey(hKey);

    if (err != ERROR_SUCCESS) {
      LocalFree(pBuf);

      if (err != ERROR_FILE_NOT_FOUND)
        res = ShowError(MB_CANCELTRYCONTINUE, err, "RegQueryValueEx(%s\\%s)", comDbLocalKey, comDbLocalName);

      continue;
    }

    DWORD maxPortsReported = bufSize*8;

    for (DWORD num = 0 ; num < maxPortsReported ; num++) {
      if (((pBuf[num/8] >> (num%8)) & 1) != 0)
        comDb.AddNum(num);
    }

    LocalFree(pBuf);

  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE) {
    SetLastError(ERROR_CANCELLED);
    return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
static CNC_DEV_CALLBACK AddComNames;
static bool AddComNames(
    HDEVINFO hDevInfo,
    PSP_DEVINFO_DATA pDevInfoData,
    PCDevProperties /*pDevProperties*/,
    BOOL * /*pRebootRequired*/,
    void *pParam)
{
  int i = GetPortNum(hDevInfo, pDevInfoData);

  if (i < 0)
    return TRUE;

  for (int j = 0 ; j < 2 ; j++) {
    char phPortName[20];

    SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s%d",
             j ? C0C_PREF_PORT_NAME_B : C0C_PREF_PORT_NAME_A, i);

    PortParameters portParameters(C0C_SERVICE, phPortName);

    if (portParameters.Load() != ERROR_SUCCESS)
      return FALSE;

    char portName[20];

    portParameters.FillPortName(portName, sizeof(portName)/sizeof(portName[0]));

    WORD num = name2num(portName);

    if (num > 0)
      ((BusyMask *)pParam)->AddNum(num - 1);
  }

  return TRUE;
}

static bool LoadComNames(PCNC_ENUM_FILTER pFilter, BusyMask &comDb)
{
  comDb.Clear();

  DevProperties devProperties;

  if (!devProperties.DevId(C0C_BUS_DEVICE_ID))
    return FALSE;

  if (EnumDevices(pFilter, &devProperties, NULL, AddComNames, &comDb) < 0)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool SaveComDbLocal(const BusyMask &comDb)
{
  int res;

  do {
    res = IDCONTINUE;

    LONG err;
    HKEY hKey;

    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         comDbLocalKey,
                         0,
                         NULL,
                         0,
                         KEY_WRITE,
                         NULL,
                         &hKey,
                         NULL);

    if (err != ERROR_SUCCESS) {
      res = ShowError(MB_CANCELTRYCONTINUE, err, "RegCreateKeyEx(%s)", comDbLocalKey);
      continue;
    }

    DWORD maxPortsReported = 0;

    for (DWORD num = 0 ; num < COMDB_MAX_PORTS_ARBITRATED ; num++) {
      if (!comDb.IsFreeNum(num))
        maxPortsReported = num + 1;
    }

    if (!maxPortsReported) {
      err = RegDeleteValue(hKey, comDbLocalName);

      RegCloseKey(hKey);

      if (err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND)
        res = ShowError(MB_CANCELTRYCONTINUE, err, "RegDeleteValue(%s\\%s)", comDbLocalKey, comDbLocalName);

      continue;
    }

    DWORD bufSize = (maxPortsReported + 7)/8;
    BYTE *pBuf = (BYTE *)LocalAlloc(LPTR, bufSize);

    if (!pBuf) {
      RegCloseKey(hKey);

      res = ShowError(MB_CANCELTRYCONTINUE, ERROR_NOT_ENOUGH_MEMORY, "LocalAlloc(%lu)", (unsigned long)bufSize);
      continue;
    }

    for (DWORD num = 0 ; num < maxPortsReported ; num++) {
      if (!comDb.IsFreeNum(num))
        pBuf[num/8] |= (1 << (num%8));
    }

    err = RegSetValueEx(hKey,
                        comDbLocalName,
                        NULL,
                        REG_BINARY,
                        pBuf,
                        bufSize);

    RegCloseKey(hKey);
    LocalFree(pBuf);

    if (err != ERROR_SUCCESS) {
      res = ShowError(MB_CANCELTRYCONTINUE, err, "RegSetValueEx(%s\\%s)", comDbLocalKey, comDbLocalName);
      continue;
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE) {
    SetLastError(ERROR_CANCELLED);
    return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool ComDbGetInUse(const char *pPortName, bool &inUse)
{
  WORD num = name2num(pPortName);

  if (num == 0) {
    inUse = FALSE;  // not arbitered by ComDB
  } else {
    BusyMask comDb;

    if (!LoadComDb(comDb))
      return FALSE;

    inUse = !comDb.IsFreeNum(num - 1);
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
void ComDbSync(PCNC_ENUM_FILTER pFilter)
{
  BusyMask comNames;

  if (!LoadComNames(pFilter, comNames))
    return;

  BusyMask comDbLocal;

  if (!LoadComDbLocal(comDbLocal))
    return;

  for (DWORD num = 0 ; num < COMDB_MAX_PORTS_ARBITRATED ; num++) {
    if (comNames.IsFreeNum(num)) {
      if (!comDbLocal.IsFreeNum(num)) {
        if (ClaimReleasePort(num + 1, FALSE)) {
          comDbLocal.DelNum(num);
          SaveComDbLocal(comDbLocal);
        }
      }
    } else {
      if (comDbLocal.IsFreeNum(num)) {
        if (ClaimReleasePort(num + 1, TRUE)) {
          comDbLocal.AddNum(num);
          SaveComDbLocal(comDbLocal);
        }
      }
    }
  }
}
///////////////////////////////////////////////////////////////
DWORD ComDbQueryNames(char *pBuf, DWORD maxChars)
{
  BusyMask comDb;

  if (!LoadComDb(comDb))
    return 0;

  char *pB = pBuf;

  for (DWORD num = 0 ; num < COMDB_MAX_PORTS_ARBITRATED ; num++) {
    if (comDb.IsFreeNum(num))
      continue;

    int len = SNPRINTF(pB, maxChars, "COM%u", (unsigned)(num + 1));

    if (len < 0) {
      SetLastError(ERROR_INSUFFICIENT_BUFFER);
      return 0;
    }

    pB += len + 1;
    maxChars -= len + 1;
  }

  if (pB == pBuf) {
    SetLastError(ERROR_FILE_NOT_FOUND);
    return 0;
  }

  if (maxChars == 0) {
    SetLastError(ERROR_INSUFFICIENT_BUFFER);
    return 0;
  }

  *pB++ = 0;

  return (DWORD)(pB - pBuf);
}
///////////////////////////////////////////////////////////////
bool ComDbClaim(const char *pPortName)
{
  return ClaimReleasePort(name2num(pPortName), TRUE);
}
///////////////////////////////////////////////////////////////
bool ComDbRelease(const char *pPortName)
{
  return ClaimReleasePort(name2num(pPortName), FALSE);
}
///////////////////////////////////////////////////////////////
bool ComDbIsValidName(const char *pPortName)
{
  if (name2num(pPortName) == 0) {
    ShowMsg(MB_OK|MB_ICONSTOP, "The port name %s is not in COM<1-%u> format.\n",
            pPortName, (unsigned)COMDB_MAX_PORTS_ARBITRATED);

    return FALSE;
  }

  return name2num(pPortName) != 0;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/msg.h

/*
 * $Id: msg.h,v 1.6 2011/12/15 15:51:48 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: msg.h,v $
 * Revision 1.6  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.5  2009/02/16 10:32:56  vfrolov
 * Added Silent() and PromptReboot()
 *
 * Revision 1.4  2007/09/20 12:29:03  vfrolov
 * Added return value to SetOutputFile()
 *
 * Revision 1.3  2006/11/21 11:34:55  vfrolov
 * Added
 *   ConsoleWrite()
 *   IsConsoleOpen()
 *   SetOutputFile()
 *   GetOutputFile()
 *
 * Revision 1.2  2006/10/23 12:04:23  vfrolov
 * Added SetTitle()
 *
 * Revision 1.1  2006/07/28 12:16:42  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_MSG_H_
#define _C0C_MSG_H_

int ShowMsg(UINT type, const char *pFmt, ...);
int ShowError(UINT type, DWORD err, const char *pFmt, ...);
int ShowLastError(UINT type, const char *pFmt, ...);
void Trace(const char *pFmt, ...);
void ConsoleWriteRead(char *pReadBuf, int lenReadBuf, const char *pFmt, ...);
void ConsoleWrite(const char *pFmt, ...);
bool IsConsoleOpen();
void SetTitle(const char *pTitle);
bool SetOutputFile(const char *pFile);
const char *GetOutputFile();
bool Silent();
void Silent(bool val);
void PromptReboot();

#endif /* _C0C_MSG_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/inffile.cpp

/*
 * $Id: inffile.cpp,v 1.12 2011/12/15 15:51:48 vfrolov Exp $
 *
 * Copyright (c) 2006-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: inffile.cpp,v $
 * Revision 1.12  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.11  2011/07/15 16:09:05  vfrolov
 * Disabled MessageBox() for silent mode and added default processing
 *
 * Revision 1.10  2010/07/30 09:27:18  vfrolov
 * Added STRDUP()
 * Fixed updating the source location information by OemPath() and InstallOEMInf()
 * Optimazed UninstallAllInfFiles() to look omly OEM files
 *
 * Revision 1.9  2010/07/16 07:47:13  vfrolov
 * Added using SetupUninstallOEMInf() if it exists in setupapi.dll
 *
 * Revision 1.8  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.7  2009/02/16 10:36:16  vfrolov
 * Done --silent option more silent
 *
 * Revision 1.6  2008/04/02 10:30:26  vfrolov
 * Added check pointer for null
 *
 * Revision 1.5  2007/09/20 12:39:59  vfrolov
 * Added SetLastError(ERROR_NOT_ENOUGH_MEMORY)
 *
 * Revision 1.4  2007/06/15 09:45:50  vfrolov
 * Increased list size for SetupGetInfFileList()
 *
 * Revision 1.3  2007/06/14 16:11:01  vfrolov
 * Added Scan INF files progress indication
 *
 * Revision 1.2  2006/10/19 13:28:48  vfrolov
 * Added InfFile::UninstallAllInfFiles()
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "inffile.h"
#include "msg.h"
#include "utils.h"

///////////////////////////////////////////////////////////////
static bool GetVersionInfo(const char *pInfPath, const char *pKey, char **ppValue, bool showErrors)
{
  if (!pInfPath)
    return FALSE;

  if (*ppValue)
    return TRUE;

  DWORD size;
  PSP_INF_INFORMATION pInformation;

  if (!SetupGetInfInformation(pInfPath, INFINFO_INF_NAME_IS_ABSOLUTE, NULL, 0, &size)) {
    if (showErrors)
      ShowLastError(MB_OK|MB_ICONSTOP, "SetupGetInfInformation() for %s", pInfPath);
    return FALSE;
  }

  pInformation = (PSP_INF_INFORMATION)LocalAlloc(LPTR, size);

  if (pInformation) {
    if (!SetupGetInfInformation(pInfPath, INFINFO_INF_NAME_IS_ABSOLUTE, pInformation, size, NULL)) {
      if (showErrors)
        ShowLastError(MB_OK|MB_ICONSTOP, "SetupGetInfInformation() for %s", pInfPath);
      LocalFree(pInformation);
      return FALSE;
    }
  } else {
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    ShowLastError(MB_OK|MB_ICONSTOP, "LocalAlloc(%lu)", (unsigned long)size);
    return FALSE;
  }

  if (!SetupQueryInfVersionInformation(pInformation, 0, pKey, NULL, 0, &size)) {
    if (showErrors)
      ShowLastError(MB_OK|MB_ICONSTOP, "SetupQueryInfVersionInformation(%s) for %s", pKey, pInfPath);
    LocalFree(pInformation);
    return FALSE;
  }

  *ppValue = (char *)LocalAlloc(LPTR, size*sizeof(*ppValue[0]));

  if (*ppValue) {
    if (!SetupQueryInfVersionInformation(pInformation, 0, pKey, *ppValue, size, NULL)) {
      if (showErrors)
        ShowLastError(MB_OK|MB_ICONSTOP, "SetupQueryInfVersionInformation(%s) for %s", pKey, pInfPath);
      LocalFree(*ppValue);
      *ppValue = NULL;
      LocalFree(pInformation);
      return FALSE;
    }
  } else {
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    ShowLastError(MB_OK|MB_ICONSTOP, "LocalAlloc(%lu)", (unsigned long)(size*sizeof(*ppValue[0])));
    LocalFree(pInformation);
    return FALSE;
  }

  LocalFree(pInformation);
  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool Open(const char *pInfPath, HINF *phInf, bool showErrors)
{
  if (*phInf != INVALID_HANDLE_VALUE)
    return TRUE;

  int res;

  do {
    res = IDCONTINUE;

    UINT errLine;
    *phInf = SetupOpenInfFile(pInfPath, NULL, INF_STYLE_WIN4, &errLine);

    if (*phInf == INVALID_HANDLE_VALUE) {
      if (!showErrors)
        break;

      res = ShowLastError(MB_RETRYCANCEL,
                          "SetupOpenInfFile(%s) on line %u",
                          pInfPath, errLine);
    }
  } while (res == IDRETRY);

  return *phInf != INVALID_HANDLE_VALUE;
}
///////////////////////////////////////////////////////////////
static bool IsPathInList(
    const char *pPath,
    const char *const *ppList)
{
  if (pPath == NULL || ppList == NULL)
    return FALSE;

  while (*ppList) {
    if (lstrcmpi(*ppList++, pPath) == 0)
      return TRUE;
  }

  return FALSE;
}
///////////////////////////////////////////////////////////////
static bool GetFilePath(
    const char *pFileName,
    const char *pNearPath,
    char *pFilePath,
    DWORD lenFilePath)
{
  char *pBuf;
  DWORD res;

  if (!pNearPath) {
    if (DWORD(lstrlen(pFileName)) >= lenFilePath) {
      ShowError(MB_OK|MB_ICONSTOP, ERROR_BUFFER_OVERFLOW, "lstrlen(%s) >= %lu",
                pFileName, (long)lenFilePath);
      return FALSE;
    }

    lstrcpy(pFilePath, pFileName);

    return TRUE;
  }

  res = GetFullPathName(pNearPath, lenFilePath, pFilePath, &pBuf);

  if (!res) {
    ShowLastError(MB_OK|MB_ICONSTOP, "GetFullPathName(%s)", pNearPath);
    return FALSE;
  }

  if (res >= lenFilePath) {
    ShowError(MB_OK|MB_ICONSTOP, ERROR_BUFFER_OVERFLOW, "GetFullPathName(%s)", pNearPath);
    return FALSE;
  }

  if (!pBuf) {
    ShowError(MB_OK|MB_ICONSTOP, ERROR_INVALID_NAME, "GetFullPathName(%s)", pNearPath);
    return FALSE;
  }

  if (DWORD(pBuf - pFilePath + lstrlen(pFileName)) >= lenFilePath) {
    ShowError(MB_OK|MB_ICONSTOP, ERROR_BUFFER_OVERFLOW, "GetFullPathName(%s)", pNearPath);
    return FALSE;
  }

  lstrcpy(pBuf, pFileName);

  //ShowMsg(MB_OK, "pFilePath=%s\n", pFilePath);

  return TRUE;
}

InfFile::InfFile(const char *pInfName, const char *pNearPath)
  : pPath(NULL)
  , pOemPath(NULL)
  , pClassGUID(NULL)
  , pClass(NULL)
  , pProvider(NULL)
  , pDriverVer(NULL)
  , pUninstallInfTag(NULL)
  , hInf(INVALID_HANDLE_VALUE)
{
  char path[MAX_PATH + 1];

  if (GetFilePath(pInfName, pNearPath, path, sizeof(path)/sizeof(path[0])))
    pPath = STRDUP(path);
}
///////////////////////////////////////////////////////////////
InfFile::~InfFile()
{
  if (pPath)
    LocalFree((HLOCAL)pPath);
  if (pOemPath)
    LocalFree((HLOCAL)pOemPath);
  if (pClassGUID)
    LocalFree((HLOCAL)pClassGUID);
  if (pClass)
    LocalFree((HLOCAL)pClass);
  if (pProvider)
    LocalFree((HLOCAL)pProvider);
  if (pUninstallInfTag)
    LocalFree((HLOCAL)pUninstallInfTag);
  if (pDriverVer)
    LocalFree((HLOCAL)pDriverVer);
  if (hInf != INVALID_HANDLE_VALUE)
    SetupCloseInfFile(hInf);
}
///////////////////////////////////////////////////////////////
bool InfFile::Test(const InfFileField *pFields, bool showErrors) const
{
  if (!Open(pPath, &hInf, showErrors))
    return FALSE;

  for (const InfFileField *pField = pFields ; pField->pSection != NULL ; pField++) {
    INFCONTEXT context;

    if (!SetupFindFirstLine(hInf, pField->pSection, pField->pKey, &context))
      return FALSE;

    for (;;) {
      DWORD size;

      if (!SetupGetStringField(&context, pField->nField, NULL, 0, &size))
        return FALSE;

      char *pValue = (char *)LocalAlloc(LPTR, size*sizeof(pValue[0]));

      if (pValue == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastError(MB_OK|MB_ICONSTOP, "LocalAlloc(%lu)", (unsigned long)(size*sizeof(pValue[0])));
        return FALSE;
      }

      if (!SetupGetStringField(&context, pField->nField, pValue, size, NULL)) {
        LocalFree(pValue);
        return FALSE;
      }

      if (lstrcmpi(pValue, pField->pFieldValue) == 0) {
        LocalFree(pValue);
        break;
      }

      LocalFree(pValue);

      if (!SetupFindNextMatchLine(&context, pField->pKey, &context))
        return FALSE;
    }
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
const char *InfFile::OemPath(bool showErrors) const
{
  if (!pOemPath) {
    char path[MAX_PATH + 1];

    if (SetupCopyOEMInf(pPath, NULL, SPOST_NONE, SP_COPY_REPLACEONLY|SP_COPY_NOOVERWRITE,
          path, sizeof(path)/sizeof(path[0]), NULL, NULL) ||
        GetLastError() == ERROR_FILE_EXISTS)
    {
      pOemPath = STRDUP(path, showErrors);
    }
  }

  return pOemPath;
}
///////////////////////////////////////////////////////////////
const char *InfFile::ClassGUID(bool showErrors) const
{
  GetVersionInfo(pPath, "ClassGUID", &pClassGUID, showErrors);

  return pClassGUID;
}
///////////////////////////////////////////////////////////////
const char *InfFile::Class(bool showErrors) const
{
  GetVersionInfo(pPath, "Class", &pClass, showErrors);

  return pClass;
}
///////////////////////////////////////////////////////////////
const char *InfFile::Provider(bool showErrors) const
{
  GetVersionInfo(pPath, "Provider", &pProvider, showErrors);

  return pProvider;
}
///////////////////////////////////////////////////////////////
const char *InfFile::DriverVer(bool showErrors) const
{
  GetVersionInfo(pPath, "DriverVer", &pDriverVer, showErrors);

  return pDriverVer;
}
///////////////////////////////////////////////////////////////
const char *InfFile::UninstallInfTag(bool showErrors) const
{
  GetVersionInfo(pPath, "UninstallInfTag", &pUninstallInfTag, showErrors);

  return pUninstallInfTag;
}
///////////////////////////////////////////////////////////////
static UINT FileCallback(
    PVOID Context,
    UINT Notification,
    UINT_PTR Param1,
    UINT_PTR Param2)
{
  if (Notification == SPFILENOTIFY_ENDDELETE) {
    PFILEPATHS pFilePaths = (PFILEPATHS)Param1;

    if (pFilePaths->Win32Error == ERROR_SUCCESS) {
      Trace("Deleted File %s\n", pFilePaths->Target);
    }
    else
    if (pFilePaths->Win32Error == ERROR_FILE_NOT_FOUND) {
      Trace("File %s not installed\n", pFilePaths->Target);
    }
    else {
      ShowError(MB_OK|MB_ICONWARNING, pFilePaths->Win32Error, "Delete(%s)", pFilePaths->Target);
    }
  }

  return SetupDefaultQueueCallback(Context, Notification, Param1, Param2);
}

bool InfFile::UninstallFiles(const char *pFilesSection) const
{
  if (!pPath)
    return FALSE;

  if (!Open(pPath, &hInf, TRUE))
    return FALSE;

  int res;

  do {
    res = IDCONTINUE;

    HSPFILEQ hFileQueue = SetupOpenFileQueue();

    if (hFileQueue != INVALID_HANDLE_VALUE) {
      if (SetupQueueDeleteSection(hFileQueue, hInf, NULL, pFilesSection)) {
        PVOID pContext = SetupInitDefaultQueueCallback(NULL);

        if (pContext) {
          if(!SetupCommitFileQueue(NULL, hFileQueue, FileCallback, pContext))
            res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupCommitFileQueue()");

          SetupTermDefaultQueueCallback(pContext);
        } else {
          res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupInitDefaultQueueCallback()");
        }
      } else {
        res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupQueueDeleteSection(%s)", pFilesSection);
      }

      SetupCloseFileQueue(hFileQueue);
    } else {
      res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupOpenFileQueue()");
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool InfFile::InstallOEMInf() const
{
  if (!pPath)
    return FALSE;

  bool wasInstalled = (OemPath() != NULL);

  if (!SetupCopyOEMInf(pPath, NULL, SPOST_PATH, 0, NULL, 0, NULL, NULL)) {
    ShowLastError(MB_OK|MB_ICONSTOP, "SetupCopyOEMInf(%s)", pPath);
    return FALSE;
  }

  if (!wasInstalled)
    Trace("Installed %s to %s\n", pPath, OemPath());
  else
    Trace("Re-installed %s to %s\n", pPath, OemPath());

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool UninstallFile(const char *pPath)
{
  int res;

  do {
    res = IDCONTINUE;

    if (DeleteFile(pPath)) {
      Trace("Deleted %s\n", pPath);
    }
    else
    if (GetLastError() == ERROR_FILE_NOT_FOUND) {
      Trace("File %s not installed\n", pPath);
    }
    else {
      res = ShowLastError(MB_CANCELTRYCONTINUE, "DeleteFile(%s)", pPath);
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}

static bool UninstallInf(const char *pPath)
{
  if (pPath == NULL)
    return FALSE;

  int res;

  do {
    res = IDCONTINUE;

    char infPathDest[MAX_PATH + 1];

    if (SNPRINTF(infPathDest, sizeof(infPathDest)/sizeof(infPathDest[0]), "%s", pPath) > 0) {
      typedef BOOL (WINAPI *PSETUPUNINSTALLOEMINFA)(IN PCSTR, IN DWORD, IN PVOID);
      static PSETUPUNINSTALLOEMINFA pSetupUninstallOEMInf = NULL;

      if(!pSetupUninstallOEMInf) {
        HMODULE hModule = GetModuleHandle("setupapi.dll");

        if (hModule) {
          pSetupUninstallOEMInf =
              (PSETUPUNINSTALLOEMINFA)GetProcAddress(hModule, "SetupUninstallOEMInfA");
        }
      }

      if (pSetupUninstallOEMInf) {
        char *pInfNameDest, *p;

        for (pInfNameDest = p = infPathDest ; *p ; p++)
          if (*p == '\\')
            pInfNameDest = p + 1;

        if (pSetupUninstallOEMInf(pInfNameDest, 0, NULL)) {
          Trace("Uninstalled %s\n", pInfNameDest);
        } else {
          res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupUninstallOEMInf(%s)", pInfNameDest);
        }
      }
      else
      if (UninstallFile(infPathDest)) {
        int infPathDestLen = lstrlen(infPathDest);

        if (infPathDestLen > 4) {
          char *pInfPathDestExt = infPathDest + infPathDestLen - 4;

          if (!lstrcmpi(pInfPathDestExt, ".inf")) {
            pInfPathDestExt[1] = 'p';     // pInfPathDestExt = ".pnf"

            if (!UninstallFile(infPathDest))
              res = IDCANCEL;
          }
        }
      } else {
        res = IDCANCEL;
      }
    } else {
      Trace("Can't uninstall %s\n", pPath);
      res = IDCANCEL;
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool InfFile::UninstallOEMInf() const
{
  if (!pPath)
    return FALSE;

  int res;

  do {
    res = IDCONTINUE;

    if (OemPath()) {
      UninstallInf(OemPath());
    } else {
      if (GetLastError() == ERROR_FILE_NOT_FOUND) {
        Trace("File %s not installed\n", pPath);
      } else {
        res = ShowLastError(MB_CANCELTRYCONTINUE, "SetupCopyOEMInf(%s)", pPath);
      }
    }
  } while (res == IDTRYAGAIN);

  if (res != IDCONTINUE)
    return FALSE;

  return TRUE;
}
///////////////////////////////////////////////////////////////
static bool TestUninstall(
    const InfFile &infFile,
    const InfFile::InfFileUninstall *pInfFileUninstallList,
    bool queryConfirmation)
{
  for (
      const InfFile::InfFileUninstall *pInfFileUninstall = pInfFileUninstallList ;
      pInfFileUninstall->pRequiredFields != NULL ;
      pInfFileUninstall++)
  {
    if (pInfFileUninstall->queryConfirmation != queryConfirmation)
      continue;

    if (infFile.Test(pInfFileUninstall->pRequiredFields, FALSE))
      return TRUE;
  }

  return FALSE;
}

bool InfFile::UninstallAllInfFiles(
    const InfFileUninstall *pInfFileUninstallList,
    const char *const *ppOemPathExcludeList)
{
  Trace("Scan INF files .");

  DWORD size;

  if (!SetupGetInfFileList(NULL, INF_STYLE_WIN4, NULL, 0, &size)) {
    DWORD err = GetLastError();

    Trace(" FAIL\n");
    ShowError(MB_OK|MB_ICONSTOP, err, "SetupGetInfFileList()");
    return FALSE;
  }

  Trace("...");

  size += 256; // possible new INF files were added since
  char *pList = (char *)LocalAlloc(LPTR, size*sizeof(pList[0]));

  if (pList) {
    if (!SetupGetInfFileList(NULL, INF_STYLE_WIN4, pList, size, NULL)) {
      DWORD err = GetLastError();

      Trace(" FAIL\n");
      ShowError(MB_OK|MB_ICONSTOP, err, "SetupGetInfFileList(%lu)", (unsigned long)size);
      LocalFree(pList);
      return FALSE;
    }
  } else {
    Trace(" FAIL\n");
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    ShowLastError(MB_OK|MB_ICONSTOP, "LocalAlloc(%lu)", (unsigned long)size);
    return FALSE;
  }

  Trace(".");

  char windir[MAX_PATH + 1];

  size = GetEnvironmentVariable("windir", windir, sizeof(windir)/sizeof(windir[0]));

  if (!size || size >= sizeof(windir)/sizeof(windir[0])) {
    DWORD err = !size ? GetLastError() : ERROR_BUFFER_OVERFLOW;

    Trace(" FAIL\n");
    ShowError(MB_OK|MB_ICONSTOP, err, "GetEnvironmentVariable(windir)");
    LocalFree(pList);
    return FALSE;
  }

  char *p = pList;
  int i;
  int m;

  p = pList;
  i = 0;

  do {
    i++;
    p += lstrlen(p) + 1;
  } while (*p);

  m = i/3;

  if (m == 0)
    m = 1;

  p = pList;
  i = 0;

  do {
    if (++i%m == 0)
      Trace(".");

    char infPath[MAX_PATH + 1];

    if ((p[0] == 'O' || p[0] == 'o') &&
        (p[1] == 'E' || p[1] == 'e') &&
        (p[2] == 'M' || p[2] == 'm') &&
        SNPRINTF(infPath, sizeof(infPath)/sizeof(infPath[0]), "%s\\inf\\%s", windir, p) > 0)
    {
      InfFile infFile(infPath, NULL);
      bool doUninstall;

      if (IsPathInList(infFile.Path(), ppOemPathExcludeList)) {
        //Trace("\nSkipped %s\n", infFile.Path());
        doUninstall = FALSE;
      }
      else
      if (TestUninstall(infFile, pInfFileUninstallList, FALSE)) {
        doUninstall = TRUE;
      }
      else
      if (TestUninstall(infFile, pInfFileUninstallList, TRUE)) {
        int res;

        res = ShowMsg(MB_YESNO,
            "The file %s possible should be deleted too.\n"
            "\n"
            "%s:\n"
            "  ClassGUID = %s\n"
            "  Class = %s\n"
            "  Provider = %s\n"
            "  DriverVer = %s\n"
            "  UninstallInfTag = %s\n"
            "\n"
            "Would you like to delete it?\n",
            infFile.Path(),
            infFile.Path(),
            infFile.ClassGUID(FALSE),
            infFile.Class(FALSE),
            infFile.Provider(FALSE),
            infFile.DriverVer(FALSE),
            infFile.UninstallInfTag(FALSE));

        if (res == 0)
          res = IDNO;

        doUninstall = (res == IDYES);
      } else {
        doUninstall = FALSE;
      }

      if (doUninstall) {
        Trace("\n");

        if (infFile.hInf != INVALID_HANDLE_VALUE) {
          SetupCloseInfFile(infFile.hInf);
          infFile.hInf = INVALID_HANDLE_VALUE;
        }

        UninstallInf(infFile.Path());
      }
    }

    p += lstrlen(p) + 1;
  } while (*p);

  Trace(" done.\n");

  LocalFree(pList);

  return TRUE;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/sources

TARGETNAME=setup
TARGETPATH=..
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1

MSC_WARNING_LEVEL=/W4

SOURCES= \
        setup.cpp \
        inffile.cpp \
        params.cpp \
        devutils.cpp \
        portnum.cpp \
        comdb.cpp \
        msg.cpp \
        utils.cpp \
        setup.rc \

TARGETLIBS= \
        $(DDK_LIB_PATH)\kernel32.lib \
        $(DDK_LIB_PATH)\advapi32.lib \
        $(DDK_LIB_PATH)\setupapi.lib \
        $(DDK_LIB_PATH)\newdev.lib \
        $(DDK_LIB_PATH)\user32.lib \
        $(DDK_LIB_PATH)\msports.lib \
        $(DDK_LIB_PATH)\shlwapi.lib \

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/comdb.h

/*
 * $Id: comdb.h,v 1.5 2011/12/29 14:34:23 vfrolov Exp $
 *
 * Copyright (c) 2008-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: comdb.h,v $
 * Revision 1.5  2011/12/29 14:34:23  vfrolov
 * Implemented RealPortName=COM<n> for PortName=COM#
 *
 * Revision 1.4  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.3  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.2  2008/12/25 16:57:33  vfrolov
 * Added ComDbQueryNames()
 *
 * Revision 1.1  2008/12/24 15:20:35  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_COMDB_H_
#define _C0C_COMDB_H_

///////////////////////////////////////////////////////////////
bool ComDbGetInUse(const char *pPortName, bool &inUse);
void ComDbSync(PCNC_ENUM_FILTER pFilter);
DWORD ComDbQueryNames(char *pBuf, DWORD maxChars);
bool ComDbClaim(const char *pPortName);
bool ComDbRelease(const char *pPortName);
bool ComDbIsValidName(const char *pPortName);
///////////////////////////////////////////////////////////////

#endif /* _C0C_COMDB_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/.cvsignore

obj
objchk*
objfre*


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/setup.def

LIBRARY  SETUP

EXPORTS
   MainA
   RunDllA


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/msg.cpp

/*
 * $Id: msg.cpp,v 1.15 2012/06/04 06:15:37 vfrolov Exp $
 *
 * Copyright (c) 2006-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: msg.cpp,v $
 * Revision 1.15  2012/06/04 06:15:37  vfrolov
 * Fixed previous commit
 *
 * Revision 1.14  2012/06/04 06:02:14  vfrolov
 * Added commented code with SetupSetNonInteractiveMode
 *
 * Revision 1.13  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.12  2011/12/08 09:32:04  vfrolov
 * Fixed unreadable console output by changing LANG_NEUTRAL to LANG_ENGLISH
 *
 * Revision 1.11  2011/07/15 16:09:05  vfrolov
 * Disabled MessageBox() for silent mode and added default processing
 *
 * Revision 1.10  2011/07/13 17:42:46  vfrolov
 * Added tracing of dialogs
 *
 * Revision 1.9  2010/07/30 09:19:29  vfrolov
 * Added STRDUP()
 *
 * Revision 1.8  2009/11/09 11:16:43  vfrolov
 * Added restoring last error
 *
 * Revision 1.7  2009/02/16 10:32:56  vfrolov
 * Added Silent() and PromptReboot()
 *
 * Revision 1.6  2007/10/19 16:11:56  vfrolov
 * Added ability to redirect console output
 *
 * Revision 1.5  2007/09/20 12:29:03  vfrolov
 * Added return value to SetOutputFile()
 *
 * Revision 1.4  2006/11/21 11:34:55  vfrolov
 * Added
 *   ConsoleWrite()
 *   IsConsoleOpen()
 *   SetOutputFile()
 *   GetOutputFile()
 *
 * Revision 1.3  2006/10/23 12:04:23  vfrolov
 * Added SetTitle()
 *
 * Revision 1.2  2006/10/17 10:03:59  vfrolov
 * Added MB_SETFOREGROUND flag to MessageBox()
 *
 * Revision 1.1  2006/07/28 12:16:42  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "msg.h"
#include "utils.h"

static char *pOutputFile = NULL;
static char title[80] = "";
static bool silent = FALSE;

///////////////////////////////////////////////////////////////
static int ShowMsgDefault(LPCSTR pText, UINT type)
{
  return Silent() ? 0 : MessageBox(NULL, pText, title, type|MB_SETFOREGROUND);
}

static int (* pShowMsg)(LPCSTR pText, UINT type) = ShowMsgDefault;
///////////////////////////////////////////////////////////////
static bool isConsoleOpen = FALSE;

static void ConsoleWriteReadDefault(LPSTR pReadBuf, DWORD lenReadBuf, LPCSTR pText)
{
  static HANDLE handle = INVALID_HANDLE_VALUE;

  if (handle == INVALID_HANDLE_VALUE) {
    AllocConsole();
    handle = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTitle(title);
    isConsoleOpen = TRUE;
  }

  if (pText) {
    DWORD cnt;

    if (GetFileType(handle) == FILE_TYPE_CHAR)
      WriteConsole(handle, pText, lstrlen(pText), &cnt, NULL);
    else
      WriteFile(handle, pText, lstrlen(pText), &cnt, NULL);
  }

  if (pReadBuf && lenReadBuf > 0) {
    if (lenReadBuf > 1 &&
        ReadConsole(GetStdHandle(STD_INPUT_HANDLE), pReadBuf, lenReadBuf - 1, &lenReadBuf, 0))
    {
      pReadBuf[lenReadBuf] = 0;
    } else {
      pReadBuf[0] = 0;
    }
  }
}

static void (* pConsole)(LPSTR pReadBuf, DWORD lenReadBuf, LPCSTR pText) = ConsoleWriteReadDefault;
///////////////////////////////////////////////////////////////
static void TraceDefault(LPCSTR pText)
{
  pConsole(NULL, 0, pText);

  if (!pOutputFile || !pText)
    return;

  HANDLE hFile = CreateFile(
                   pOutputFile,
                   GENERIC_WRITE,
                   FILE_SHARE_READ,
                   NULL,
                   OPEN_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);

  if (hFile != INVALID_HANDLE_VALUE) {
    SetFilePointer(hFile, 0, NULL, FILE_END);

    LPCSTR p;

    for (p = pText ; *p ; p++) {
      DWORD not_used;

      if (*p == '\n')
        WriteFile(hFile, "\r", sizeof(*p), &not_used, NULL);
      WriteFile(hFile, p, sizeof(*p), &not_used, NULL);
    }

    CloseHandle(hFile);
  }
}

static void (* pTrace)(LPCSTR pText) = TraceDefault;
///////////////////////////////////////////////////////////////
static int ShowMsg(LPCSTR pText, UINT type)
{
  Trace("\nDIALOG: {\n%s} ... ", pText);

#define TRACECASE(p, s) case p##s: Trace(#s); break;

  int res = pShowMsg(pText, type);

  switch(res) {
    TRACECASE(ID, OK)
    TRACECASE(ID, CANCEL)
    TRACECASE(ID, ABORT)
    TRACECASE(ID, RETRY)
    TRACECASE(ID, IGNORE)
    TRACECASE(ID, YES)
    TRACECASE(ID, NO)
    TRACECASE(ID, CLOSE)
    TRACECASE(ID, HELP)
    TRACECASE(ID, TRYAGAIN)
    TRACECASE(ID, CONTINUE)
    case 0:
      Trace("ERROR");
      break;
    default:
      Trace("%d", res);
  }

  Trace("\n");

  return res;
}
///////////////////////////////////////////////////////////////
static int ShowMsgVA(UINT type, const char *pFmt, va_list va)
{
  char buf[1024];

  VSNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), pFmt, va);

  return ShowMsg(buf, type);
}
///////////////////////////////////////////////////////////////
static int ShowErrorVA(UINT type, DWORD err, const char *pFmt, va_list va)
{
  char buf[1024];

  VSNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), pFmt, va);

  LPVOID pMsgBuf;

  FormatMessage(
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL,
      err,
      MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
      (LPTSTR) &pMsgBuf,
      0,
      NULL);

  int len = lstrlen(buf);

  if ((err & 0xFFFF0000) == 0)
    SNPRINTF(buf + len, sizeof(buf)/sizeof(buf[0]) - len, "\nERROR: %lu - %s\n", (unsigned long)err, pMsgBuf);
  else
    SNPRINTF(buf + len, sizeof(buf)/sizeof(buf[0]) - len, "\nERROR: 0x%08lX - %s\n", (unsigned long)err, pMsgBuf);

  LocalFree(pMsgBuf);

  return ShowMsg(buf, type);
}
///////////////////////////////////////////////////////////////
int ShowMsg(UINT type, const char *pFmt, ...)
{
  int res;
  va_list va;

  va_start(va, pFmt);
  res = ShowMsgVA(type, pFmt, va);
  va_end(va);

  return res;
}
///////////////////////////////////////////////////////////////
int ShowError(UINT type, DWORD err, const char *pFmt, ...)
{
  int res;
  va_list va;

  va_start(va, pFmt);
  res = ShowErrorVA(type, err, pFmt, va);
  va_end(va);

  return res;
}
///////////////////////////////////////////////////////////////
int ShowLastError(UINT type, const char *pFmt, ...)
{
  int res;

  DWORD err = GetLastError();

  va_list va;

  va_start(va, pFmt);
  res = ShowErrorVA(type, err, pFmt, va);
  va_end(va);

  SetLastError(err);

  return res;
}
///////////////////////////////////////////////////////////////
void Trace(const char *pFmt, ...)
{
  char buf[1024];
  va_list va;

  va_start(va, pFmt);

  VSNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), pFmt, va);

  va_end(va);

  DWORD err = GetLastError();

  pTrace(buf);

  SetLastError(err);
}
///////////////////////////////////////////////////////////////
void ConsoleWriteRead(char *pReadBuf, int lenReadBuf, const char *pFmt, ...)
{
  char buf[1024];
  va_list va;

  va_start(va, pFmt);

  VSNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), pFmt, va);

  va_end(va);

  DWORD err = GetLastError();

  pConsole(pReadBuf, lenReadBuf, buf);

  SetLastError(err);
}
///////////////////////////////////////////////////////////////
void ConsoleWrite(const char *pFmt, ...)
{
  char buf[1024];
  va_list va;

  va_start(va, pFmt);

  VSNPRINTF(buf, sizeof(buf)/sizeof(buf[0]), pFmt, va);

  va_end(va);

  DWORD err = GetLastError();

  pConsole(NULL, 0, buf);

  SetLastError(err);
}
///////////////////////////////////////////////////////////////
bool IsConsoleOpen()
{
  return isConsoleOpen;
}
///////////////////////////////////////////////////////////////
void SetTitle(const char *pTitle)
{
  SNPRINTF(title, sizeof(title)/sizeof(title[0]), "%s", pTitle);
}
///////////////////////////////////////////////////////////////
bool SetOutputFile(const char *pFile)
{
  if (pOutputFile) {
    LocalFree(pOutputFile);
    pOutputFile = NULL;
  }

  if (pFile) {
    pOutputFile = STRDUP(pFile);

    if (!pOutputFile)
      return FALSE;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
const char *GetOutputFile()
{
  return pOutputFile;
}
///////////////////////////////////////////////////////////////
bool Silent()
{
  return silent;
}
///////////////////////////////////////////////////////////////
void Silent(bool val)
{
  silent = val;

  /*
  typedef BOOL (WINAPI *PSETUPSETNONINTERACTIVEMODE)(IN BOOL);
  static PSETUPSETNONINTERACTIVEMODE pSetupSetNonInteractiveMode = NULL;

  if(!pSetupSetNonInteractiveMode) {
    HMODULE hModule = GetModuleHandle("setupapi.dll");

    if (hModule) {
      pSetupSetNonInteractiveMode =
          (PSETUPSETNONINTERACTIVEMODE)GetProcAddress(hModule, "SetupSetNonInteractiveMode");
    }
  }

  if (pSetupSetNonInteractiveMode)
    pSetupSetNonInteractiveMode(silent);
  */
}
///////////////////////////////////////////////////////////////
void PromptReboot()
{
  Trace("\nReboot required.\n");

  if (!silent)
    SetupPromptReboot(NULL, NULL, FALSE);
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setup/params.cpp

/*
 * $Id: params.cpp,v 1.23 2012/01/31 05:48:32 vfrolov Exp $
 *
 * Copyright (c) 2006-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: params.cpp,v $
 * Revision 1.23  2012/01/31 05:48:32  vfrolov
 * Deprecated invoking of system-supplied advanced settings dialog box
 *
 * Revision 1.22  2011/12/29 14:34:23  vfrolov
 * Implemented RealPortName=COM<n> for PortName=COM#
 *
 * Revision 1.21  2011/12/27 11:38:13  vfrolov
 * Superseded incorrect PortParameters::ClassChanged()
 *
 * Revision 1.20  2011/12/15 15:51:48  vfrolov
 * Fixed types
 *
 * Revision 1.19  2011/12/06 16:03:22  vfrolov
 * Added cleaning high data bits for less then 8 bit data
 * Added AllDataBits option to force 8 bit data
 *
 * Revision 1.18  2010/06/01 12:54:12  vfrolov
 * Fixed bit settings
 *
 * Revision 1.17  2010/05/31 07:58:14  vfrolov
 * Added ability to invoke the system-supplied advanced settings dialog box
 *
 * Revision 1.16  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.15  2008/12/25 16:55:23  vfrolov
 * Added converting portnames to uppercase
 *
 * Revision 1.14  2008/12/02 11:54:28  vfrolov
 * Fixed typo
 *
 * Revision 1.13  2008/09/17 07:58:32  vfrolov
 * Added AddRTTO and AddRITO parameters
 *
 * Revision 1.12  2008/06/26 13:39:19  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.11  2008/05/04 09:53:51  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.10  2008/04/08 06:49:44  vfrolov
 * Added pin OUT2
 *
 * Revision 1.9  2007/10/19 16:09:55  vfrolov
 * Implemented --detail-prms option
 *
 * Revision 1.8  2007/09/20 12:43:03  vfrolov
 * Added parameters string length check
 *
 * Revision 1.7  2007/09/17 14:33:38  vfrolov
 * Implemented pseudo pin OPEN
 *
 * Revision 1.6  2007/07/03 14:39:49  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.5  2007/06/01 16:32:04  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.4  2007/01/11 15:05:03  vfrolov
 * Replaced strtok() by STRTOK_R()
 *
 * Revision 1.3  2006/11/02 16:11:58  vfrolov
 * Added default values to help text
 *
 * Revision 1.2  2006/10/27 13:11:58  vfrolov
 * Added PortParameters::FillPortName()
 *
 * Revision 1.1  2006/07/28 12:16:43  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "params.h"
#include "utils.h"
#include "msg.h"

#define TEXT_PREF
#include "../include/com0com.h"

///////////////////////////////////////////////////////////////
enum {
  m_portName       = 0x00000001,
  m_emuBR          = 0x00000002,
  m_emuOverrun     = 0x00000004,
  m_plugInMode     = 0x00000008,
  m_exclusiveMode  = 0x00000010,
  m_hiddenMode     = 0x00000020,
  m_allDataBits    = 0x00000040,
  m_pinCTS         = 0x00000100,
  m_pinDSR         = 0x00000200,
  m_pinDCD         = 0x00000400,
  m_pinRI          = 0x00000800,
  m_emuNoise       = 0x00010000,
  m_addRTTO        = 0x00020000,
  m_addRITO        = 0x00040000,
  m_realPortName   = 0x01000000,
};
///////////////////////////////////////////////////////////////
static struct Bit
{
  DWORD bit;

  enum {
    OTHER,
    FLAG,
    PIN,
    PROBABILITY,
    UNSIGNED,
  } type;
} bits[] = {
  {m_portName,       Bit::OTHER},
  {m_realPortName,   Bit::OTHER},
  {m_emuBR,          Bit::FLAG},
  {m_emuOverrun,     Bit::FLAG},
  {m_plugInMode,     Bit::FLAG},
  {m_exclusiveMode,  Bit::FLAG},
  {m_hiddenMode,     Bit::FLAG},
  {m_allDataBits,    Bit::FLAG},
  {m_pinCTS,         Bit::PIN},
  {m_pinDSR,         Bit::PIN},
  {m_pinDCD,         Bit::PIN},
  {m_pinRI,          Bit::PIN},
  {m_emuNoise,       Bit::PROBABILITY},
  {m_addRTTO,        Bit::UNSIGNED},
  {m_addRITO,        Bit::UNSIGNED},
};
///////////////////////////////////////////////////////////////
PortParameters::PortParameters(const char *pService, const char *pPhPortName)
{
  SNPRINTF(service, sizeof(service)/sizeof(service[0]), "%s", pService);
  SNPRINTF(phPortName, sizeof(phPortName)/sizeof(phPortName[0]), "%s", pPhPortName);

  Init();
}
///////////////////////////////////////////////////////////////
void PortParameters::Init()
{
  portName[0] = 0;
  realPortName[0] = 0;
  emuBR = 0;
  emuOverrun = 0;
  plugInMode = 0;
  exclusiveMode = 0;
  hiddenMode = 0;
  allDataBits = 0;

  pinCTS = 0;
  pinDSR = 0;
  pinDCD = 0;
  pinRI = 0;

  emuNoise = 0;
  addRTTO = 0;
  addRITO = 0;

  maskChanged = 0;
  maskExplicit = 0;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetPortName(const char *pNewPortName)
{
  if (lstrcmpi(portName, pNewPortName) != 0) {
    if (SNPRINTF(portName, sizeof(portName)/sizeof(portName[0]), "%s", pNewPortName) <= 0) {
      Trace("Invalid port name '%s'\n", pNewPortName);
      return FALSE;
    }

    CharUpper(portName);
    maskChanged |= m_portName;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetRealPortName(const char *pNewRealPortName)
{
  if (lstrcmpi(realPortName, pNewRealPortName) != 0) {
    if (SNPRINTF(realPortName, sizeof(realPortName)/sizeof(realPortName[0]), "%s", pNewRealPortName) <= 0) {
      Trace("Invalid real port name '%s'\n", pNewRealPortName);
      return FALSE;
    }

    CharUpper(realPortName);
    maskChanged |= m_realPortName;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::InitRealPortName(const char *pRealPortName)
{
  if (!lstrcmpi("", pRealPortName)) {
    maskExplicit &= ~m_realPortName;
    maskChanged &= ~m_realPortName;

    return TRUE;
  }

  if (SNPRINTF(realPortName, sizeof(realPortName)/sizeof(realPortName[0]), "%s", pRealPortName) <= 0) {
    Trace("Invalid real port name '%s'\n", pRealPortName);
    return FALSE;
  }

  CharUpper(realPortName);

  maskChanged &= ~m_realPortName;
  maskExplicit |= m_realPortName;

  return TRUE;
}
///////////////////////////////////////////////////////////////
DWORD *PortParameters::GetDwPtr(DWORD bit)
{
  switch (bit) {
    case m_emuBR:          return &emuBR;
    case m_emuOverrun:     return &emuOverrun;
    case m_plugInMode:     return &plugInMode;
    case m_exclusiveMode:  return &exclusiveMode;
    case m_hiddenMode:     return &hiddenMode;
    case m_allDataBits:    return &allDataBits;
    case m_pinCTS:         return &pinCTS;
    case m_pinDSR:         return &pinDSR;
    case m_pinDCD:         return &pinDCD;
    case m_pinRI:          return &pinRI;
    case m_emuNoise:       return &emuNoise;
    case m_addRTTO:        return &addRTTO;
    case m_addRITO:        return &addRITO;
  }

  return NULL;
}
///////////////////////////////////////////////////////////////
static const DWORD *GetDwPtrDefault(DWORD bit)
{
  static const DWORD emuBR = C0C_DEFAULT_EMUBR;
  static const DWORD emuOverrun = C0C_DEFAULT_EMUOVERRUN;
  static const DWORD plugInMode = C0C_DEFAULT_PLUGINMODE;
  static const DWORD exclusiveMode = C0C_DEFAULT_EXCLUSIVEMODE;
  static const DWORD hiddenMode = C0C_DEFAULT_HIDDENMODE;
  static const DWORD allDataBits = C0C_DEFAULT_ALLDATABITS;
  static const DWORD pinCTS = C0C_DEFAULT_PIN_CTS;
  static const DWORD pinDSR = C0C_DEFAULT_PIN_DSR;
  static const DWORD pinDCD = C0C_DEFAULT_PIN_DCD;
  static const DWORD pinRI = C0C_DEFAULT_PIN_RI;
  static const DWORD emuNoise = C0C_DEFAULT_EMUNOISE;
  static const DWORD addRTTO = C0C_DEFAULT_ADDRTTO;
  static const DWORD addRITO = C0C_DEFAULT_ADDRITO;

  switch (bit) {
    case m_emuBR:          return &emuBR;
    case m_emuOverrun:     return &emuOverrun;
    case m_plugInMode:     return &plugInMode;
    case m_exclusiveMode:  return &exclusiveMode;
    case m_hiddenMode:     return &hiddenMode;
    case m_allDataBits:    return &allDataBits;
    case m_pinCTS:         return &pinCTS;
    case m_pinDSR:         return &pinDSR;
    case m_pinDCD:         return &pinDCD;
    case m_pinRI:          return &pinRI;
    case m_emuNoise:       return &emuNoise;
    case m_addRTTO:        return &addRTTO;
    case m_addRITO:        return &addRITO;
  }

  return NULL;
}
///////////////////////////////////////////////////////////////
static const char *GetBitName(DWORD bit)
{
  switch (bit) {
    case m_portName:       return "PortName";
    case m_realPortName:   return "RealPortName";
    case m_emuBR:          return "EmuBR";
    case m_emuOverrun:     return "EmuOverrun";
    case m_plugInMode:     return "PlugInMode";
    case m_exclusiveMode:  return "ExclusiveMode";
    case m_hiddenMode:     return "HiddenMode";
    case m_allDataBits:    return "AllDataBits";
    case m_pinCTS:         return "cts";
    case m_pinDSR:         return "dsr";
    case m_pinDCD:         return "dcd";
    case m_pinRI:          return "ri";
    case m_emuNoise:       return "EmuNoise";
    case m_addRTTO:        return "AddRTTO";
    case m_addRITO:        return "AddRITO";
  }

  return NULL;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetFlag(const char *pNewVal, DWORD bit)
{
  DWORD newFlag;

  if (!lstrcmpi(pNewVal, "yes")) {
    newFlag = 0xFFFFFFFF;
  }
  else
  if (!lstrcmpi(pNewVal, "no")) {
    newFlag = 0;
  }
  else {
    Trace("Invalid value '%s'\n", pNewVal);
    return FALSE;
  }

  DWORD *pFlag = GetDwPtr(bit);

  if (pFlag == NULL)
    return FALSE;

  if (*pFlag != newFlag) {
    *pFlag = newFlag;
    maskChanged |= bit;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetPin(const char *pNewVal, DWORD bit)
{
  DWORD newPin;

  if (*pNewVal == '!') {
    newPin = C0C_PIN_NEGATIVE;
    pNewVal++;
  } else {
    newPin = 0;
  }

  if (!lstrcmpi(pNewVal, "rrts")) {
    newPin |= C0C_PIN_RRTS;
  }
  else
  if (!lstrcmpi(pNewVal, "rdtr")) {
    newPin |= C0C_PIN_RDTR;
  }
  else
  if (!lstrcmpi(pNewVal, "rout1")) {
    newPin |= C0C_PIN_ROUT1;
  }
  else
  if (!lstrcmpi(pNewVal, "rout2")) {
    newPin |= C0C_PIN_ROUT2;
  }
  else
  if (!lstrcmpi(pNewVal, "ropen")) {
    newPin |= C0C_PIN_ROPEN;
  }
  else
  if (!lstrcmpi(pNewVal, "lrts")) {
    newPin |= C0C_PIN_LRTS;
  }
  else
  if (!lstrcmpi(pNewVal, "ldtr")) {
    newPin |= C0C_PIN_LDTR;
  }
  else
  if (!lstrcmpi(pNewVal, "lout1")) {
    newPin |= C0C_PIN_LOUT1;
  }
  else
  if (!lstrcmpi(pNewVal, "lout2")) {
    newPin |= C0C_PIN_LOUT2;
  }
  else
  if (!lstrcmpi(pNewVal, "lopen")) {
    newPin |= C0C_PIN_LOPEN;
  }
  else
  if (!lstrcmpi(pNewVal, "on")) {
    newPin |= C0C_PIN_ON;
  }
  else {
    Trace("Invalid value '%s'\n", pNewVal);
    return FALSE;
  }

  DWORD *pPin = GetDwPtr(bit);

  if (pPin == NULL)
    return FALSE;

  if (*pPin != newPin) {
    *pPin = newPin;
    maskChanged |= bit;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetProbability(const char *pNewVal, DWORD bit)
{
  DWORD newVal = 0;

  if (pNewVal[0] == '0' && pNewVal[1] == '.') {
    const char *p = pNewVal + 2;

    for (DWORD one = C0C_PROBABILITY_ONE ; one > 1 ; one /= 10) {
      newVal *= 10;

      if (*p == 0)
        continue;

      if (*p < '0' || *p > '9') {
        Trace("Invalid value '%s'\n", pNewVal);
        return FALSE;
      }

      newVal += *p++ - '0';
    }

    while (*p == '0')
      p++;

    if (*p != 0) {
      Trace("Too long value '%s'\n", pNewVal);
      return FALSE;
    }
  }
  else
  if (pNewVal[0] == '0') {
  }
  else {
    Trace("Invalid value '%s'\n", pNewVal);
    return FALSE;
  }

  DWORD *pVal = GetDwPtr(bit);

  if (pVal == NULL)
    return FALSE;

  if (*pVal != newVal) {
    *pVal = newVal;
    maskChanged |= bit;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetUnsigned(const char *pNewVal, DWORD bit)
{
  DWORD newVal = 0;

  for (const char *p = pNewVal ; *p ; p++) {
    if (*p < '0' || *p > '9') {
      Trace("Invalid value '%s'\n", pNewVal);
      return FALSE;
    }
    newVal = newVal*10 + (*p - '0');
  }

  DWORD *pVal = GetDwPtr(bit);

  if (pVal == NULL)
    return FALSE;

  if (*pVal != newVal) {
    *pVal = newVal;
    maskChanged |= bit;
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::SetBit(const char *pVal, const Bit &bit)
{
  if (!lstrcmpi(pVal, "*"))
    return TRUE;

  if (!lstrcmpi("-", pVal)) {
    if (maskExplicit & bit.bit) {
      maskExplicit &= ~bit.bit;
      maskChanged |= bit.bit;
    }
    return TRUE;
  }

  if (bit.type == Bit::FLAG) {
    if (!SetFlag(pVal, bit.bit))
      return FALSE;
  }
  else
  if (bit.type == Bit::PIN) {
    if (!SetPin(pVal, bit.bit))
      return FALSE;
  }
  else
  if (bit.type == Bit::PROBABILITY) {
    if (!SetProbability(pVal, bit.bit))
      return FALSE;
  }
  else
  if (bit.type == Bit::UNSIGNED) {
    if (!SetUnsigned(pVal, bit.bit))
      return FALSE;
  }
  else
  if (bit.type == Bit::OTHER) {
    if (bit.bit == m_portName) {
      if (!SetPortName(pVal))
        return FALSE;
    }
    else
    if (bit.bit == m_realPortName) {
      if (!SetRealPortName(pVal))
        return FALSE;
    }
    else {
      return FALSE;
    }
  }
  else {
    return FALSE;
  }

  if (maskChanged & bit.bit)
    maskExplicit |= bit.bit;

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::FillParametersKey(char *pRegKey, int size)
{
  int len;

  len = SNPRINTF(pRegKey, size, REGSTR_PATH_SERVICES "\\%s\\Parameters\\%s", service, phPortName);

  //Trace("%s\n", pRegKey);

  return len >= 0;
}
///////////////////////////////////////////////////////////////
void PortParameters::LoadDw(HKEY hKey, DWORD bit)
{
  DWORD *pDw = GetDwPtr(bit);
  const char *pName = GetBitName(bit);

  if (pDw == NULL || pName == NULL)
    return;

  DWORD buf;
  DWORD len = sizeof(buf);

  LONG err = RegQueryValueEx(hKey,
                             pName,
                             NULL,
                             NULL,
                             (PBYTE)&buf,
                             &len);

  if (err == ERROR_SUCCESS) {
    *pDw = buf;
    maskExplicit |= bit;

    //Trace("  %s=0x%lX\n", pName, (unsigned long)*pDw);
  }
}
///////////////////////////////////////////////////////////////
LONG PortParameters::SaveDw(HKEY hKey, DWORD bit)
{
  if (maskChanged & bit) {
    DWORD *pDw = GetDwPtr(bit);
    const char *pName = GetBitName(bit);

    if (pDw == NULL || pName == NULL)
      return ERROR_BAD_COMMAND;

    LONG err;

    if (maskExplicit & bit) {
      err = RegSetValueEx(hKey,
                          pName,
                          NULL,
                          REG_DWORD,
                          (PBYTE)pDw,
                          sizeof(*pDw));
    } else {
      err = RegDeleteValue(hKey, pName);

      if (err == ERROR_FILE_NOT_FOUND)
        err = ERROR_SUCCESS;
    }

    if (err != ERROR_SUCCESS)
      return err;

    maskChanged &= ~bit;
    //Trace("  New %s=0x%lX\n", pName, (unsigned long)*pDw);
  }

  return ERROR_SUCCESS;
}
///////////////////////////////////////////////////////////////
LONG PortParameters::Load()
{
  Init();

  char reqKey[100];

  FillParametersKey(reqKey, sizeof(reqKey)/sizeof(reqKey[0]));

  LONG err;
  HKEY hKey;

  err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     reqKey,
                     0,
                     KEY_READ,
                     &hKey);

  if (err == ERROR_FILE_NOT_FOUND)
    return ERROR_SUCCESS;

  if (err != ERROR_SUCCESS)
    return err;

  BYTE buf[sizeof(portName)];
  DWORD len;

  len = sizeof(buf);

  err = RegQueryValueEx(hKey,
                        "PortName",
                        NULL,
                        NULL,
                        buf,
                        &len);

  if (err == ERROR_SUCCESS) {
    SNPRINTF(portName, sizeof(portName)/sizeof(portName[0]), "%s", (char *)buf);
    maskExplicit |= m_portName;

    //Trace("  PortName=%s\n", portName);
  }

  int i;

  for (i = 0 ; i < sizeof(bits)/sizeof(bits[0]) ; i++) {
    if (!GetDwPtr(bits[i].bit))
      continue;

    LoadDw(hKey, bits[i].bit);
  }

  RegCloseKey(hKey);

  return ERROR_SUCCESS;
}
///////////////////////////////////////////////////////////////
LONG PortParameters::Save()
{
  if (!Changed()) {
    return ERROR_SUCCESS;
  }

  char reqKey[100];

  FillParametersKey(reqKey, sizeof(reqKey)/sizeof(reqKey[0]));

  LONG err;
  HKEY hKey;

  err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       reqKey,
                       0,
                       NULL,
                       0,
                       KEY_WRITE,
                       NULL,
                       &hKey,
                       NULL);

  if (err != ERROR_SUCCESS)
    return err;

  if (maskChanged & m_portName) {
    if (maskExplicit & m_portName) {
      err = RegSetValueEx(hKey,
                          "PortName",
                          NULL,
                          REG_SZ,
                          (PBYTE)portName,
                          (lstrlen(portName) + 1) * sizeof(portName[0]));
    } else {
      err = RegDeleteValue(hKey, "PortName");

      if (err == ERROR_FILE_NOT_FOUND)
        err = ERROR_SUCCESS;
    }

    if (err != ERROR_SUCCESS)
      goto err;

    maskChanged &= ~m_portName;

    //Trace("  New PortName=%s\n", portName);
  }

  int i;

  for (i = 0 ; i < sizeof(bits)/sizeof(bits[0]) ; i++) {
    if (!GetDwPtr(bits[i].bit))
      continue;

    if (SaveDw(hKey, bits[i].bit) != ERROR_SUCCESS)
      goto err;
  }

err:

  RegCloseKey(hKey);

  return err;
}
///////////////////////////////////////////////////////////////
bool PortParameters::ParseParametersStr(const char *pParameters)
{
  PortParameters tmp = *this;

  if (!lstrcmpi(pParameters, "-") || !lstrcmpi(pParameters, "*")) {
    int i;

    for (i = 0 ; i < sizeof(bits)/sizeof(bits[0]) ; i++) {
      if (!tmp.SetBit(pParameters, bits[i]))
        return FALSE;
    }
  } else {
    char pars[200];

    if (SNPRINTF(pars, sizeof(pars)/sizeof(pars[0]), "%s", pParameters) < 0) {
      Trace("The parameters string '%s' is too long\n", pParameters);
      return FALSE;
    }

    char *pSave1;

    for (char *pPar = STRTOK_R(pars, ",", &pSave1) ; pPar ; pPar = STRTOK_R(NULL, ",", &pSave1)) {
      char *pSave2;
      const char *pKey = STRTOK_R(pPar, "=", &pSave2);
      const char *pVal = STRTOK_R(NULL, "=", &pSave2);

      //Trace("'%s'='%s'\n", pKey, pVal);

      if (!pVal) {
        Trace("Missing value for '%s'\n", pKey);
        return FALSE;
      }

      int i;

      for (i = 0 ; i < sizeof(bits)/sizeof(bits[0]) ; i++) {
        DWORD bit = bits[i].bit;
        const char *pName = GetBitName(bit);

        if (pName == NULL)
          continue;

        if (!lstrcmpi(pKey, pName)) {
          if (!tmp.SetBit(pVal, bits[i]))
            return FALSE;
          break;
        }
      }

      if (i >= sizeof(bits)/sizeof(bits[0])) {
        Trace("Invalid parameter '%s'\n", pKey);
        return FALSE;
      }
    }
  }

  *this = tmp;

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::FillParametersStr(char *pParameters, int size, bool detail)
{
  int len;

  len = SNPRINTF(pParameters, size, "PortName=%s",
                 (maskExplicit & m_portName) ? portName : (detail ? phPortName : "-"));

  if (len < 0)
    return FALSE;

  pParameters += len;
  size -= len;

  if (maskExplicit & m_realPortName) {
    len = SNPRINTF(pParameters, size, ",RealPortName=%s", realPortName);

    if (len < 0)
      return FALSE;

    pParameters += len;
    size -= len;
  }

  for (int i = 0 ; i < sizeof(bits)/sizeof(bits[0]) ; i++) {
    DWORD bit = bits[i].bit;

    if (!GetDwPtr(bit))
      continue;

    const char *pName = GetBitName(bit);

    if (pName) {
      const DWORD *pBit;

      if ((maskExplicit & bit) != 0)
        pBit = GetDwPtr(bit);
      else
      if (detail)
        pBit = GetDwPtrDefault(bit);
      else
        continue;

      if (pBit == NULL)
        continue;

      if (bits[i].type == Bit::FLAG) {
        len = SNPRINTF(pParameters, size, ",%s=%s", pName, *pBit ? "yes" : "no");
      }
      else
      if (bits[i].type == Bit::PIN) {
        const char *pVal = NULL;

        switch (*pBit & ~C0C_PIN_NEGATIVE) {
          case C0C_PIN_RRTS:  pVal = "rrts";  break;
          case C0C_PIN_RDTR:  pVal = "rdtr";  break;
          case C0C_PIN_ROUT1: pVal = "rout1"; break;
          case C0C_PIN_ROUT2: pVal = "rout2"; break;
          case C0C_PIN_ROPEN: pVal = "ropen"; break;
          case C0C_PIN_LRTS:  pVal = "lrts";  break;
          case C0C_PIN_LDTR:  pVal = "ldtr";  break;
          case C0C_PIN_LOUT1: pVal = "lout1"; break;
          case C0C_PIN_LOUT2: pVal = "lout2"; break;
          case C0C_PIN_LOPEN: pVal = "lopen"; break;
          case C0C_PIN_ON:    pVal = "on";    break;
        }

        if (pVal == NULL)
          continue;

        len = SNPRINTF(pParameters, size, ",%s=%s%s", pName, (*pBit & C0C_PIN_NEGATIVE) == 0 ? "" : "!", pVal);
      }
      else
      if (bits[i].type == Bit::PROBABILITY) {
          if (*pBit == 0) {
            len = SNPRINTF(pParameters, size, ",%s=0", pName);
          } else {
            char strVal[11] = "";
            char digits[11];

            SNPRINTF(digits, sizeof(digits)/sizeof(digits[0]), "%ld", (unsigned long)*pBit);

            for (int i = lstrlen(digits) ; i ; i--) {
              if (digits[i - 1] > '0')
                break;

              digits[i - 1] = 0;
            }

            const char *p = digits;

            for (DWORD one = C0C_PROBABILITY_ONE/10 ; one > 0 ; one /= 10) {
              if (one > *pBit) {
                lstrcat(strVal, "0");
              }
              else
              if (*p) {
                char sc[2];

                sc[0] = *p++;
                sc[1] = 0;
                lstrcat(strVal, sc);
              }
              else {
                break;
              }
            }

            len = SNPRINTF(pParameters, size, ",%s=0.%s", pName, strVal);
          }
      }
      else
      if (bits[i].type == Bit::UNSIGNED) {
        len = SNPRINTF(pParameters, size, ",%s=%lu", pName, (unsigned long)*pBit);
      }

      if (len < 0)
        return FALSE;

      pParameters += len;
      size -= len;
    }
  }

  return TRUE;
}
///////////////////////////////////////////////////////////////
bool PortParameters::FillPortName(char *pPortName, int size)
{
  int len;

  len = SNPRINTF(pPortName, size, "%s",
                 (maskExplicit & m_portName) ? portName : phPortName);

  return len >= 0;
}
///////////////////////////////////////////////////////////////
bool PortParameters::FillRealPortName(char *pRealPortName, int size)
{
  int len;

  len = SNPRINTF(pRealPortName, size, "%s",
                 (maskExplicit & m_realPortName) ? realPortName : "");

  return len >= 0;
}
///////////////////////////////////////////////////////////////
const char *PortParameters::GetHelp()
{
  return
    "Syntax of port parameters string:\n"
    "  -                       - use driver's defaults for all parameters\n"
    "  *                       - use current settings for all parameters\n"
    "  <par>=<val>[,...]       - set value <val> for each parameter <par>\n"
    "\n"
    "Parameters:\n"
    "  PortName=<portname>     - set port name to <portname>\n"
    "                            (port identifier by default)\n"
    "  EmuBR={yes|no}          - enable/disable baud rate emulation in the direction\n"
    "                            to the paired port (disabled by default)\n"
    "  EmuOverrun={yes|no}     - enable/disable buffer overrun (disabled by default)\n"
    "  EmuNoise=<n>            - probability in range 0-0.99999999 of error per\n"
    "                            character frame in the direction to the paired port\n"
    "                            (0 by default)\n"
    "  AddRTTO=<n>             - add <n> milliseconds to the total time-out period\n"
    "                            for read operations (0 by default)\n"
    "  AddRITO=<n>             - add <n> milliseconds to the maximum time allowed to\n"
    "                            elapse between the arrival of two characters for\n"
    "                            read operations (0 by default)\n"
    "  PlugInMode={yes|no}     - enable/disable plug-in mode, the plug-in mode port\n"
    "                            is hidden and can't be open if the paired port is\n"
    "                            not open (disabled by default)\n"
    "  ExclusiveMode={yes|no}  - enable/disable exclusive mode, the exclusive mode\n"
    "                            port is hidden if it is open (disabled by default)\n"
    "  HiddenMode={yes|no}     - enable/disable hidden mode, the hidden mode port is\n"
    "                            hidden as it is possible for port enumerators\n"
    "                            (disabled by default)\n"
    "  AllDataBits={yes|no}    - enable/disable all data bits transfer disregard\n"
    "                            data bits setting (disabled by default)\n"
    "  cts=[!]<p>              - wire CTS pin to <p> (rrts by default)\n"
    "  dsr=[!]<p>              - wire DSR pin to <p> (rdtr by default)\n"
    "  dcd=[!]<p>              - wire DCD pin to <p> (rdtr by default)\n"
    "  ri=[!]<p>               - wire RI pin to <p> (!on by default)\n"
    "\n"
    "The possible values of <p> above can be rrts, lrts, rdtr, ldtr, rout1, lout1,\n"
    "rout2, lout2 (remote/local RTS/DTR/OUT1/OUT2), ropen, lopen (logical ON if\n"
    "remote/local port is open) or on (logical ON). The exclamation sign (!) can be\n"
    "used to invert the value.\n"
    "\n"
    "Special values:\n"
    "  -                       - use driver's default value\n"
    "  *                       - use current setting\n"
    ;
}
///////////////////////////////////////////////////////////////


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/Changes.txt

v3.0.0.0 (2012-06-04)

* Added ability to put the port to the Ports class.
* Added ability to set selections for setup.exe by setting environment variables.
* Installers setupc.exe and setupg.exe marked as "require administrative access"
  so Turning off UAC is not required now.
* Added tracing of dialogs while setup.
* Improved silent install and uninstall.
* Added cleaning high data bits for less then 8 bit data. For forcing backward
  compatibility added AllDataBits option.
* Added ability to uninstall package w/o uninstalling devices and driver.
* Added ability to build installer with com0com.cat file.
* Added ability to build installer suitable for both 32-bit and 64-bit systems.
* Implemented setting friendly names.
* Fixed some bugs and made some improvements.

v2.2.2.0 (2009-12-17)

* Added --wait option to the Setup Command Prompt.
* Fixed some bugs.

v2.2.1.0 (2009-05-29)

* Added logging COMx names in the COM port database.
* Added ability to get list of names that already in use (busynames command).
* Added ability to speed up installing of multiple com port pairs (--no-update option).
* Improved silent install and uninstall.
* Fixed some bugs and made some improvements.

v2.2.0.0 (2008-12-09)

* Implemented noise emulation.
* Added ability to monitor BREAK state.
* Added ability to fix timeouts for read operations to compensate the network delays.
* Added ability to do silent uninstalls (uninstall /S).
* Fixed some bugs and made some improvements.

v2.1.0.0 (2008-06-06)

* Implemented ability to monitor and get the paired port settings (baud rate, byte size, parity, stop bits).
* Implemented ability to change state of individual pins (OUT1 and OUT2 for example).
* Added command to Setup Command Prompt for reloading driver.
* Added ability to wire OUT2 pin.
* Added ability to permanently hide port for port enumerators.
* Fixed some bugs and made some improvements.

v2.0.0.0 (2007-12-04)

* Implemented graphics setup utility.
* Added support for 64-bit systems.
* Implemented pinout customization.
* Implemented transmit FIFO buffer.
* Implemented IOCTL_SERIAL_SET_MODEM_CONTROL device control request.
* Fixed some bugs and made some improvements.

v1.8.0.0 (2007-06-15)

* Implemented IOCTL_SERIAL_XOFF_COUNTER.
* Added ability to hide port interfaces (plug-in and exclusive modes).
* Improved baudrate emulation.
* Fixed some bugs.

v1.7.0.0 (2006-12-14)

* Implemented installer.
* Implemented WMI functionality.
* Added the device interface registration.
* Fixed incompatibility with VMware.
* Fixed some bugs.

v1.6.0.0 (2006-06-29)

* Implemented flow control, replacement and handshaking functionality.
* Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF.
* Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF.
* Implemented IOCTL_SERIAL_GET_MODEM_CONTROL.

v1.5.0.0 (2005-12-29)

* Implemented SERIAL_EV_RXFLAG and SERIAL_EV_RX80FULL.
* Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS.
* Implemented IOCTL_SERIAL_IMMEDIATE_CHAR.
* Implemented IOCTL_SERIAL_GET_DTRRTS.
* Added stub for IOCTL_SERIAL_SET_XON.

v1.4.0.0 (2005-10-17)

* Implemented overrun emulation (configurable).
* Implemented SERIAL_EV_TXEMPTY.
* Implemented IRP_MJ_FLUSH_BUFFERS.
* Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.
* Fixed DeviceType typo (fopen problem).

v1.3.0.0 (2005-09-02)

* Implemented baudrate emulation.
* Fixed overlapped operations processing order.

v1.2.0.0 (2005-07-15)

* Fixed BSOD problem (#1237666).
* Made some improvements.

v1.1.1.0 (2005-06-23)

* Improved port numbering.

v1.1.0.0 (2005-05-18)

* Implemented IOCTL_SERIAL_LSRMST_INSERT.
* Implemented SERIAL_EV_RXCHAR
* Added ability to change the port names
* Fixed some bugs and made some improvements.

2005-02-21 - released v1.0.0.0.
2005-01-24 - project moved to http://com0com.sourceforge.net/.
2004       - project started.


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/trace.c

/*
 * $Id: trace.c,v 1.40 2011/12/15 06:17:12 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: trace.c,v $
 * Revision 1.40  2011/12/15 06:17:12  vfrolov
 * Removed usage undocumented PDRIVER_OBJECT->Type
 *
 * Revision 1.39  2011/07/26 16:06:33  vfrolov
 * Added PID tracing on IRP_MJ_CLOSE
 *
 * Revision 1.38  2011/07/12 18:22:02  vfrolov
 * Discarded WDM garbage (fixed timestamp localization)
 * Added IOCTL_SERIAL_SET_FIFO_CONTROL value tracing
 *
 * Revision 1.37  2010/08/09 05:51:16  vfrolov
 * Fixed BSOD on tracing broken IRP_MN_QUERY_DEVICE_RELATIONS
 *
 * Revision 1.36  2010/08/04 13:12:04  vfrolov
 * Fixed null string tracing
 *
 * Revision 1.35  2010/05/27 11:02:11  vfrolov
 * Added multiline tracing for IRP_MN_QUERY_ID
 *
 * Revision 1.34  2009/05/22 14:25:39  vfrolov
 * Optimized for trace disabled mode
 *
 * Revision 1.33  2009/05/20 13:35:36  vfrolov
 * United closely IRP function name printing code
 *
 * Revision 1.32  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.31  2008/06/10 11:24:20  vfrolov
 * Disabled tracing if traceFileName is empty
 *
 * Revision 1.30  2008/04/08 10:37:56  vfrolov
 * Implemented ability to set individual pins with extended
 * IOCTL_SERIAL_SET_MODEM_CONTROL and IOCTL_SERIAL_GET_MODEM_CONTROL
 *
 * Revision 1.29  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.28  2007/06/20 10:32:44  vfrolov
 * Added PID tracing on IRP_MJ_CREATE
 *
 * Revision 1.27  2007/06/05 12:26:38  vfrolov
 * Allocate trace buffers only if trace enabled
 *
 * Revision 1.26  2007/02/21 16:52:34  vfrolov
 * Added tracing of IRP_MJ_POWER with more details
 *
 * Revision 1.25  2007/02/20 12:01:47  vfrolov
 * Added result dumping SERIAL_XOFF_COUNTER
 *
 * Revision 1.24  2007/02/15 11:43:56  vfrolov
 * Added tracing SERIAL_XOFF_COUNTER
 *
 * Revision 1.23  2007/02/02 09:52:21  vfrolov
 * Fixed huge system error logging if bad trace file used
 *
 * Revision 1.22  2006/10/27 12:36:58  vfrolov
 * Removed unnecessary InterlockedExchange*()
 *
 * Revision 1.21  2006/08/23 13:05:43  vfrolov
 * Added ability to trace w/o table
 * Added tracing IRP_MN_QUERY_ID result
 * Added tracing GUID for IRP_MN_QUERY_INTERFACE
 * Added tracing WMI
 *
 * Revision 1.20  2006/06/08 11:30:52  vfrolov
 * Added params check to Trace0() and Trace00()
 *
 * Revision 1.19  2006/05/19 15:02:03  vfrolov
 * Implemented IOCTL_SERIAL_GET_MODEM_CONTROL
 *
 * Revision 1.18  2006/01/10 09:44:04  vfrolov
 * Added ability to enable/disable dump
 * Added tracing of HoldReasons, WaitForImmediate, AmountInOutQueue for SERIAL_STATUS
 *
 * Revision 1.17  2005/12/06 13:01:54  vfrolov
 * Implemented IOCTL_SERIAL_GET_DTRRTS
 *
 * Revision 1.16  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.15  2005/11/30 16:04:12  vfrolov
 * Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
 *
 * Revision 1.14  2005/09/28 10:06:42  vfrolov
 * Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION
 *
 * Revision 1.13  2005/09/13 08:55:41  vfrolov
 * Disabled modem status tracing by default
 *
 * Revision 1.12  2005/09/09 15:21:32  vfrolov
 * Added additional flushing for saved strings
 *
 * Revision 1.11  2005/09/06 06:58:20  vfrolov
 * Added SERIAL_STATUS.Errors tracing
 * Added version tracing
 *
 * Revision 1.10  2005/08/30 13:12:04  vfrolov
 * Disabled IOCTL_SERIAL_GET_MODEMSTATUS tracing by default
 *
 * Revision 1.9  2005/08/25 07:48:39  vfrolov
 * Changed type of code names from wchar to char
 * Fixed HandFlow tracing
 *
 * Revision 1.8  2005/08/23 15:28:26  vfrolov
 * Added build timestamp
 *
 * Revision 1.7  2005/07/14 13:51:09  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.6  2005/07/01 11:03:50  vfrolov
 * Included <stdarg.h>
 *
 * Revision 1.5  2005/05/19 08:23:41  vfrolov
 * Fixed data types
 *
 * Revision 1.4  2005/05/13 16:58:03  vfrolov
 * Implemented IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.3  2005/02/28 12:10:08  vfrolov
 * Log skipped lines to trace file (was to syslog)
 * Fixed missing trace file close
 *
 * Revision 1.2  2005/02/01 16:39:35  vfrolov
 * Added AnsiStrCopyCommStatus()
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"

#if ENABLE_TRACING

#include "version.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 4

/********************************************************************/
#include <stdarg.h>

#include "trace.h"
#include "strutils.h"
/********************************************************************/
#define TRACE_ERROR_LIMIT 10
#define TRACE_BUF_SIZE 256
#define TRACE_BUFS_NUM 8
#define TRACE_IRQL_BUF_SIZE 1024
/********************************************************************/
typedef struct _TRACE_BUFFER {
  BOOLEAN busy;
  CHAR buf[TRACE_BUF_SIZE];
} TRACE_BUFFER, *PTRACE_BUFFER;

typedef struct _TRACE_DATA {
  UNICODE_STRING traceFileName;

  struct {
    KSPIN_LOCK lock;
    TRACE_BUFFER bufs[TRACE_BUFS_NUM];
  } bufs;

  struct {
    KSPIN_LOCK lock;
    CHAR buf[TRACE_IRQL_BUF_SIZE];
    LONG busyInd;
    LONG freeInd;
  } irqlBuf;

  #define TRACE_ENABLE_IRP       0x00000001
  #define TRACE_ENABLE_DUMP      0x00000002

  #define TRACE_ENABLE_ALL       0xFFFFFFFF

  struct {
    ULONG read;
    ULONG write;
    ULONG getTimeouts;
    ULONG setTimeouts;
    ULONG getCommStatus;
    ULONG getModemStatus;
    ULONG modemStatus;
  } traceEnable;

  int errorCount;
  LONG skippedTraces;

} TRACE_DATA, *PTRACE_DATA;
/********************************************************************/
PTRACE_DATA pTraceData = NULL;
static PDRIVER_OBJECT pDrvObj;
/********************************************************************/
VOID QueryRegistryTrace(IN PUNICODE_STRING pRegistryPath)
{
  NTSTATUS status;
  UNICODE_STRING traceRegistryPath;
  RTL_QUERY_REGISTRY_TABLE queryTable[2];

  status = STATUS_SUCCESS;

  RtlInitUnicodeString(&traceRegistryPath, NULL);
  StrAppendStr(&status, &traceRegistryPath, pRegistryPath->Buffer, pRegistryPath->Length);
  StrAppendStr0(&status, &traceRegistryPath, L"\\Trace");

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"QueryRegistryTrace FAIL");
    return;
  }

  RtlZeroMemory(queryTable, sizeof(queryTable));

  if (pTraceData->traceFileName.Buffer) {
    RtlFreeUnicodeString(&pTraceData->traceFileName);
    RtlInitUnicodeString(&pTraceData->traceFileName, NULL);
  }

  queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
  queryTable[0].Name          = L"TraceFile";
  queryTable[0].EntryContext  = &pTraceData->traceFileName;

  status = RtlQueryRegistryValues(
      RTL_REGISTRY_ABSOLUTE,
      traceRegistryPath.Buffer,
      queryTable,
      NULL,
      NULL);

  StrFree(&traceRegistryPath);

  if (!NT_SUCCESS(status))
    RtlInitUnicodeString(&pTraceData->traceFileName, NULL);
}

VOID QueryRegistryTraceEnable(IN PUNICODE_STRING pRegistryPath)
{
  NTSTATUS status;
  UNICODE_STRING traceRegistryPath;
  RTL_QUERY_REGISTRY_TABLE queryTable[8];
  ULONG zero = 0;

  RtlZeroMemory(&pTraceData->traceEnable, sizeof(pTraceData->traceEnable));

  status = STATUS_SUCCESS;

  RtlInitUnicodeString(&traceRegistryPath, NULL);
  StrAppendStr(&status, &traceRegistryPath, pRegistryPath->Buffer, pRegistryPath->Length);
  StrAppendStr0(&status, &traceRegistryPath, L"\\Trace\\Enable");

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"QueryRegistryTraceEnable FAIL");
    return;
  }

  RtlZeroMemory(queryTable, sizeof(queryTable));

  queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[0].Name          = L"Read";
  queryTable[0].EntryContext  = &pTraceData->traceEnable.read;
  queryTable[0].DefaultType   = REG_DWORD;
  queryTable[0].DefaultData   = &zero;
  queryTable[0].DefaultLength = sizeof(ULONG);

  queryTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[1].Name          = L"Write";
  queryTable[1].EntryContext  = &pTraceData->traceEnable.write;
  queryTable[1].DefaultType   = REG_DWORD;
  queryTable[1].DefaultData   = &zero;
  queryTable[1].DefaultLength = sizeof(ULONG);

  queryTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[2].Name          = L"GetTimeouts";
  queryTable[2].EntryContext  = &pTraceData->traceEnable.getTimeouts;
  queryTable[2].DefaultType   = REG_DWORD;
  queryTable[2].DefaultData   = &zero;
  queryTable[2].DefaultLength = sizeof(ULONG);

  queryTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[3].Name          = L"SetTimeouts";
  queryTable[3].EntryContext  = &pTraceData->traceEnable.setTimeouts;
  queryTable[3].DefaultType   = REG_DWORD;
  queryTable[3].DefaultData   = &zero;
  queryTable[3].DefaultLength = sizeof(ULONG);

  queryTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[4].Name          = L"GetCommStatus";
  queryTable[4].EntryContext  = &pTraceData->traceEnable.getCommStatus;
  queryTable[4].DefaultType   = REG_DWORD;
  queryTable[4].DefaultData   = &zero;
  queryTable[4].DefaultLength = sizeof(ULONG);

  queryTable[5].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[5].Name          = L"GetModemStatus";
  queryTable[5].EntryContext  = &pTraceData->traceEnable.getModemStatus;
  queryTable[5].DefaultType   = REG_DWORD;
  queryTable[5].DefaultData   = &zero;
  queryTable[5].DefaultLength = sizeof(ULONG);

  queryTable[6].Flags         = RTL_QUERY_REGISTRY_DIRECT;
  queryTable[6].Name          = L"ModemStatus";
  queryTable[6].EntryContext  = &pTraceData->traceEnable.modemStatus;
  queryTable[6].DefaultType   = REG_DWORD;
  queryTable[6].DefaultData   = &zero;
  queryTable[6].DefaultLength = sizeof(ULONG);

  status = RtlQueryRegistryValues(
      RTL_REGISTRY_ABSOLUTE,
      traceRegistryPath.Buffer,
      queryTable,
      NULL,
      NULL);

  StrFree(&traceRegistryPath);
}
/********************************************************************/

PTRACE_BUFFER AllocTraceBuf()
{
  PTRACE_BUFFER pBuf;
  KIRQL oldIrql;
  int i;

  pBuf = NULL;

  KeAcquireSpinLock(&pTraceData->bufs.lock, &oldIrql);
  for (i = 0 ; i < TRACE_BUFS_NUM ; i++) {
    if (!pTraceData->bufs.bufs[i].busy) {
      pTraceData->bufs.bufs[i].busy = TRUE;
      pBuf = &pTraceData->bufs.bufs[i];
      break;
    }
  }
  KeReleaseSpinLock(&pTraceData->bufs.lock, oldIrql);

  if (!pBuf)
    InterlockedIncrement(&pTraceData->skippedTraces);

  return pBuf;
}

VOID FreeTraceBuf(PTRACE_BUFFER pBuf)
{
  HALT_UNLESS(pBuf);
  pBuf->busy = FALSE;
}
/********************************************************************/

PCHAR AnsiStrCopyStr(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PCHAR pStr)
{
  SIZE_T len, size;
  PCHAR pStrTmp;

  if (pStr == NULL)
    pStr = "(null)";

  pStrTmp = pStr;

  while (*(pStrTmp++))
    ;

  len = pStrTmp - pStr;
  size = *pSize;

  if (len > size)
    len = size;

  if (len) {
    RtlCopyMemory(pDestStr, pStr, len - 1);
    size -= len - 1;
    pDestStr += len - 1;
    *pDestStr = 0;
    *pSize = size;
  }
  return pDestStr;
}

PCHAR AnsiStrCopyStrW(
    PCHAR pDestStr,
    PSIZE_T pSize,
    PWCHAR pStr,
    BOOLEAN multiStr)
{
  SIZE_T len, size;
  PWCHAR pStrTmp;

  if (pStr == NULL)
    pStr = L"(null)" L"\0";

  pStrTmp = pStr;

  if (multiStr) {
    do {
      while (*(pStrTmp++))
        ;
    } while (*(pStrTmp++));
  }
  else {
    while (*(pStrTmp++))
      ;
  }

  len = pStrTmp - pStr;

  if (multiStr)
    len--;

  size = *pSize;

  if (len > size)
    len = size;

  if (len) {
    SIZE_T i;

    for (i = 0 ; i < len - 1 ; i++) {
      if (pStr[i] == 0)
        pDestStr[i] = '"';
      else
      if ((pStr[i] & 0xFF00) == 0)
        pDestStr[i] = (CHAR)(pStr[i]);
      else
        pDestStr[i] = '?';
    }

    size -= len - 1;
    pDestStr += len - 1;
    *pDestStr = 0;
    *pSize = size;
  }
  return pDestStr;
}

PCHAR AnsiStrCopyNum(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN ULONG num,
    IN ULONG base,
    int width)
{
  CHAR buf[sizeof(num) * 8 + 1];
  PCHAR pBuf;

  if (!(base > 0 && base <= 36))
    base = 10;

  pBuf = buf + sizeof(buf);
  *(--pBuf) = 0;

  do {
    ULONG d = num % base;
    *(--pBuf) = (CHAR)(d + ((d < 10) ? '0' : ('A' - 10)));
    num /= base;
    width--;
  } while (num);

  while (width-- > 0)
    pDestStr = AnsiStrCopyStr(pDestStr, pSize, "0");

  return AnsiStrCopyStr(pDestStr, pSize, pBuf);
}

PCHAR _AnsiStrVaFormat(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PCHAR pFmt,
    va_list va)
{
  SIZE_T size;

  size = *pSize;

  while (*pFmt) {
    BOOLEAN format;
    BOOLEAN l;
    BOOLEAN fail;
    int width;
    CHAR ch;

    ch = *(pFmt++);

    if (ch != '%') {
      CHAR buf[2];

      buf[0] = ch;
      buf[1] = 0;
      pDestStr = AnsiStrCopyStr(pDestStr, &size, buf);
      continue;
    }

    fail = FALSE;
    format = TRUE;
    l = FALSE;
    width = 0;

    while (*pFmt && format) {
      ch = *(pFmt++);

      switch (ch) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          width = width*10 + ch - '0';
          break;
        case 'l':
          l = TRUE;
          break;
        case 's': {
          PCHAR pStr = va_arg(va, PCHAR);
          pDestStr = AnsiStrCopyStr(pDestStr, &size, pStr);
          format = FALSE;
          break;
        }
        case 'S': {
          PWCHAR pStr = va_arg(va, PWCHAR);
          pDestStr = AnsiStrCopyStrW(pDestStr, &size, pStr, FALSE);
          format = FALSE;
          break;
        }
        case 'd': {
          LONG n;
          if (l)
            n = va_arg(va, long);
          else
            n = va_arg(va, int);
          if (n < 0) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, "-");
            n = -n;
          }
          pDestStr = AnsiStrCopyNum(pDestStr, &size, n, 10, width);
          format = FALSE;
          break;
        }
        case 'u': {
          ULONG n;
          if (l)
            n = va_arg(va, unsigned long);
          else
            n = va_arg(va, unsigned int);
          pDestStr = AnsiStrCopyNum(pDestStr, &size, n, 10, width);
          format = FALSE;
          break;
        }
        case 'x':
        case 'X': {
          ULONG n;
          if (l)
            n = va_arg(va, unsigned long);
          else
            n = va_arg(va, unsigned int);
          pDestStr = AnsiStrCopyNum(pDestStr, &size, n, 16, width);
          format = FALSE;
          break;
        }
        case '%':
          pDestStr = AnsiStrCopyStr(pDestStr, &size, "%");
          format = FALSE;
          break;
        default:
          fail = TRUE;
      }
      if (fail)
        break;
    }
    if (fail)
      break;
  }

  *pSize = size;
  return pDestStr;
}

PCHAR AnsiStrVaFormat(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PCHAR pFmt,
    va_list va)
{
  SIZE_T oldSize = *pSize;

  try {
    return _AnsiStrVaFormat(pDestStr, pSize, pFmt, va);
  } except (EXCEPTION_EXECUTE_HANDLER) {
    SysLogDrv(pDrvObj, GetExceptionCode(), L"AnsiStrVaFormat EXCEPTION");
    *pSize = oldSize;
    return pDestStr;
  }
}

PCHAR AnsiStrFormat(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PCHAR pFmt,
    ...)
{
  va_list va;

  va_start(va, pFmt);
  pDestStr = AnsiStrVaFormat(pDestStr, pSize, pFmt, va);
  va_end(va);

  return pDestStr;
}
/********************************************************************/

PCHAR code2name(
    IN ULONG code,
    IN PCODE2NAME pTable)
{
  if (!pTable)
    return NULL;

  while (pTable->name) {
    if (pTable->code == code)
      return pTable->name;
    pTable++;
  }

  return NULL;
}

PCHAR AnsiStrCopyCode(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN ULONG code,
    IN PCODE2NAME pTable,
    IN PCHAR pPref,
    IN ULONG base)
{
  PCHAR pStr;

  pStr = code2name(code, pTable);

  if (pStr) {
    pDestStr = AnsiStrCopyStr(pDestStr, pSize, pStr);
  } else {
    if (pPref)
      pDestStr = AnsiStrCopyStr(pDestStr, pSize, pPref);
    pDestStr = AnsiStrCopyNum(pDestStr, pSize, code, base, 0);
  }

  return pDestStr;
}

PCHAR AnsiStrCopyMask(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PCODE2NAME pTable,
    IN ULONG mask)
{
  ULONG b, unknown;
  int count;

  pDestStr = AnsiStrCopyStr(pDestStr, pSize, "[");

  unknown = 0;
  count = 0;

  for (b = 1 ; b ; b <<= 1) {
    if ((mask & b) != 0) {
      PCHAR pStr;

      pStr = code2name(b, pTable);

      if (pStr) {
        if (count)
          pDestStr = AnsiStrCopyStr(pDestStr, pSize, "|");
        pDestStr = AnsiStrCopyStr(pDestStr, pSize, pStr);
        count++;
      } else {
        unknown |= b;
      }
    }
  }

  if (unknown) {
    if (count)
      pDestStr = AnsiStrCopyStr(pDestStr, pSize, "|");
    pDestStr = AnsiStrFormat(pDestStr, pSize, "0x%lX", (long)unknown);
  }

  return AnsiStrCopyStr(pDestStr, pSize, "]");
}

PCHAR AnsiStrCopyFields(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PFIELD2NAME pTable,
    IN ULONG mask)
{
  int count = 0;

  pDestStr = AnsiStrCopyStr(pDestStr, pSize, "[");

  if (pTable) {
    while (pTable->name) {
      ULONG m = (mask & pTable->mask);

      if (m == pTable->code) {
        mask &= ~pTable->mask;
        if (count)
          pDestStr = AnsiStrCopyStr(pDestStr, pSize, "|");
        pDestStr = AnsiStrCopyStr(pDestStr, pSize, pTable->name);
        count++;
      }
      pTable++;
    }
  }

  if (mask) {
    if (count)
      pDestStr = AnsiStrCopyStr(pDestStr, pSize, "|");
    pDestStr = AnsiStrFormat(pDestStr, pSize, "0x%lX", (long)mask);
  }

  return AnsiStrCopyStr(pDestStr, pSize, "]");
}

PCHAR AnsiStrCopyDump(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PVOID pData,
    IN SIZE_T length)
{
#define DUMP_MAX 16
  CHAR bufA[DUMP_MAX + 1];
  SIZE_T i;

  pDestStr = AnsiStrFormat(pDestStr, pSize, "%lu:", (long)length);

  for (i = 0 ; i < length && i < DUMP_MAX ; i++) {
    UCHAR c = *(((PUCHAR)pData) + i);

    bufA[i] = (CHAR)((c >= 0x20 && c < 0x7F) ? c : '.');

    pDestStr = AnsiStrFormat(pDestStr, pSize, " %02X", (int)c);
  }

  bufA[i] = 0;

  return AnsiStrFormat(pDestStr, pSize, " * %s *", bufA);
}
/********************************************************************/

PCHAR AnsiStrCopyHead(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PCHAR pHead)
{
  if (pDevExt) {
    pDestStr = AnsiStrFormat(pDestStr, pSize, "%S/", pDevExt->portName);
    pDestStr = AnsiStrCopyCode(pDestStr, pSize, pDevExt->doType, codeNameTableDoType, NULL, 10);
  }
  if (pHead)
    pDestStr = AnsiStrFormat(pDestStr, pSize, pDevExt ? " %s" : "%s", pHead);

  return pDestStr;
}

PCHAR AnsiStrCopyHandFlow(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_HANDFLOW pHandFlow)
{
  pDestStr = AnsiStrCopyStr(pDestStr, pSize, " Hand");
  pDestStr = AnsiStrCopyFields(pDestStr, pSize,
      codeNameTableControlHandShake,
      pHandFlow->ControlHandShake);

  pDestStr = AnsiStrCopyStr(pDestStr, pSize, " Flow");
  pDestStr = AnsiStrCopyFields(pDestStr, pSize,
      codeNameTableFlowReplace,
      pHandFlow->FlowReplace);

  pDestStr = AnsiStrFormat(pDestStr, pSize, " XonLim=%lu XoffLim=%lu",
      (long)pHandFlow->XonLimit, (long)pHandFlow->XoffLimit);

  return pDestStr;
}

PCHAR AnsiStrCopyTimeouts(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_TIMEOUTS pTimeouts)
{
  return AnsiStrFormat(pDestStr, pSize,
      " Read[Interval=%lu Multiplier=%lu Constant=%lu]"
      " Write[Multiplier=%lu Constant=%lu]",
      (long)pTimeouts->ReadIntervalTimeout,
      (long)pTimeouts->ReadTotalTimeoutMultiplier,
      (long)pTimeouts->ReadTotalTimeoutConstant,
      (long)pTimeouts->WriteTotalTimeoutMultiplier,
      (long)pTimeouts->WriteTotalTimeoutConstant);
}

PCHAR AnsiStrCopyChars(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_CHARS pChars)
{
  return AnsiStrFormat(pDestStr, pSize,
      " EofChar=0x%X ErrorChar=0x%X BreakChar=0x%X"
      " EventChar=0x%X XonChar=0x%X XoffChar=0x%X",
      (int)pChars->EofChar, (int)pChars->ErrorChar, (int)pChars->BreakChar,
      (int)pChars->EventChar, (int)pChars->XonChar, (int)pChars->XoffChar);
}

PCHAR AnsiStrCopyLineControl(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_LINE_CONTROL pLineControl)
{
  return AnsiStrFormat(pDestStr, pSize,
      " StopBits=%u Parity=%u WordLength=%u",
      (int)pLineControl->StopBits,
      (int)pLineControl->Parity,
      (int)pLineControl->WordLength);
}

PCHAR AnsiStrCopyBaudRate(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_BAUD_RATE pBaudRate)
{
  return AnsiStrFormat(pDestStr, pSize, " BaudRate=%lu", (long)pBaudRate->BaudRate);
}

PCHAR AnsiStrCopyQueueSize(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_QUEUE_SIZE pQueueSize)
{
  return AnsiStrFormat(pDestStr, pSize,
      " InSize=%lu OutSize=%lu",
      (long)pQueueSize->InSize, (long)pQueueSize->OutSize);
}

PCHAR AnsiStrCopyXoffCounter(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_XOFF_COUNTER pXoffCounter)
{
  return AnsiStrFormat(pDestStr, pSize,
      " Timeout=%lu Counter=%ld XoffChar=0x%X",
      (long)pXoffCounter->Timeout, (long)pXoffCounter->Counter, (int)pXoffCounter->XoffChar);
}

PCHAR AnsiStrCopyCommStatus(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIAL_STATUS pCommStatus)
{
  pDestStr = AnsiStrCopyStr(pDestStr, pSize, " {");

  if (pCommStatus->Errors) {
    pDestStr = AnsiStrCopyStr(pDestStr, pSize, " Errors");
    pDestStr = AnsiStrCopyMask(pDestStr, pSize,
        codeNameTableErrors, pCommStatus->Errors);
  }

  if (pCommStatus->HoldReasons) {
    pDestStr = AnsiStrCopyStr(pDestStr, pSize, " HoldReasons");
    pDestStr = AnsiStrCopyMask(pDestStr, pSize,
        codeNameTableHoldReasons, pCommStatus->HoldReasons);
  }

  if (pCommStatus->WaitForImmediate)
    pDestStr = AnsiStrCopyStr(pDestStr, pSize, " WaitForImmediate=TRUE");

  if (pCommStatus->AmountInInQueue)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " AmountInInQueue=%lu", (long)pCommStatus->AmountInInQueue);

  if (pCommStatus->AmountInOutQueue)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " AmountInOutQueue=%lu", (long)pCommStatus->AmountInOutQueue);

  pDestStr = AnsiStrCopyStr(pDestStr, pSize, " }");
  return pDestStr;
}

PCHAR AnsiStrCopyPerfStats(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PSERIALPERF_STATS pPerfStats)
{
  pDestStr = AnsiStrCopyStr(pDestStr, pSize, " {");

  if (pPerfStats->ReceivedCount)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " ReceivedCount=%lu", (long)pPerfStats->ReceivedCount);

  if (pPerfStats->TransmittedCount)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " TransmittedCount=%lu", (long)pPerfStats->TransmittedCount);

  if (pPerfStats->FrameErrorCount)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " FrameErrorCount=%lu", (long)pPerfStats->FrameErrorCount);

  if (pPerfStats->SerialOverrunErrorCount)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " SerialOverrunErrorCount=%lu", (long)pPerfStats->SerialOverrunErrorCount);

  if (pPerfStats->BufferOverrunErrorCount)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " BufferOverrunErrorCount=%lu", (long)pPerfStats->BufferOverrunErrorCount);

  if (pPerfStats->ParityErrorCount)
    pDestStr = AnsiStrFormat(pDestStr, pSize,
        " ParityErrorCount=%lu", (long)pPerfStats->ParityErrorCount);

  pDestStr = AnsiStrCopyStr(pDestStr, pSize, " }");
  return pDestStr;
}
/********************************************************************/

VOID GetTimeFields(PTIME_FIELDS pTimeFields)
{
  LARGE_INTEGER systemTime;
  LARGE_INTEGER localTime;

  KeQuerySystemTime(&systemTime);
  ExSystemTimeToLocalTime(&systemTime, &localTime);

  RtlTimeToTimeFields(&localTime, pTimeFields);
}

PCHAR AnsiStrCopyTimeFields(
    PCHAR pDestStr,
    PSIZE_T pSize,
    IN PTIME_FIELDS pTimeFields)
{
  return AnsiStrFormat(pDestStr, pSize,
      "%04u/%02u/%02u %02u:%02u:%02u.%03u",
      (unsigned)pTimeFields->Year,
      (unsigned)pTimeFields->Month,
      (unsigned)pTimeFields->Day,
      (unsigned)pTimeFields->Hour,
      (unsigned)pTimeFields->Minute,
      (unsigned)pTimeFields->Second,
      (unsigned)pTimeFields->Milliseconds);
}
/********************************************************************/

NTSTATUS TraceWrite(
    IN HANDLE handle,
    IN PCHAR pStr)
{
  NTSTATUS status;
  ANSI_STRING str;
  IO_STATUS_BLOCK ioStatusBlock;

  RtlInitAnsiString(&str, pStr);

  status = ZwWriteFile(
      handle,
      NULL,
      NULL,
      NULL,
      &ioStatusBlock,
      str.Buffer,
      str.Length,
      NULL,
      NULL);

  if (!NT_SUCCESS(status)) {
    pTraceData->errorCount++;
    SysLogDrv(pDrvObj, status, L"TraceWrite ZwWriteFile FAIL");
  }

  return status;
}

VOID TraceOutput(IN PCHAR pStr)
{
  NTSTATUS status;
  HANDLE handle;
  OBJECT_ATTRIBUTES objectAttributes;
  IO_STATUS_BLOCK ioStatusBlock;

  if (pTraceData->errorCount > TRACE_ERROR_LIMIT) {
    if (pTraceData->errorCount < (TRACE_ERROR_LIMIT + 100)) {
      pTraceData->errorCount += 100;
      SysLogDrv(pDrvObj, STATUS_SUCCESS, L"Trace disabled");
    }
    return;
  }

  if (KeGetCurrentIrql() != PASSIVE_LEVEL) {
    SIZE_T size;
    KIRQL oldIrql;
    PCHAR pDestStr;
    TIME_FIELDS timeFields;

    if (!pStr)
      return;

    GetTimeFields(&timeFields);

    KeAcquireSpinLock(&pTraceData->irqlBuf.lock, &oldIrql);

    size = sizeof(pTraceData->irqlBuf.buf) - pTraceData->irqlBuf.freeInd;
    pDestStr = pTraceData->irqlBuf.buf + (sizeof(pTraceData->irqlBuf.buf) - size);

    pDestStr = AnsiStrCopyTimeFields(pDestStr, &size, &timeFields);
    pDestStr = AnsiStrFormat(pDestStr, &size, " *%u* %s\r\n", (unsigned)KeGetCurrentIrql(), pStr);
    HALT_UNLESS3(size > 0, pTraceData->irqlBuf.freeInd,
                 pTraceData->irqlBuf.busyInd, sizeof(pTraceData->irqlBuf.buf));

    if (size == 1) {
      pDestStr -= 6;
      size += 6;
      pDestStr = AnsiStrCopyStr(pDestStr, &size, " ...\r\n");
    }

    pTraceData->irqlBuf.freeInd = (LONG)(sizeof(pTraceData->irqlBuf.buf) - size);

    KeReleaseSpinLock(&pTraceData->irqlBuf.lock, oldIrql);

    return;
  }

  HALT_UNLESS(TRACE_FILE_OK);
  InitializeObjectAttributes(
      &objectAttributes,
      &pTraceData->traceFileName,
      OBJ_KERNEL_HANDLE,
      NULL,
      NULL);

  status = ZwCreateFile(
      &handle,
      SYNCHRONIZE | FILE_APPEND_DATA,
      &objectAttributes,
      &ioStatusBlock,
      NULL,
      FILE_ATTRIBUTE_NORMAL,
      FILE_SHARE_READ|FILE_SHARE_WRITE,
      FILE_OPEN_IF,
      FILE_SYNCHRONOUS_IO_NONALERT,
      NULL,
      0);

  if (NT_SUCCESS(status)) {
    PTRACE_BUFFER pBuf;

    pBuf = AllocTraceBuf();

    if (pBuf) {
      PCHAR pDestStr;
      SIZE_T size;
      LONG skipped;

      size = TRACE_BUF_SIZE;
      pDestStr = pBuf->buf;

      while (pTraceData->irqlBuf.freeInd) {
        SIZE_T lenBuf;
        KIRQL oldIrql;

        KeAcquireSpinLock(&pTraceData->irqlBuf.lock, &oldIrql);
        lenBuf = pTraceData->irqlBuf.freeInd - pTraceData->irqlBuf.busyInd;
        if (lenBuf) {
          if (lenBuf > size - 1)
            lenBuf = size - 1;
          RtlCopyMemory(pDestStr, &pTraceData->irqlBuf.buf[pTraceData->irqlBuf.busyInd], lenBuf);
          pDestStr[lenBuf] = 0;
          pTraceData->irqlBuf.busyInd += (LONG)lenBuf;
          HALT_UNLESS3(pTraceData->irqlBuf.busyInd <= pTraceData->irqlBuf.freeInd,
                       pTraceData->irqlBuf.freeInd, pTraceData->irqlBuf.busyInd, lenBuf);
          if (pTraceData->irqlBuf.busyInd == pTraceData->irqlBuf.freeInd)
            pTraceData->irqlBuf.freeInd = pTraceData->irqlBuf.busyInd = 0;
        }
        KeReleaseSpinLock(&pTraceData->irqlBuf.lock, oldIrql);

        if (lenBuf)
          TraceWrite(handle, pBuf->buf);
      }

      skipped = InterlockedExchange(&pTraceData->skippedTraces, 0);

      if (skipped) {
        SIZE_T tmp_size = size;

        AnsiStrFormat(pDestStr, &tmp_size, "*** skipped %lu lines ***\r\n", (long)skipped);
        TraceWrite(handle, pBuf->buf);
      }

      if (pStr) {
        TIME_FIELDS timeFields;

        GetTimeFields(&timeFields);

        pDestStr = AnsiStrCopyTimeFields(pDestStr, &size, &timeFields);
        pDestStr = AnsiStrFormat(pDestStr, &size, " %s\r\n", pStr);

        TraceWrite(handle, pBuf->buf);
      }

      FreeTraceBuf(pBuf);
    }

    status = ZwClose(handle);

    if (!NT_SUCCESS(status)) {
      pTraceData->errorCount++;
      SysLogDrv(pDrvObj, status, L"TraceOutput ZwClose FAIL");
    }
  }
  else {
    pTraceData->errorCount++;
    SysLogDrv(pDrvObj, status, L"TraceOutput ZwCreateFile FAIL");
  }
}
/********************************************************************/

VOID TraceF(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PCHAR pFmt,
    ...)
{
  PTRACE_BUFFER pBuf;
  PCHAR pDestStr;
  SIZE_T size;
  va_list va;

  HALT_UNLESS(TRACE_FILE_OK);

  pBuf = AllocTraceBuf();
  if (!pBuf)
    return;
  size = TRACE_BUF_SIZE;
  pDestStr = pBuf->buf;

  pDestStr = AnsiStrCopyHead(pDestStr, &size, pDevExt, NULL);
  pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");

  va_start(va, pFmt);
  pDestStr = AnsiStrVaFormat(pDestStr, &size, pFmt, va);
  va_end(va);

  TraceOutput(pBuf->buf);
  FreeTraceBuf(pBuf);
}
/********************************************************************/
VOID TraceDisable()
{
  if (pTraceData) {
    if (pTraceData->traceFileName.Buffer)
      RtlFreeUnicodeString(&pTraceData->traceFileName);

    C0C_FREE_POOL(pTraceData);
    pTraceData = NULL;
  }
}

VOID TraceOpen(
    IN PDRIVER_OBJECT _pDrvObj,
    IN PUNICODE_STRING pRegistryPath)
{
  pDrvObj = _pDrvObj;

  pTraceData = (PTRACE_DATA)C0C_ALLOCATE_POOL(NonPagedPool, sizeof(*pTraceData));

  if (!pTraceData) {
    SysLogDrv(pDrvObj, STATUS_INSUFFICIENT_RESOURCES, L"TraceEnable C0C_ALLOCATE_POOL FAIL");
    return;
  }

  RtlZeroMemory(pTraceData, sizeof(*pTraceData));

  KeInitializeSpinLock(&pTraceData->bufs.lock);
  KeInitializeSpinLock(&pTraceData->irqlBuf.lock);

  QueryRegistryTrace(pRegistryPath);
  QueryRegistryTraceEnable(pRegistryPath);

  if (!pTraceData->traceFileName.Buffer || !pTraceData->traceFileName.Length)
    TraceDisable();

  if (TRACE_FILE_OK) {
    UNICODE_STRING msg;
    NTSTATUS status;

    status = STATUS_SUCCESS;

    RtlInitUnicodeString(&msg, NULL);
    StrAppendStr0(&status, &msg, L"Trace enabled. See ");
    StrAppendStr(&status, &msg, pTraceData->traceFileName.Buffer, pTraceData->traceFileName.Length);

    if (NT_SUCCESS(status))
      SysLogDrv(pDrvObj, status, msg.Buffer);

    StrFree(&msg);

    TraceF(NULL, "===== BEGIN =====");
    TraceF(NULL, "VERSION " C0C_VERSION_STR " (" __DATE__ " " __TIME__ ")");

    if (pTraceData->errorCount) {
      TraceDisable();
      SysLogDrv(pDrvObj, STATUS_SUCCESS, L"Trace disabled");
    }
  }
}

VOID TraceClose()
{
  if (!TRACE_FILE_OK)
    return;

  TraceF(NULL, "===== END =====");

  TraceDisable();
}

VOID InternalTrace0(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PWCHAR pStr)
{
  if (!pStr)
    return;

  TraceF(pDevExt, "%S", pStr);
}

VOID InternalTrace00(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PWCHAR pStr1,
    IN PWCHAR pStr2)
{
  if (!pStr1 || !pStr2)
    return;

  TraceF(pDevExt, "%S%S", pStr1, pStr2);
}

VOID InternalTraceCode(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PCHAR pHead,
    IN PCODE2NAME pTable,
    IN ULONG code,
    IN PNTSTATUS pStatus)
{
  PTRACE_BUFFER pBuf;
  PCHAR pDestStr;
  SIZE_T size;

  HALT_UNLESS(TRACE_FILE_OK);

  pBuf = AllocTraceBuf();
  if (!pBuf)
    return;
  size = TRACE_BUF_SIZE;
  pDestStr = pBuf->buf;

  pDestStr = AnsiStrCopyHead(pDestStr, &size, pDevExt, pHead);
  pDestStr = AnsiStrCopyCode(pDestStr, &size, code, pTable, "0x", 16);

  if (pStatus) {
    pDestStr = AnsiStrCopyStr(pDestStr, &size, ", status=");
    pDestStr = AnsiStrCopyCode(pDestStr, &size, *pStatus, codeNameTableStatus, "0x", 16);
  }

  TraceOutput(pBuf->buf);
  FreeTraceBuf(pBuf);
}

VOID InternalTraceMask(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PCHAR pHead,
    IN PCODE2NAME pTable,
    IN ULONG mask)
{
  PTRACE_BUFFER pBuf;
  PCHAR pDestStr;
  SIZE_T size;

  HALT_UNLESS(TRACE_FILE_OK);

  pBuf = AllocTraceBuf();
  if (!pBuf)
    return;
  size = TRACE_BUF_SIZE;
  pDestStr = pBuf->buf;

  pDestStr = AnsiStrCopyHead(pDestStr, &size, pDevExt, pHead);
  pDestStr = AnsiStrCopyMask(pDestStr, &size, pTable, mask);

  TraceOutput(pBuf->buf);
  FreeTraceBuf(pBuf);
}

VOID InternalTraceModemStatus(IN PC0C_IO_PORT pIoPort)
{
  HALT_UNLESS(TRACE_FILE_OK);

  if (!pTraceData->traceEnable.modemStatus)
    return;

  TraceMask(
      (PC0C_COMMON_EXTENSION)pIoPort->pDevExt,
      "ModemStatus",
      codeNameTableModemStatus,
      pIoPort->modemStatus);
}

VOID InternalTraceIrp(
    IN PCHAR pHead,
    IN PIRP pIrp,
    IN PNTSTATUS pStatus,
    IN ULONG flags)
{
  PTRACE_BUFFER pBuf;
  PCHAR pDestStr;
  SIZE_T size;
  PIO_STACK_LOCATION pIrpStack;
  PC0C_COMMON_EXTENSION pDevExt;
  PVOID pSysBuf;
  ULONG_PTR inform;
  ULONG major;
  ULONG enableMask;

  HALT_UNLESS(TRACE_FILE_OK);

  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
  major = pIrpStack->MajorFunction;
  enableMask = TRACE_ENABLE_ALL;

  switch (major) {
    case IRP_MJ_WRITE:
      enableMask = pTraceData->traceEnable.write;
      break;
    case IRP_MJ_READ:
      enableMask = pTraceData->traceEnable.read;
      break;
    case IRP_MJ_DEVICE_CONTROL:
      switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_SERIAL_GET_TIMEOUTS:
          enableMask = pTraceData->traceEnable.getTimeouts;
          break;
        case IOCTL_SERIAL_SET_TIMEOUTS:
          enableMask = pTraceData->traceEnable.setTimeouts;
          break;
        case IOCTL_SERIAL_GET_COMMSTATUS:
          enableMask = pTraceData->traceEnable.getCommStatus;
          break;
        case IOCTL_SERIAL_GET_MODEMSTATUS:
          enableMask = pTraceData->traceEnable.getModemStatus;
          break;
      }
      break;
  }

  pDevExt = pIrpStack->DeviceObject->DeviceExtension;

  if (!(enableMask & TRACE_ENABLE_IRP)) {
    TraceOutput(NULL);
    return;
  }

  pBuf = AllocTraceBuf();
  if (!pBuf)
    return;
  size = TRACE_BUF_SIZE;
  pDestStr = pBuf->buf;

  pDestStr = AnsiStrCopyHead(pDestStr, &size, pDevExt, pHead);
  pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");

  switch (major) {
    case IRP_MJ_DEVICE_CONTROL:
      pDestStr = AnsiStrCopyCode(pDestStr, &size,
          pIrpStack->Parameters.DeviceIoControl.IoControlCode,
          codeNameTableIoctl, "IOCTL_", 16);
      break;
    case IRP_MJ_PNP:
      pDestStr = AnsiStrCopyCode(pDestStr, &size,
          pIrpStack->MinorFunction,
          codeNameTablePnp, "PNP_", 10);
      break;
    case IRP_MJ_POWER:
      pDestStr = AnsiStrCopyCode(pDestStr, &size,
          pIrpStack->MinorFunction,
          codeNameTablePower, "POWER_", 10);
      break;
    case IRP_MJ_SYSTEM_CONTROL:
      pDestStr = AnsiStrCopyCode(pDestStr, &size,
          pIrpStack->MinorFunction,
          codeNameTableWmi, "WMI_", 10);
      break;
    default:
      pDestStr = AnsiStrCopyCode(pDestStr, &size,
          major, codeNameTableIrpMj, "IRP_MJ_", 10);
  }

  /*
  if (pIrpStack->FileObject)
    pDestStr = AnsiStrFormat(pDestStr, &size, "(%lx)", PtrToUlong(pIrpStack->FileObject));
  */

  pSysBuf = pIrp->AssociatedIrp.SystemBuffer;
  inform = pIrp->IoStatus.Information;

  switch (major) {
    case IRP_MJ_CREATE:
    case IRP_MJ_CLOSE:
      pDestStr = AnsiStrFormat(pDestStr, &size, ", PID:%lu", PtrToUlong(PsGetCurrentProcessId()));
      break;
    case IRP_MJ_WRITE:
    case IRP_MJ_READ:
      if (flags & TRACE_FLAG_PARAMS) {
        ULONG length;

        if (major == IRP_MJ_WRITE)
          length = pIrpStack->Parameters.Write.Length;
        else
          length = pIrpStack->Parameters.Read.Length;
        pDestStr = AnsiStrFormat(pDestStr, &size, " length=%lu", (long)length);
      }
      if (flags & TRACE_FLAG_RESULTS) {
        pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
        if (enableMask & TRACE_ENABLE_DUMP)
          pDestStr = AnsiStrCopyDump(pDestStr, &size, pSysBuf, inform);
        else
          pDestStr = AnsiStrFormat(pDestStr, &size, "%lu", (long)inform);
      }
      break;
    case IRP_MJ_DEVICE_CONTROL: {
      ULONG inLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

      switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_SERIAL_GET_MODEMSTATUS:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTableModemStatus, *((PULONG)pSysBuf));
          }
          break;
        case IOCTL_SERIAL_SET_MODEM_CONTROL:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTableModemControl, *((PULONG)pSysBuf));

            if (inLength > sizeof(ULONG)) {
              pDestStr = AnsiStrCopyStr(pDestStr, &size, ", ");
              pDestStr = AnsiStrCopyDump(pDestStr, &size, ((PUCHAR)pSysBuf) + sizeof(ULONG), inLength - sizeof(ULONG));
            }
          }
          break;
        case IOCTL_SERIAL_GET_MODEM_CONTROL:
        case IOCTL_SERIAL_GET_DTRRTS:
          if ((flags & TRACE_FLAG_PARAMS) && inLength) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyDump(pDestStr, &size, pSysBuf, inLength);
          }
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTableModemControl, *((PULONG)pSysBuf));

            if (inform > sizeof(ULONG)) {
              pDestStr = AnsiStrCopyStr(pDestStr, &size, ", ");
              pDestStr = AnsiStrCopyDump(pDestStr, &size, ((PUCHAR)pSysBuf) + sizeof(ULONG), inform - sizeof(ULONG));
            }
          }
          break;
        case IOCTL_SERIAL_SET_FIFO_CONTROL:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(ULONG))
            pDestStr = AnsiStrFormat(pDestStr, &size, " 0x%lX", (long)*((PULONG)pSysBuf));
          break;
        case IOCTL_SERIAL_SET_WAIT_MASK:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTableWaitMask, *((PULONG)pSysBuf));
          }
          break;
        case IOCTL_SERIAL_GET_WAIT_MASK:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTableWaitMask, *((PULONG)pSysBuf));
          }
          break;
        case IOCTL_SERIAL_WAIT_ON_MASK:
          if ((flags & TRACE_FLAG_PARAMS) && pDevExt->doType == C0C_DOTYPE_FP) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size, codeNameTableWaitMask,
                ((PC0C_FDOPORT_EXTENSION)pDevExt)->pIoPortLocal->waitMask);
          }
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTableWaitMask, *((PULONG)pSysBuf));
          }
          break;
        case IOCTL_SERIAL_PURGE:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(ULONG)) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyMask(pDestStr, &size,
                codeNameTablePurgeMask, *((PULONG)pSysBuf));
          }
          break;
        case IOCTL_SERIAL_SET_HANDFLOW:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(SERIAL_HANDFLOW))
            pDestStr = AnsiStrCopyHandFlow(pDestStr, &size, (PSERIAL_HANDFLOW)pSysBuf);
          break;
        case IOCTL_SERIAL_GET_HANDFLOW:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIAL_HANDFLOW))
            pDestStr = AnsiStrCopyHandFlow(pDestStr, &size, (PSERIAL_HANDFLOW)pSysBuf);
          break;
        case IOCTL_SERIAL_SET_TIMEOUTS:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(SERIAL_TIMEOUTS))
            pDestStr = AnsiStrCopyTimeouts(pDestStr, &size, (PSERIAL_TIMEOUTS)pSysBuf);
          break;
        case IOCTL_SERIAL_GET_TIMEOUTS:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIAL_TIMEOUTS))
            pDestStr = AnsiStrCopyTimeouts(pDestStr, &size, (PSERIAL_TIMEOUTS)pSysBuf);
          break;
        case IOCTL_SERIAL_SET_CHARS:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(SERIAL_CHARS))
            pDestStr = AnsiStrCopyChars(pDestStr, &size, (PSERIAL_CHARS)pSysBuf);
          break;
        case IOCTL_SERIAL_GET_CHARS:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIAL_CHARS))
            pDestStr = AnsiStrCopyChars(pDestStr, &size, (PSERIAL_CHARS)pSysBuf);
          break;
        case IOCTL_SERIAL_SET_LINE_CONTROL:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(SERIAL_LINE_CONTROL))
            pDestStr = AnsiStrCopyLineControl(pDestStr, &size, (PSERIAL_LINE_CONTROL)pSysBuf);
          break;
        case IOCTL_SERIAL_GET_LINE_CONTROL:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIAL_LINE_CONTROL))
            pDestStr = AnsiStrCopyLineControl(pDestStr, &size, (PSERIAL_LINE_CONTROL)pSysBuf);
          break;
        case IOCTL_SERIAL_SET_BAUD_RATE:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(SERIAL_BAUD_RATE))
            pDestStr = AnsiStrCopyBaudRate(pDestStr, &size, (PSERIAL_BAUD_RATE)pSysBuf);
          break;
        case IOCTL_SERIAL_GET_BAUD_RATE:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIAL_BAUD_RATE))
            pDestStr = AnsiStrCopyBaudRate(pDestStr, &size, (PSERIAL_BAUD_RATE)pSysBuf);
          break;
        case IOCTL_SERIAL_SET_QUEUE_SIZE:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(SERIAL_QUEUE_SIZE))
            pDestStr = AnsiStrCopyQueueSize(pDestStr, &size, (PSERIAL_QUEUE_SIZE)pSysBuf);
          break;
        case IOCTL_SERIAL_GET_COMMSTATUS:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIAL_STATUS))
            pDestStr = AnsiStrCopyCommStatus(pDestStr, &size, (PSERIAL_STATUS)pSysBuf);
          break;
        case IOCTL_SERIAL_LSRMST_INSERT:
          if ((flags & TRACE_FLAG_PARAMS) && inLength >= sizeof(UCHAR)) {
            pDestStr = AnsiStrFormat(pDestStr, &size, " escapeChar=0x%02X", (int)(*(PUCHAR)pSysBuf & 0xFF));

            if (inLength > sizeof(UCHAR)) {
              pDestStr = AnsiStrCopyStr(pDestStr, &size, ", ");
              pDestStr = AnsiStrCopyDump(pDestStr, &size, ((PUCHAR)pSysBuf) + sizeof(UCHAR), inLength - sizeof(UCHAR));
            }
          }
          if ((flags & TRACE_FLAG_RESULTS) && inform) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyDump(pDestStr, &size, pSysBuf, inform);
          }
          break;
        case IOCTL_SERIAL_GET_STATS:
          if ((flags & TRACE_FLAG_RESULTS) && inform >= sizeof(SERIALPERF_STATS))
            pDestStr = AnsiStrCopyPerfStats(pDestStr, &size, (PSERIALPERF_STATS)pSysBuf);
          break;
        case IOCTL_SERIAL_IMMEDIATE_CHAR:
          if (flags & TRACE_FLAG_RESULTS) {
            pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
            pDestStr = AnsiStrCopyDump(pDestStr, &size, pSysBuf, inform);
          }
          break;
        case IOCTL_SERIAL_XOFF_COUNTER:
          if (inLength >= sizeof(SERIAL_XOFF_COUNTER)) {
            if ((flags & TRACE_FLAG_PARAMS))
              pDestStr = AnsiStrCopyXoffCounter(pDestStr, &size, (PSERIAL_XOFF_COUNTER)pSysBuf);
            if (flags & TRACE_FLAG_RESULTS) {
              pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
              if (enableMask & TRACE_ENABLE_DUMP)
                pDestStr = AnsiStrCopyDump(pDestStr, &size, &((PSERIAL_XOFF_COUNTER)pSysBuf)->XoffChar, inform);
              else
                pDestStr = AnsiStrFormat(pDestStr, &size, "%lu", (long)inform);
            }
          }
          break;
      }
      break;
    }
    case IRP_MJ_PNP:
      switch (pIrpStack->MinorFunction) {
        case IRP_MN_QUERY_ID:
          pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
          pDestStr = AnsiStrCopyCode(pDestStr, &size,
              pIrpStack->Parameters.QueryId.IdType,
              codeNameTableBusQuery, "BusQuery", 10);
          if ((flags & TRACE_FLAG_RESULTS) && inform) {
            BOOLEAN multiStr;

            pDestStr = AnsiStrCopyStr(pDestStr, &size, " Information: '");

            switch (pIrpStack->Parameters.QueryId.IdType) {
              case BusQueryHardwareIDs:
              case BusQueryCompatibleIDs:
                multiStr = TRUE;
                break;
              default:
                multiStr = FALSE;
            }
            pDestStr = AnsiStrCopyStrW(pDestStr, &size,
                (PWCHAR)inform,
                multiStr);

            pDestStr = AnsiStrCopyStr(pDestStr, &size, "'");
          }
          break;
        case IRP_MN_QUERY_DEVICE_TEXT:
          pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
          pDestStr = AnsiStrCopyCode(pDestStr, &size,
              pIrpStack->Parameters.QueryDeviceText.DeviceTextType,
              codeNameTableDeviceText, "DeviceText", 10);
          if ((flags & TRACE_FLAG_RESULTS) && inform) {
            pDestStr = AnsiStrFormat(pDestStr, &size,
                " Information: \"%S\"",
                (PWCHAR)inform);
          }
          break;
        case IRP_MN_QUERY_DEVICE_RELATIONS:
          pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
          pDestStr = AnsiStrCopyCode(pDestStr, &size,
              pIrpStack->Parameters.QueryDeviceRelations.Type,
              codeNameTableRelations, "Relations", 10);
          if ((flags & TRACE_FLAG_RESULTS) && inform) {
            switch (pIrpStack->Parameters.QueryDeviceRelations.Type) {
              case BusRelations:
              case EjectionRelations:
              case PowerRelations:
              case RemovalRelations:
              case TargetDeviceRelation:
                pDestStr = AnsiStrFormat(pDestStr, &size, " Count=%u", (unsigned)((PDEVICE_RELATIONS)inform)->Count);
            }
          }
          break;
        case IRP_MN_QUERY_INTERFACE:
          pDestStr = AnsiStrFormat(pDestStr, &size,
              " GUID: %8lX-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X",
              (long)pIrpStack->Parameters.QueryInterface.InterfaceType->Data1,
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data2,
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data3,
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[0],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[1],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[2],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[3],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[4],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[5],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[6],
              (int)pIrpStack->Parameters.QueryInterface.InterfaceType->Data4[7]);
          break;
      }
      break;
    case IRP_MJ_POWER:
      if ((flags & TRACE_FLAG_PARAMS) == 0)
        break;

      switch (pIrpStack->MinorFunction) {
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER: {
          POWER_STATE_TYPE powerType = pIrpStack->Parameters.Power.Type;
          POWER_STATE powerState = pIrpStack->Parameters.Power.State;

          pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
          pDestStr = AnsiStrCopyCode(pDestStr, &size, powerType, codeNameTablePowerType, "Type_", 10);
          pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");

          switch (powerType) {
            case DevicePowerState:
              pDestStr = AnsiStrCopyCode(pDestStr, &size, powerState.DeviceState,
                                         codeNameTableDevicePowerState, "State_", 10);
              break;
            case SystemPowerState:
              pDestStr = AnsiStrCopyCode(pDestStr, &size, powerState.SystemState,
                                         codeNameTableSystemPowerState, "State_", 10);
              break;
            default:
              pDestStr = AnsiStrCopyCode(pDestStr, &size, powerState.SystemState, NULL, "State_", 10);
              break;
          }

          pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
          pDestStr = AnsiStrCopyCode(pDestStr, &size, pIrpStack->Parameters.Power.ShutdownType,
                                     codeNameTablePowerAction, "Action_", 10);
          break;
        }
        case IRP_MN_WAIT_WAKE: {
          SYSTEM_POWER_STATE powerState = pIrpStack->Parameters.WaitWake.PowerState;

          pDestStr = AnsiStrCopyStr(pDestStr, &size, " Sys ");
          pDestStr = AnsiStrCopyCode(pDestStr, &size, powerState, codeNameTableSystemPowerState, "State_", 10);
          break;
        }
      }
      break;
    case IRP_MJ_QUERY_INFORMATION: {
      ULONG code = pIrpStack->Parameters.QueryFile.FileInformationClass;

      pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
      pDestStr = AnsiStrCopyCode(pDestStr, &size, code, codeNameTableFileInformationClass, NULL, 10);
      break;
    }
    case IRP_MJ_SET_INFORMATION: {
      ULONG code = pIrpStack->Parameters.SetFile.FileInformationClass;

      pDestStr = AnsiStrCopyStr(pDestStr, &size, " ");
      pDestStr = AnsiStrCopyCode(pDestStr, &size, code, codeNameTableFileInformationClass, NULL, 10);
      break;
    }
  }

  if (pStatus) {
    pDestStr = AnsiStrCopyStr(pDestStr, &size, ", status=");
    pDestStr = AnsiStrCopyCode(pDestStr, &size, *pStatus, codeNameTableStatus, "0x", 16);
  }

  TraceOutput(pBuf->buf);
  FreeTraceBuf(pBuf);
}
/********************************************************************/

#else /* ENABLE_TRACING */
  #pragma warning(disable:4206) // nonstandard extension used : translation unit is empty
#endif /* ENABLE_TRACING */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/noise.h

/*
 * $Id: noise.h,v 1.2 2008/10/30 07:54:37 vfrolov Exp $
 *
 * Copyright (c) 2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: noise.h,v $
 * Revision 1.2  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.1  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 */

#ifndef _C0C_NOISE_H_
#define _C0C_NOISE_H_

VOID BreakError(PC0C_IO_PORT pReadIoPort, PUCHAR pLsr);
UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr);
VOID BrokeChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pChar, PUCHAR pLsr);
SIZE_T GetBrokenChars(ULONG brokeCharsProbability, SIZE_T chars);

#endif /* _C0C_NOISE_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/pinouts.c

/*
 * $Id: pinouts.c,v 1.5 2008/06/26 13:37:10 vfrolov Exp $
 *
 * Copyright (c) 2007-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: pinouts.c,v $
 * Revision 1.5  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.4  2008/04/08 06:47:37  vfrolov
 * Added pin OUT2
 *
 * Revision 1.3  2007/10/19 16:03:41  vfrolov
 * Added default values
 *
 * Revision 1.2  2007/09/17 14:31:06  vfrolov
 * Implemented pseudo pin OPEN
 *
 * Revision 1.1  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 */

#include "precomp.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 0xE

VOID SetModemControl(
    IN PC0C_IO_PORT pIoPort,
    IN UCHAR bits,
    IN UCHAR mask,
    PLIST_ENTRY pQueueToComplete)
{
  UCHAR modemControlOld;
  UCHAR modemControlNew;
  UCHAR modemControlChanged;

  modemControlOld = modemControlNew = pIoPort->modemControl;

  modemControlNew |= bits & mask;
  modemControlNew &= ~(~bits & mask);

  modemControlChanged = modemControlOld ^ modemControlNew;

  if (modemControlChanged) {
    UCHAR bitsStatusRemote, maskStatusRemote;
    UCHAR bitsStatusLocal, maskStatusLocal;

    pIoPort->modemControl = modemControlNew;

    bitsStatusRemote = maskStatusRemote = 0;
    bitsStatusLocal = maskStatusLocal = 0;

    #define SET_PIN_OUTS(pin) \
    if (modemControlChanged & C0C_MCR_##pin) { \
      maskStatusRemote |= pIoPort->pinOuts[C0C_PIN_OUTS_##pin].remote.positive | \
                          pIoPort->pinOuts[C0C_PIN_OUTS_##pin].remote.negative; \
      maskStatusLocal |= pIoPort->pinOuts[C0C_PIN_OUTS_##pin].local.positive | \
                         pIoPort->pinOuts[C0C_PIN_OUTS_##pin].local.negative; \
      if (modemControlNew & C0C_MCR_##pin) { \
        bitsStatusRemote |= pIoPort->pinOuts[C0C_PIN_OUTS_##pin].remote.positive; \
        bitsStatusLocal |= pIoPort->pinOuts[C0C_PIN_OUTS_##pin].local.positive; \
      } else { \
        bitsStatusRemote |= pIoPort->pinOuts[C0C_PIN_OUTS_##pin].remote.negative; \
        bitsStatusLocal |= pIoPort->pinOuts[C0C_PIN_OUTS_##pin].local.negative; \
      } \
    }

    SET_PIN_OUTS(RTS);
    SET_PIN_OUTS(DTR);
    SET_PIN_OUTS(OUT1);
    SET_PIN_OUTS(OUT2);
    SET_PIN_OUTS(OPEN);

    #undef SET_PIN_OUTS

    if (maskStatusRemote)
      SetModemStatus(pIoPort->pIoPortRemote, bitsStatusRemote, maskStatusRemote, pQueueToComplete);

    if (maskStatusLocal)
      SetModemStatus(pIoPort, bitsStatusLocal, maskStatusLocal, pQueueToComplete);
  }
}

VOID PinWire(
    PC0C_IO_PORT pIoPortLocal,
    PC0C_IO_PORT pIoPortRemote,
    ULONG pinSrc,
    UCHAR pinDst,
    PUCHAR pModemStatus)
{
  switch (pinSrc) {
    case C0C_PIN_ON:
      *pModemStatus |= pinDst;
      break;
    case C0C_PIN_ON|C0C_PIN_NEGATIVE:
      *pModemStatus &= ~pinDst;
      break;

    #define CASE_PIN(pin) \
    case C0C_PIN_R##pin: \
      pIoPortRemote->pinOuts[C0C_PIN_OUTS_##pin].remote.positive |= pinDst; \
      if (pIoPortRemote->modemControl & C0C_MCR_##pin) \
        *pModemStatus |= pinDst; \
      else \
        *pModemStatus &= ~pinDst; \
      break; \
    case C0C_PIN_L##pin: \
      pIoPortLocal->pinOuts[C0C_PIN_OUTS_##pin].local.positive |= pinDst; \
      if (pIoPortLocal->modemControl & C0C_MCR_##pin) \
        *pModemStatus |= pinDst; \
      else \
        *pModemStatus &= ~pinDst; \
      break; \
    case C0C_PIN_R##pin|C0C_PIN_NEGATIVE: \
      pIoPortRemote->pinOuts[C0C_PIN_OUTS_##pin].remote.negative |= pinDst; \
      if (pIoPortRemote->modemControl & C0C_MCR_##pin) \
        *pModemStatus &= ~pinDst; \
      else \
        *pModemStatus |= pinDst; \
      break; \
    case C0C_PIN_L##pin|C0C_PIN_NEGATIVE: \
      pIoPortLocal->pinOuts[C0C_PIN_OUTS_##pin].local.negative |= pinDst; \
      if (pIoPortLocal->modemControl & C0C_MCR_##pin) \
        *pModemStatus &= ~pinDst; \
      else \
        *pModemStatus |= pinDst; \
      break;

    CASE_PIN(RTS)
    CASE_PIN(DTR)
    CASE_PIN(OUT1)
    CASE_PIN(OUT2)
    CASE_PIN(OPEN)

    #undef CASE_PIN
  }
}

VOID PinMap(
    IN PC0C_IO_PORT pIoPort,
    IN ULONG pinCTS,
    IN ULONG pinDSR,
    IN ULONG pinDCD,
    IN ULONG pinRI)
{
  PC0C_IO_PORT pIoPortRemote;
  int i;

  for (i = 0 ; i < sizeof(pIoPort->pinOuts)/sizeof(pIoPort->pinOuts[0]) ; i++)
    RtlZeroMemory(&pIoPort->pinOuts[i].local, sizeof(pIoPort->pinOuts[i].local));

  pIoPortRemote = pIoPort->pIoPortRemote;

  for (i = 0 ; i < sizeof(pIoPortRemote->pinOuts)/sizeof(pIoPortRemote->pinOuts[0]) ; i++)
    RtlZeroMemory(&pIoPortRemote->pinOuts[i].remote, sizeof(pIoPortRemote->pinOuts[i].remote));

  PinWire(pIoPort, pIoPortRemote, pinCTS, C0C_MSB_CTS, &pIoPort->modemStatus);
  PinWire(pIoPort, pIoPortRemote, pinDSR, C0C_MSB_DSR, &pIoPort->modemStatus);
  PinWire(pIoPort, pIoPortRemote, pinDCD, C0C_MSB_RLSD, &pIoPort->modemStatus);
  PinWire(pIoPort, pIoPortRemote, pinRI, C0C_MSB_RING, &pIoPort->modemStatus);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/pnp.c

/*
 * $Id: pnp.c,v 1.14 2011/12/27 11:23:11 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: pnp.c,v $
 * Revision 1.14  2011/12/27 11:23:11  vfrolov
 * Changed DeviceTextDescription
 *
 * Revision 1.13  2010/07/29 12:10:04  vfrolov
 * Added handling of IRPs that must be handled
 *
 * Revision 1.12  2010/07/21 07:39:01  vfrolov
 * Added handling of IRPs that all PnP drivers must handle
 *
 * Revision 1.11  2010/07/20 07:00:16  vfrolov
 * Fixed memory leak
 *
 * Revision 1.10  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.9  2007/11/23 08:58:48  vfrolov
 * Added UniqueID capability
 *
 * Revision 1.8  2007/06/04 15:24:33  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.7  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.6  2007/01/11 14:50:29  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.5  2006/06/23 07:37:24  vfrolov
 * Disabled usage pDevExt after deleting device
 * Added check of openCount to IRP_MN_QUERY_REMOVE_DEVICE
 *
 * Revision 1.4  2005/07/14 13:51:07  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.3  2005/06/28 12:25:34  vfrolov
 * Implemented IRP_MN_QUERY_CAPABILITIES and IRP_MN_QUERY_BUS_INFORMATION for PdoPortPnp()
 *
 * Revision 1.2  2005/05/17 15:06:18  vfrolov
 * Fixed type cast
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include <initguid.h>
#include "strutils.h"
#include "showport.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 5

/*
 * {E74D3627-7582-48a6-8B0B-ED60CE908A51}
 */
DEFINE_GUID(GUID_C0C_BUS_TYPE,
    0xe74d3627, 0x7582, 0x48a6, 0x8b, 0xb, 0xed, 0x60, 0xce, 0x90, 0x8a, 0x51);

NTSTATUS FdoBusPnp(
    IN PC0C_FDOBUS_EXTENSION pDevExt,
    IN PIRP                  pIrp)
{
  NTSTATUS status;
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
  ULONG minorFunction = pIrpStack->MinorFunction;
  PDEVICE_OBJECT pLowDevObj = pDevExt->pLowDevObj; // IRP_MN_REMOVE_DEVICE deletes *pDevExt!

  status = STATUS_SUCCESS;

  switch (minorFunction) {
  case IRP_MN_QUERY_DEVICE_RELATIONS:
    if (pIrpStack->Parameters.QueryDeviceRelations.Type == BusRelations) {
      ULONG countPdos, countRelations;
      PDEVICE_RELATIONS pRelationsPrev, pRelations;
      int i;

      countPdos = 0;
      for (i = 0 ; i < 2 ; i++) {
        if (pDevExt->childs[i].pDevExt)
          countPdos++;
      }

      if (!countPdos)
        break;

      pRelationsPrev = (PDEVICE_RELATIONS)pIrp->IoStatus.Information;
      countRelations = pRelationsPrev ? pRelationsPrev->Count : 0;

      pRelations = (PDEVICE_RELATIONS)C0C_ALLOCATE_POOL(PagedPool,
        sizeof(DEVICE_RELATIONS) + ((countPdos + countRelations - 1) * sizeof (PDEVICE_OBJECT)));

      if (!pRelations) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        break;
      }

      if (countRelations)
        RtlCopyMemory(pRelations->Objects, pRelationsPrev->Objects,
                                      countRelations * sizeof (PDEVICE_OBJECT));

      for (i = 0 ; i < 2 ; i++) {
        PC0C_PDOPORT_EXTENSION  pPhDevExt;

        pPhDevExt = pDevExt->childs[i].pDevExt;

        if (pPhDevExt) {
          if (!pDevExt->childs[i].ioPort.pDevExt) {
            UNICODE_STRING portName;
            UNICODE_STRING portRegistryPath;

            RtlInitUnicodeString(&portRegistryPath, NULL);
            StrAppendPortParametersRegistryPath(&status, &portRegistryPath, pPhDevExt->portName);

            RtlInitUnicodeString(&portName, NULL);
            StrAppendParameterPortName(&status, &portName, portRegistryPath.Buffer);

            StrFree(&portRegistryPath);

            if (NT_SUCCESS(status) && portName.Length &&
                _wcsicmp(C0C_PORT_NAME_COMCLASS, portName.Buffer) == 0)
            {
              pDevExt->childs[i].ioPort.isComClass = TRUE;
              Trace0((PC0C_COMMON_EXTENSION)pPhDevExt, L"Port class set to COM");
            } else {
              pDevExt->childs[i].ioPort.isComClass = FALSE;
              Trace0((PC0C_COMMON_EXTENSION)pPhDevExt, L"Port class set to CNC");
            }

            StrFree(&portName);

            status = STATUS_SUCCESS;
          }

          pRelations->Objects[countRelations++] = pPhDevExt->pDevObj;
          ObReferenceObject(pPhDevExt->pDevObj);
        }
      }

      pRelations->Count = countRelations;

      if (pRelationsPrev)
        ExFreePool(pRelationsPrev);

      pIrp->IoStatus.Information = (ULONG_PTR)pRelations;
      pIrp->IoStatus.Status = STATUS_SUCCESS;
    }
    break;
  case IRP_MN_REMOVE_DEVICE:
    RemoveFdoBus(pDevExt);
    pDevExt = NULL;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    break;
  case IRP_MN_START_DEVICE:
  case IRP_MN_STOP_DEVICE:
  case IRP_MN_QUERY_STOP_DEVICE:
  case IRP_MN_CANCEL_STOP_DEVICE:
  case IRP_MN_QUERY_REMOVE_DEVICE:
  case IRP_MN_CANCEL_REMOVE_DEVICE:
  case IRP_MN_SURPRISE_REMOVAL:
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    break;
  }

  if (status == STATUS_SUCCESS) {
    TraceIrp("FdoBusPnp", pIrp, NULL, TRACE_FLAG_RESULTS);

    IoSkipCurrentIrpStackLocation(pIrp);
    status = IoCallDriver(pLowDevObj, pIrp);

    TraceCode((PC0C_COMMON_EXTENSION)pDevExt, "PNP ", codeNameTablePnp, minorFunction, &status);
  } else {
    TraceIrp("PNP", pIrp, &status, TRACE_FLAG_RESULTS);

    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}

NTSTATUS PdoPortQueryId(
    IN PC0C_PDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp,
    IN PIO_STACK_LOCATION     pIrpStack)
{
  NTSTATUS status;
  PWCHAR pIDs = NULL;

  switch (pIrpStack->Parameters.QueryId.IdType) {
  case BusQueryDeviceID:
    status = DupStrW(&pIDs, C0C_PORT_DEVICE_ID, FALSE);
    break;
  case BusQueryHardwareIDs:
    status = DupStrW(
        &pIDs,
        (pDevExt->pIoPortLocal && pDevExt->pIoPortLocal->isComClass) ?
            C0C_PORT_HARDWARE_IDS_COMCLASS :
            C0C_PORT_HARDWARE_IDS_CNCCLASS,
        TRUE);
    break;
  case BusQueryCompatibleIDs:
    status = DupStrW(&pIDs, L"\0", TRUE);
    break;
  case BusQueryInstanceID:
    status = DupStrW(&pIDs, pDevExt->portName, FALSE);
    break;
  default:
    status = pIrp->IoStatus.Status;
  }

  pIrp->IoStatus.Information = (ULONG_PTR)pIDs;

  return status;
}

NTSTATUS PdoPortQueryCaps(
    IN PC0C_PDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp,
    IN PIO_STACK_LOCATION     pIrpStack)
{
  PDEVICE_CAPABILITIES pCaps = pIrpStack->Parameters.DeviceCapabilities.Capabilities;

  UNREFERENCED_PARAMETER(pDevExt);
  UNREFERENCED_PARAMETER(pIrp);

  if (pCaps->Version != 1 || pCaps->Size < sizeof(DEVICE_CAPABILITIES))
    return STATUS_UNSUCCESSFUL;

  pCaps->UniqueID = TRUE;

  pCaps->Address = pCaps->UINumber =
    (pDevExt->pIoPortLocal == &pDevExt->pBusExt->childs[0].ioPort ? 0 : 1);

  return STATUS_SUCCESS;
}

NTSTATUS PdoPortQueryDevText(
    IN PC0C_PDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp,
    IN PIO_STACK_LOCATION     pIrpStack)
{
  NTSTATUS status;

  status = STATUS_SUCCESS;

  switch (pIrpStack->Parameters.QueryDeviceText.DeviceTextType) {
  case DeviceTextDescription:
    if (!pIrp->IoStatus.Information) {
      UNICODE_STRING portText;

      RtlInitUnicodeString(&portText, NULL);
      StrAppendStr0(&status, &portText, L"com0com - serial port emulator");

      if (NT_SUCCESS(status))
        pIrp->IoStatus.Information = (ULONG_PTR)portText.Buffer;
    }
    break;
  case DeviceTextLocationInformation:
    if (!pIrp->IoStatus.Information) {
      UNICODE_STRING portText;

      RtlInitUnicodeString(&portText, NULL);
      StrAppendStr0(&status, &portText, pDevExt->portName);

      if (NT_SUCCESS(status))
        pIrp->IoStatus.Information = (ULONG_PTR)portText.Buffer;
    }
    break;
  default:
    status = pIrp->IoStatus.Status;
  }

  return status;
}

NTSTATUS PdoPortBusInfo(
    IN PC0C_PDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp)
{
  PPNP_BUS_INFORMATION pBusInfo;

  pBusInfo = (PPNP_BUS_INFORMATION)C0C_ALLOCATE_POOL(PagedPool, sizeof(PNP_BUS_INFORMATION));

  if (!pBusInfo)
    return STATUS_INSUFFICIENT_RESOURCES;

  pBusInfo->BusTypeGuid = GUID_C0C_BUS_TYPE;
  pBusInfo->LegacyBusType = PNPBus;
  pBusInfo->BusNumber = pDevExt->pBusExt->portNum;

  pIrp->IoStatus.Information = (ULONG_PTR)pBusInfo;

  return STATUS_SUCCESS;
}

NTSTATUS PdoPortPnp(
    IN PC0C_PDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp)
{
  NTSTATUS status = pIrp->IoStatus.Status;
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  switch (pIrpStack->MinorFunction) {
  case IRP_MN_QUERY_ID:
    status = PdoPortQueryId(pDevExt, pIrp, pIrpStack);
    break;
  case IRP_MN_QUERY_CAPABILITIES:
    status = PdoPortQueryCaps(pDevExt, pIrp, pIrpStack);
    break;
  case IRP_MN_QUERY_DEVICE_TEXT:
    status = PdoPortQueryDevText(pDevExt, pIrp, pIrpStack);
    break;
  case IRP_MN_QUERY_BUS_INFORMATION:
    status = PdoPortBusInfo(pDevExt, pIrp);
    break;
  case IRP_MN_QUERY_DEVICE_RELATIONS:
    switch (pIrpStack->Parameters.QueryDeviceRelations.Type) {
    case TargetDeviceRelation: {
      PDEVICE_RELATIONS pRelations;

      HALT_UNLESS(pIrp->IoStatus.Information == 0);

      if (pIrp->IoStatus.Information != 0)
        break;

      pRelations = (PDEVICE_RELATIONS)C0C_ALLOCATE_POOL(PagedPool, sizeof(DEVICE_RELATIONS));

      if (!pRelations) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        break;
      }

      pRelations->Count = 1;
      pRelations->Objects[0] = pDevExt->pDevObj;
      ObReferenceObject(pDevExt->pDevObj);
      pIrp->IoStatus.Information = (ULONG_PTR)pRelations;
      status = STATUS_SUCCESS;
      break;
    }
    case RemovalRelations:
    case BusRelations:
    case EjectionRelations:
    case PowerRelations:
    default:
      break;
    }
    break;
  case IRP_MN_DEVICE_USAGE_NOTIFICATION:
    status = STATUS_UNSUCCESSFUL;
    break;
  case IRP_MN_REMOVE_DEVICE:
  case IRP_MN_START_DEVICE:
  case IRP_MN_STOP_DEVICE:
  case IRP_MN_QUERY_STOP_DEVICE:
  case IRP_MN_CANCEL_STOP_DEVICE:
  case IRP_MN_QUERY_REMOVE_DEVICE:
  case IRP_MN_CANCEL_REMOVE_DEVICE:
  case IRP_MN_SURPRISE_REMOVAL:
  case IRP_MN_EJECT:
    status = STATUS_SUCCESS;
    break;
  default:
    break;
  }

  TraceIrp("PNP", pIrp, &status, TRACE_FLAG_RESULTS);

  pIrp->IoStatus.Status = status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}

NTSTATUS FdoPortPnp(
    IN PC0C_FDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp)
{
  NTSTATUS status;
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
  ULONG minorFunction = pIrpStack->MinorFunction;
  PDEVICE_OBJECT pLowDevObj = pDevExt->pLowDevObj; // IRP_MN_REMOVE_DEVICE deletes *pDevExt!

  status = STATUS_SUCCESS;

  switch (minorFunction) {
  case IRP_MN_QUERY_DEVICE_RELATIONS: {
    LIST_ENTRY queueToComplete;
    KIRQL oldIrql;
    PC0C_IO_PORT pIoPort = pDevExt->pIoPortLocal;

    if ((pIoPort->exclusiveMode && pIoPort->isOpen) ||
        (pIoPort->plugInMode && !pIoPort->pIoPortRemote->isOpen))
    {
      HidePort(pDevExt);
    } else {
      ShowPort(pDevExt);
    }

    /* complete pending CLOSE IRPs */

    InitializeListHead(&queueToComplete);

    KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);
    FdoPortIo(C0C_IO_TYPE_CLOSE_COMPLETE,
              NULL,
              pIoPort,
              &pIoPort->irpQueues[C0C_QUEUE_CLOSE],
              &queueToComplete);
    KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

    FdoPortCompleteQueue(&queueToComplete);
    break;
  }
  case IRP_MN_QUERY_REMOVE_DEVICE:
    if (pDevExt->openCount)
      status = STATUS_DEVICE_BUSY;
    else
      pIrp->IoStatus.Status = STATUS_SUCCESS;
    break;
  case IRP_MN_REMOVE_DEVICE:
    RemoveFdoPort(pDevExt);
    pDevExt = NULL;
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    break;
  case IRP_MN_START_DEVICE:
  case IRP_MN_STOP_DEVICE:
  case IRP_MN_QUERY_STOP_DEVICE:
  case IRP_MN_CANCEL_STOP_DEVICE:
  case IRP_MN_SURPRISE_REMOVAL:
    pIrp->IoStatus.Status = STATUS_SUCCESS;
    break;
  }

  if (status == STATUS_SUCCESS) {
    IoSkipCurrentIrpStackLocation(pIrp);
    status = IoCallDriver(pLowDevObj, pIrp);

    TraceCode((PC0C_COMMON_EXTENSION)pDevExt, "PNP ", codeNameTablePnp, minorFunction, &status);
  } else {
    TraceIrp("PNP", pIrp, &status, TRACE_FLAG_RESULTS);

    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}

NTSTATUS c0cPnpDispatch(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

  HALT_UNLESS2(IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_PNP,
      IoGetCurrentIrpStackLocation(pIrp)->MajorFunction,
      IoGetCurrentIrpStackLocation(pIrp)->MinorFunction);

  TraceIrp("PNP", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FB:
    status = FdoBusPnp((PC0C_FDOBUS_EXTENSION)pDevExt, pIrp);
    break;
  case C0C_DOTYPE_PP:
    status = PdoPortPnp((PC0C_PDOPORT_EXTENSION)pDevExt, pIrp);
    break;
  case C0C_DOTYPE_FP:
    status = FdoPortPnp((PC0C_FDOPORT_EXTENSION)pDevExt, pIrp);
    break;
  default:
    status = STATUS_NO_SUCH_DEVICE;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/commprop.h

/*
 * $Id: commprop.h,v 1.1 2006/08/23 13:09:15 vfrolov Exp $
 *
 * Copyright (c) 2006 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: commprop.h,v $
 * Revision 1.1  2006/08/23 13:09:15  vfrolov
 * Initial revision
 *
 *
 */

#ifndef _C0C_COMMPROP_H_
#define _C0C_COMMPROP_H_

NTSTATUS GetCommProp(
    PC0C_FDOPORT_EXTENSION pDevExt,
    PVOID pBuf,
    ULONG bufSize,
    PULONG pSize);

#endif /* _C0C_COMMPROP_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/version.h

/*
 * $Id: version.h,v 1.22 2012/06/04 06:21:43 vfrolov Exp $
 *
 * Copyright (c) 2005-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef _C0C_VERSION_H_
#define _C0C_VERSION_H_

#define C0C_COPYRIGHT_YEARS "2004-2012"

#define C0C_V1 3
#define C0C_V2 0
#define C0C_V3 0
#define C0C_V4 0

#define MK_VERSION_STR1(V1, V2, V3, V4) #V1 "." #V2 "." #V3 "." #V4
#define MK_VERSION_STR(V1, V2, V3, V4) MK_VERSION_STR1(V1, V2, V3, V4)

#define C0C_VERSION_STR MK_VERSION_STR(C0C_V1, C0C_V2, C0C_V3, C0C_V4)

#endif /* _C0C_VERSION_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/rand.c

#include "precomp.h"
#include "rand.h"

ULONG RAND()
{
  static ULONG x = 123456789, y = 362436069, z = 521288629, w = 88675123, v = 886756453;
  ULONG t = (x ^ ( x >> 7));
  x = y; y = z; z = w; w = v;
  v = (v ^ (v << 6)) ^ (t ^ (t << 13));
  return (y + y + 1) * v;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/halt.h

/*
 * $Id: halt.h,v 1.3 2010/08/09 12:50:58 vfrolov Exp $
 *
 * Copyright (c) 2005-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: halt.h,v $
 * Revision 1.3  2010/08/09 12:50:58  vfrolov
 * Added try DbgBreakPoint() before KeBugCheckEx()
 *
 * Revision 1.2  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.1  2008/12/02 16:07:37  vfrolov
 * Initial revision
 *
 */

#ifndef _HALT_H_
#define _HALT_H_

#if defined(_PREFAST_)
  #define HALT_UNLESS3(exp, p1, p2, p3) __assume(exp)
#elif DBG
  #define HALT_UNLESS3(exp, p1, p2, p3) \
    if (!(exp)) { \
      try { \
        DbgPrint("%s (%d):\n", __FILE__, __LINE__); \
        DbgPrint("  HALT_UNLESS3(\"%s\",\n", #exp); \
        DbgPrint("               0x%08X, 0x%08X, 0x%08X);\n", (ULONG)(p1), (ULONG)(p2), (ULONG)(p3)); \
        DbgBreakPoint(); \
      } except (EXCEPTION_EXECUTE_HANDLER) { \
        KeBugCheckEx(0xDEADC0CD, (FILE_ID << 16) + __LINE__, (ULONG_PTR)(p1), (ULONG_PTR)(p2), (ULONG_PTR)(p3)); \
      } \
    }
#else
  #define HALT_UNLESS3(exp, p1, p2, p3)
#endif

#define HALT_UNLESS2(exp, p1, p2) HALT_UNLESS3(exp, p1, p2, 0)
#define HALT_UNLESS1(exp, p1)     HALT_UNLESS3(exp, p1, 0, 0)
#define HALT_UNLESS(exp)          HALT_UNLESS3(exp, 0, 0, 0)

#endif /* _HALT_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/strutils.h

/*
 * $Id: strutils.h,v 1.5 2010/05/27 11:06:23 vfrolov Exp $
 *
 * Copyright (c) 2004-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: strutils.h,v $
 * Revision 1.5  2010/05/27 11:06:23  vfrolov
 * Added StrAppendPortParametersRegistryPath() and StrAppendParameterPortName()
 *
 * Revision 1.4  2006/11/03 13:13:26  vfrolov
 * CopyStrW() now gets size in characters (not in bytes)
 *
 * Revision 1.3  2006/03/27 09:37:28  vfrolov
 * Added StrAppendDeviceProperty()
 *
 * Revision 1.2  2005/05/17 15:07:36  vfrolov
 * Fixed parameter type typo
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_STRUTILS_H_
#define _C0C_STRUTILS_H_

NTSTATUS CopyStrW(OUT PWCHAR pDestStr, IN LONG size, IN PWCHAR pStr);

NTSTATUS DupStrW(OUT PWCHAR *ppDestStr, IN PWCHAR pStr, IN BOOLEAN multiStr);
VOID StrFree(IN OUT PUNICODE_STRING  pDest);
BOOLEAN StrFreeBad(NTSTATUS status, IN OUT PUNICODE_STRING  pDest);
VOID StrAppendStr(
    PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING  pDest,
    IN PWCHAR pSrc,
    IN USHORT lenSrc);
VOID StrAppendStr0(PNTSTATUS pStatus, IN OUT PUNICODE_STRING  pDest, IN PWCHAR pSrc);
VOID StrAppendNum(
    PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN ULONG num,
    IN ULONG base);
VOID StrAppendDeviceProperty(
    IN OUT PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN PDEVICE_OBJECT pDevObj,
    IN DEVICE_REGISTRY_PROPERTY deviceProperty);
VOID StrAppendPortParametersRegistryPath(
    IN OUT PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN PWCHAR pPhPortName);
VOID StrAppendParameterPortName(
    IN OUT PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN PWCHAR pPortParametersRegistryPath);

#endif /* _C0C_STRUTILS_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/initunlo.c

/*
 * $Id: initunlo.c,v 1.9 2011/12/15 06:17:12 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: initunlo.c,v $
 * Revision 1.9  2011/12/15 06:17:12  vfrolov
 * Removed usage undocumented PDRIVER_OBJECT->Type
 *
 * Revision 1.8  2010/08/09 06:02:40  vfrolov
 * Eliminated accessing undocumented structure members
 *
 * Revision 1.7  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.6  2006/08/23 13:13:53  vfrolov
 * Moved c0cSystemControlDispatch() to wmi.c
 *
 * Revision 1.5  2005/09/28 10:06:42  vfrolov
 * Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION
 *
 * Revision 1.4  2005/09/13 14:56:16  vfrolov
 * Implemented IRP_MJ_FLUSH_BUFFERS
 *
 * Revision 1.3  2005/07/13 16:12:36  vfrolov
 * Added c0cGlobal struct for global driver's data
 *
 * Revision 1.2  2005/05/12 07:41:27  vfrolov
 * Added ability to change the port names
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 *
 */

#include "precomp.h"
#include "strutils.h"

C0C_GLOBAL c0cGlobal;

DRIVER_INITIALIZE DriverEntry;
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDrvObj, IN PUNICODE_STRING pRegistryPath)
{
  NTSTATUS status;

  KeInitializeSpinLock(&c0cGlobal.listFdoBusLock);
  InitializeListHead(&c0cGlobal.listFdoBus);

  c0cGlobal.pDrvObj = pDrvObj;

  status = STATUS_SUCCESS;

  RtlInitUnicodeString(&c0cGlobal.registryPath, NULL);
  StrAppendStr(&status, &c0cGlobal.registryPath, pRegistryPath->Buffer, pRegistryPath->Length);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"DriverEntry FAIL");
    return status;
  }

  TraceOpen(pDrvObj, pRegistryPath);

  pDrvObj->DriverUnload                                  = c0cUnload;
  pDrvObj->DriverExtension->AddDevice                    = c0cAddDevice;

  pDrvObj->MajorFunction[IRP_MJ_CREATE]                  = c0cOpen;
  pDrvObj->MajorFunction[IRP_MJ_CLOSE]                   = c0cClose;
  pDrvObj->MajorFunction[IRP_MJ_CLEANUP]                 = c0cCleanup;
  pDrvObj->MajorFunction[IRP_MJ_FLUSH_BUFFERS]           = c0cWrite;
  pDrvObj->MajorFunction[IRP_MJ_WRITE]                   = c0cWrite;
  pDrvObj->MajorFunction[IRP_MJ_READ]                    = c0cRead;
  pDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = c0cIoControl;
  pDrvObj->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = c0cInternalIoControl;
  pDrvObj->MajorFunction[IRP_MJ_QUERY_INFORMATION]       = c0cFileInformation;
  pDrvObj->MajorFunction[IRP_MJ_SET_INFORMATION]         = c0cFileInformation;
  pDrvObj->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = c0cSystemControlDispatch;
  pDrvObj->MajorFunction[IRP_MJ_PNP]                     = c0cPnpDispatch;
  pDrvObj->MajorFunction[IRP_MJ_POWER]                   = c0cPowerDispatch;

  return STATUS_SUCCESS;
}

VOID c0cUnload(IN PDRIVER_OBJECT pDrvObj)
{
  UNREFERENCED_PARAMETER(pDrvObj);

  StrFree(&c0cGlobal.registryPath);

  TraceClose();
}

NTSTATUS c0cInternalIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;

  UNREFERENCED_PARAMETER(pDevObj);

  status = STATUS_INVALID_DEVICE_REQUEST;

  TraceIrp("c0cInternalIoControl", pIrp, &status, TRACE_FLAG_PARAMS);

  pIrp->IoStatus.Information = 0;
  pIrp->IoStatus.Status = status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/precomp.h

/*
 * $Id: precomp.h,v 1.7 2011/12/15 08:47:49 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: precomp.h,v $
 * Revision 1.7  2011/12/15 08:47:49  vfrolov
 * Added ability to disable tracing code compiling by environment variable
 * (SET C_DEFINES=/DENABLE_TRACING=0)
 *
 * Revision 1.6  2011/07/12 18:15:37  vfrolov
 * Discarded WDM garbage
 *
 * Revision 1.5  2010/09/03 13:32:14  vfrolov
 * Fixed incompatibility with WDK 6001.18002
 *
 * Revision 1.4  2010/08/04 10:38:56  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.3  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.2  2005/07/01 11:05:41  vfrolov
 * Removed unused headers
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_PRECOMP_H_
#define _C0C_PRECOMP_H_

#pragma warning(push, 3)

#include <ntddk.h>
#include <ntddser.h>

#pragma warning(pop)

#ifndef NTDDI_WIN7

/* Declarations missing in old DDKs */

typedef VOID KDEFERRED_ROUTINE(
    IN PKDPC pDpc,
    IN PVOID deferredContext,
    IN PVOID systemArgument1,
    IN PVOID systemArgument2);

#ifndef NTDDI_VERSION

#define __drv_dispatchType(type)
#define __drv_aliasesMem

typedef NTSTATUS DRIVER_INITIALIZE(
    IN PDRIVER_OBJECT pDrvObj,
    IN PUNICODE_STRING pRegistryPath);

typedef VOID DRIVER_UNLOAD(
    IN PDRIVER_OBJECT pDrvObj);

typedef NTSTATUS DRIVER_ADD_DEVICE(
    IN PDRIVER_OBJECT pDrvObj,
    IN PDEVICE_OBJECT pPhDevObj);

typedef NTSTATUS DRIVER_DISPATCH(
    IN PDEVICE_OBJECT,
    IN PIRP);

typedef VOID DRIVER_CANCEL(
    IN PDEVICE_OBJECT pDevObj,
    IN PIRP pIrp);

NTSYSAPI NTSTATUS NTAPI ZwDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName);

#endif /* NTDDI_VERSION */
#endif /* NTDDI_WIN7 */

#ifndef ENABLE_TRACING
  #define ENABLE_TRACING 1
#endif

#include "com0com.h"
#include "trace.h"
#include "syslog.h"
#include "halt.h"

#pragma warning(disable:4514) // unreferenced inline function has been removed

#endif /* _C0C_PRECOMP_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/io.c

/*
 * $Id: io.c,v 1.43 2010/08/04 10:38:55 vfrolov Exp $
 *
 * Copyright (c) 2004-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: io.c,v $
 * Revision 1.43  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.42  2008/12/15 11:00:00  vfrolov
 * Fixed break char delay
 *
 * Revision 1.41  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.40  2008/09/01 16:54:28  vfrolov
 * Replaced SERIAL_LSRMST_LSR_NODATA by SERIAL_LSRMST_LSR_DATA for BREAK
 *
 * Revision 1.39  2008/08/19 12:40:58  vfrolov
 * Replaces C0CE_INSERT_ENABLE_LSR_NBI (insertion on BREAK OFF)
 * by C0CE_INSERT_ENABLE_LSR_BI (insertion on BREAK change)
 *
 * Revision 1.38  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.37  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.36  2007/09/12 12:32:53  vfrolov
 * Fixed TX buffer
 *
 * Revision 1.35  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.34  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.33  2007/06/09 08:49:47  vfrolov
 * Improved baudrate emulation
 *
 * Revision 1.32  2007/06/07 14:51:47  vfrolov
 * Added check for NULL of pIrpXoffCounter
 *
 * Revision 1.31  2007/06/04 15:24:32  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.30  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.29  2006/11/27 11:58:27  vfrolov
 * Fixed unexpected completing all queued read requests when
 * completing the first one
 *
 * Revision 1.28  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.27  2006/05/17 15:31:14  vfrolov
 * Implemented SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.26  2006/02/26 08:39:19  vfrolov
 * Added check for start/stop queue matching
 * Fixed delayed BREAK losts
 *
 * Revision 1.25  2006/02/21 13:42:11  vfrolov
 * Implemented SERIAL_BREAK_CHAR
 *
 * Revision 1.24  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.23  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.22  2005/12/06 13:04:32  vfrolov
 * Fixed data types
 *
 * Revision 1.21  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.20  2005/11/30 16:04:11  vfrolov
 * Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
 *
 * Revision 1.19  2005/11/29 12:33:21  vfrolov
 * Changed SetModemStatus() to ability set and clear bits simultaneously
 *
 * Revision 1.18  2005/11/29 08:35:13  vfrolov
 * Implemented SERIAL_EV_RX80FULL
 *
 * Revision 1.17  2005/11/25 08:59:39  vfrolov
 * Implemented SERIAL_EV_RXFLAG
 *
 * Revision 1.16  2005/09/14 13:14:47  vfrolov
 * Fixed possible tick loss
 *
 * Revision 1.15  2005/09/14 10:42:38  vfrolov
 * Implemented SERIAL_EV_TXEMPTY
 *
 * Revision 1.14  2005/09/13 14:56:16  vfrolov
 * Implemented IRP_MJ_FLUSH_BUFFERS
 *
 * Revision 1.13  2005/09/13 08:55:41  vfrolov
 * Disabled modem status tracing by default
 *
 * Revision 1.12  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.11  2005/08/26 08:35:05  vfrolov
 * Fixed unwanted interference to baudrate emulation by read operations
 *
 * Revision 1.10  2005/08/25 15:38:17  vfrolov
 * Some code moved from io.c to bufutils.c
 *
 * Revision 1.9  2005/08/25 08:25:40  vfrolov
 * Fixed data types
 *
 * Revision 1.8  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.7  2005/07/14 12:24:31  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.6  2005/05/19 08:23:41  vfrolov
 * Fixed data types
 *
 * Revision 1.5  2005/05/14 17:07:02  vfrolov
 * Implemented SERIAL_LSRMST_MST insertion
 *
 * Revision 1.4  2005/05/13 16:58:03  vfrolov
 * Implemented IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.3  2005/05/13 06:32:16  vfrolov
 * Implemented SERIAL_EV_RXCHAR
 *
 * Revision 1.2  2005/02/01 08:36:27  vfrolov
 * Changed SetModemStatus() to set multiple bits and set CD to DSR
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "timeout.h"
#include "delay.h"
#include "bufutils.h"
#include "handflow.h"
#include "noise.h"
#include "../include/cncext.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 1

#define GET_REST_BUFFER(pIrp, done) \
    (((PUCHAR)(pIrp)->AssociatedIrp.SystemBuffer) + (done))

#define GET_REST_BUFFER_WRITE(pIrp, done) \
    ((IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_DEVICE_CONTROL && \
      IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER) \
        ? &(((PSERIAL_XOFF_COUNTER)(pIrp)->AssociatedIrp.SystemBuffer)->XoffChar) + (done) \
        : GET_REST_BUFFER(pIrp, (done)))

typedef struct _RW_DATA {

  #define RW_DATA_TYPE_IRP   1
  #define RW_DATA_TYPE_CHR   2

  short type;

  union {
    struct {
      PIRP pIrp;
      NTSTATUS status;
    } irp;
    struct {
      UCHAR chr;

      #define RW_DATA_TYPE_CHR_NONE   0
      #define RW_DATA_TYPE_CHR_XCHR   1
      #define RW_DATA_TYPE_CHR_BREAK  2

      short type;

      BOOLEAN isChr;
    } chr;
  } data;
} RW_DATA, *PRW_DATA;

#define CAN_WRITE_RW_DATA_CHR(pIoPort, dataChar) \
  ( \
    ((dataChar).data.chr.type == RW_DATA_TYPE_CHR_XCHR && \
          ((pIoPort)->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) == 0) || \
    ((dataChar).data.chr.type == RW_DATA_TYPE_CHR_BREAK) \
  ) \

ULONG GetWriteLength(IN PIRP pIrp)
{
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  switch (pIrpStack->MajorFunction) {
  case IRP_MJ_WRITE:
    return pIrpStack->Parameters.Write.Length;
  case IRP_MJ_DEVICE_CONTROL:
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SERIAL_IMMEDIATE_CHAR:
    case IOCTL_SERIAL_XOFF_COUNTER:
      return sizeof(UCHAR);
    }
    break;
  }
  return 0;
}

VOID OnRxChars(
    PC0C_IO_PORT pReadIoPort,
    PC0C_FLOW_FILTER pFlowFilter,
    PLIST_ENTRY pQueueToComplete)
{
  PIRP pCurrent;
  SIZE_T size = pFlowFilter->rxCount;

  SetXonXoffHolding(pReadIoPort, pFlowFilter->lastXonXoff);

  if (pFlowFilter->events) {
    pReadIoPort->eventMask |= (pFlowFilter->events & pReadIoPort->waitMask);

    if (pReadIoPort->eventMask)
      WaitComplete(pReadIoPort, pQueueToComplete);
  }

  pReadIoPort->perfStats.ReceivedCount += (ULONG)size;

  pCurrent = pReadIoPort->irpQueues[C0C_QUEUE_WRITE].pCurrent;

  if (pCurrent) {
    PIO_STACK_LOCATION pCurrentStack;

    pCurrentStack = IoGetCurrentIrpStackLocation(pCurrent);

    if (pCurrentStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
        pCurrentStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER &&
        pCurrent->IoStatus.Information)
    {
      if ((LONG)size < pReadIoPort->xoffCounter) {
        pReadIoPort->xoffCounter -= (LONG)size;
      } else {
        ShiftQueue(&pReadIoPort->irpQueues[C0C_QUEUE_WRITE]);
        CompleteIrp(pCurrent, STATUS_SUCCESS, pQueueToComplete);
      }
    }
  }
}

NTSTATUS ReadFromBuffers(
    PIRP pIrp,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pReadDone,
    PSIZE_T pSendDone)
{
  SIZE_T destRestLength;
  SIZE_T information;
  C0C_FLOW_FILTER flowFilter;
  SIZE_T sendDone;
  SIZE_T readDone;
  SIZE_T brokeIdleChars;
  PUCHAR pDestRest;

  information = pIrp->IoStatus.Information;
  destRestLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length - information;

  if (destRestLength == 0)
    return STATUS_SUCCESS;

  pDestRest = GET_REST_BUFFER(pIrp, information);

  readDone =  ReadFromBuffer(&pReadIoPort->readBuf, pDestRest, destRestLength);

  if (readDone) {
    *pReadDone += readDone;
    information += readDone;
    destRestLength -= readDone;

    if (destRestLength == 0) {
      pIrp->IoStatus.Information = information;
      return STATUS_SUCCESS;
    }

    pDestRest += readDone;
  }

  FlowFilterInit(pReadIoPort, &flowFilter);

  brokeIdleChars = pReadIoPort->pIoPortRemote->brokeIdleChars;

  if (brokeIdleChars) {
    CopyCharsWithEscape(&pReadIoPort->readBuf,
                        &flowFilter,
                        pDestRest, destRestLength,
                        NULL, brokeIdleChars,
                        &readDone,
                        &sendDone);

    if (sendDone)
      pReadIoPort->pIoPortRemote->brokeIdleChars -= sendDone;

    if (readDone) {
      *pReadDone += readDone;
      information += readDone;
      destRestLength -= readDone;

      if (destRestLength == 0) {
        pIrp->IoStatus.Information = information;
        return STATUS_SUCCESS;
      }

      pDestRest += readDone;
    }
  }

  readDone =  ReadFromTxBuffer(&pReadIoPort->readBuf,
                               &flowFilter,
                               pDestRest, destRestLength,
                               &pReadIoPort->pIoPortRemote->txBuf,
                               pWriteLimit ? *pWriteLimit : -1,
                               &sendDone);

  if (sendDone) {
    if (pWriteLimit)
      *pWriteLimit -= sendDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += sendDone;
      pWriteDelay->idleCount = 0;
    }

    *pSendDone += sendDone;
  }

  if (readDone) {
    *pReadDone += readDone;
    information += readDone;
    destRestLength -= readDone;
  }

  pIrp->IoStatus.Information = information;

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  if (destRestLength == 0)
    return STATUS_SUCCESS;

  return STATUS_PENDING;
}

VOID ReadBrokenIdleChars(
    PIRP pIrp,
    PNTSTATUS pStatusRead,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pReadDone)
{
  SIZE_T destRestLength;
  SIZE_T information;
  C0C_FLOW_FILTER flowFilter;
  SIZE_T sendDone;
  SIZE_T readDone;

  if (pReadIoPort->pIoPortRemote->brokeIdleChars == 0)
    return;

  information = pIrp->IoStatus.Information;
  destRestLength = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length - information;

  FlowFilterInit(pReadIoPort, &flowFilter);

  CopyCharsWithEscape(&pReadIoPort->readBuf,
                      &flowFilter,
                      GET_REST_BUFFER(pIrp, information), destRestLength,
                      NULL, pReadIoPort->pIoPortRemote->brokeIdleChars,
                      &readDone,
                      &sendDone);

  if (sendDone)
    pReadIoPort->pIoPortRemote->brokeIdleChars -= sendDone;

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  if (readDone) {
    *pReadDone += readDone;
    pIrp->IoStatus.Information += readDone;
    if (destRestLength <= readDone)
      *pStatusRead = STATUS_SUCCESS;
  }
}

VOID AlertOverrun(PC0C_IO_PORT pReadIoPort, PLIST_ENTRY pQueueToComplete)
{
  pReadIoPort->errors |= SERIAL_ERROR_QUEUEOVERRUN;

  if (pReadIoPort->handFlow.FlowReplace & SERIAL_ERROR_CHAR)
    WriteMandatoryToBuffer(&pReadIoPort->readBuf, pReadIoPort->specialChars.ErrorChar);

  if (pReadIoPort->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) {
    CancelQueue(&pReadIoPort->irpQueues[C0C_QUEUE_READ], pQueueToComplete);
    CancelQueue(&pReadIoPort->irpQueues[C0C_QUEUE_WRITE], pQueueToComplete);
  }
}

SIZE_T SendBrokenChars(
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    SIZE_T count)
{
  SIZE_T sendDone;
  C0C_FLOW_FILTER flowFilter;

  if (!count)
    return 0;

  FlowFilterInit(pReadIoPort, &flowFilter);

  if (pReadIoPort->emuOverrun) {
    SIZE_T overrun;

    sendDone = WriteToBuffer(&pReadIoPort->readBuf,
                             NULL,
                             count,
                             &flowFilter,
                             &overrun);

    if (overrun) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)overrun;
    }
  } else {
    sendDone = WriteToBuffer(&pReadIoPort->readBuf,
                             NULL,
                             count,
                             &flowFilter,
                             NULL);
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  return sendDone;
}

VOID SendTxBuffer(
    PC0C_IO_PORT pReadIoPort,
    PC0C_IO_PORT pWriteIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pSendDone)
{
  SIZE_T sendDone;
  SIZE_T txLimit;
  C0C_FLOW_FILTER flowFilter;

  FlowFilterInit(pReadIoPort, &flowFilter);

  if (pWriteLimit)
    txLimit = *pWriteLimit;
  else
    txLimit = (SIZE_T)-1;

  if (pReadIoPort->emuOverrun) {
    SIZE_T overrun;

    sendDone = MoveFromTxBuffer(&pReadIoPort->readBuf,
                                &pWriteIoPort->txBuf, txLimit,
                                &flowFilter,
                                &overrun);

    if (overrun) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)overrun;
    }
  } else {
    sendDone = MoveFromTxBuffer(&pReadIoPort->readBuf,
                                &pWriteIoPort->txBuf, txLimit,
                                &flowFilter,
                                NULL);
  }

  if (sendDone) {
    if (pWriteLimit)
      *pWriteLimit -= sendDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += sendDone;
      pWriteDelay->idleCount = 0;
    }

    *pSendDone += sendDone;
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);
}

VOID WriteToBuffers(
    PRW_DATA pDataWrite,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pWriteDone,
    PSIZE_T pSendDone)
{
  SIZE_T writeLength, information;
  SIZE_T sendDone, writeDone;
  C0C_FLOW_FILTER flowFilter;
  PUCHAR pWriteBuf;
  SIZE_T length;
  SIZE_T sendLength;
  BOOLEAN isBreak;

  isBreak = FALSE;

  if (pDataWrite->type == RW_DATA_TYPE_IRP) {
    PIRP pIrp = pDataWrite->data.irp.pIrp;

    information = pIrp->IoStatus.Information;
    pWriteBuf = GET_REST_BUFFER_WRITE(pIrp, information);
    writeLength = GetWriteLength(pIrp);
  } else {
    HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

    information = 0;
    pWriteBuf = &pDataWrite->data.chr.chr;
    writeLength = pDataWrite->data.chr.isChr ? 1 : 0;
    if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_BREAK)
      isBreak = TRUE;
  }

  length = writeLength - information;

  if (pWriteLimit && length > *pWriteLimit)
    sendLength = *pWriteLimit;
  else
    sendLength = length;

  FlowFilterInit(pReadIoPort, &flowFilter);

  if (pReadIoPort->emuOverrun) {
    SIZE_T overrun;

    sendDone = WriteToBuffer(&pReadIoPort->readBuf, pWriteBuf, sendLength, &flowFilter, &overrun);

    if (overrun) {
      AlertOverrun(pReadIoPort, pQueueToComplete);
      pReadIoPort->perfStats.BufferOverrunErrorCount += (ULONG)overrun;
    }
  } else {
    sendDone = WriteToBuffer(&pReadIoPort->readBuf, pWriteBuf, sendLength, &flowFilter, NULL);
  }

  HALT_UNLESS3(sendDone <= sendLength, pDataWrite->type, sendDone, sendLength);

  writeDone = sendDone;

  if (writeDone < length && !isBreak)
    writeDone += WriteToTxBuffer(&pReadIoPort->pIoPortRemote->txBuf, pWriteBuf + writeDone, length - writeDone);

  HALT_UNLESS3(writeDone <= length, pDataWrite->type, writeDone, length);

  if (writeDone) {
    information += writeDone;

    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.pIrp->IoStatus.Information = information;
      pReadIoPort->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
    }

    if (!isBreak) {
      pReadIoPort->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
      *pWriteDone += writeDone;
    }
  }

  if (sendDone) {
    if (pWriteLimit)
      *pWriteLimit -= sendDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += sendDone;
      pWriteDelay->idleCount = 0;
    }

    if (!isBreak)
      *pSendDone += sendDone;
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  if (information == writeLength) {
    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.status = STATUS_SUCCESS;
    } else {
      HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

      pDataWrite->data.chr.isChr = FALSE;

      if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_XCHR)
        pReadIoPort->pIoPortRemote->sendXonXoff = 0;
    }
  }
}

VOID ReadWriteDirect(
    PIRP pIrpRead,
    PRW_DATA pDataWrite,
    PNTSTATUS pStatusRead,
    PC0C_IO_PORT pReadIoPort,
    PLIST_ENTRY pQueueToComplete,
    PSIZE_T pWriteLimit,
    PC0C_ADAPTIVE_DELAY pWriteDelay,
    PSIZE_T pReadDone,
    PSIZE_T pWriteDone)
{
  SIZE_T readDone, writeDone;
  SIZE_T writeLength, readLength;
  C0C_FLOW_FILTER flowFilter;
  PVOID pWriteBuf, pReadBuf;
  BOOLEAN isBreak;

  isBreak = FALSE;

  pReadBuf = GET_REST_BUFFER(pIrpRead, pIrpRead->IoStatus.Information);
  readLength = IoGetCurrentIrpStackLocation(pIrpRead)->Parameters.Read.Length
                                                - pIrpRead->IoStatus.Information;

  if (pDataWrite->type == RW_DATA_TYPE_IRP) {
    PIRP pIrpWrite = pDataWrite->data.irp.pIrp;

    pWriteBuf = GET_REST_BUFFER_WRITE(pIrpWrite, pIrpWrite->IoStatus.Information);
    writeLength = GetWriteLength(pIrpWrite) - pIrpWrite->IoStatus.Information;
  } else {
    HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

    pWriteBuf = &pDataWrite->data.chr.chr;
    writeLength = pDataWrite->data.chr.isChr ? 1 : 0;
    if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_BREAK)
      isBreak = TRUE;
  }

  FlowFilterInit(pReadIoPort, &flowFilter);

  CopyCharsWithEscape(
      &pReadIoPort->readBuf, &flowFilter,
      pReadBuf, readLength,
      pWriteBuf, (pWriteLimit && writeLength > *pWriteLimit) ? *pWriteLimit : writeLength,
      &readDone, &writeDone);

  pIrpRead->IoStatus.Information += readDone;

  if (readDone == readLength)
    *pStatusRead = STATUS_SUCCESS;

  if (writeDone == writeLength) {
    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.status = STATUS_SUCCESS;
    } else {
      HALT_UNLESS1(pDataWrite->type == RW_DATA_TYPE_CHR, pDataWrite->type);

      pDataWrite->data.chr.isChr = FALSE;

      if (pDataWrite->data.chr.type == RW_DATA_TYPE_CHR_XCHR)
        pReadIoPort->pIoPortRemote->sendXonXoff = 0;
    }
  }

  if (writeDone) {
    if (pWriteLimit)
      *pWriteLimit -= writeDone;

    if (pWriteDelay) {
      pWriteDelay->sentFrames += writeDone;
      pWriteDelay->idleCount = 0;
    }

    if (pDataWrite->type == RW_DATA_TYPE_IRP) {
      pDataWrite->data.irp.pIrp->IoStatus.Information += writeDone;
      pReadIoPort->pIoPortRemote->amountInWriteQueue -= (ULONG)writeDone;
    }

    if (!isBreak) {
      pReadIoPort->pIoPortRemote->perfStats.TransmittedCount += (ULONG)writeDone;
      *pWriteDone += writeDone;
    }
  }

  if (flowFilter.rxCount)
    OnRxChars(pReadIoPort, &flowFilter, pQueueToComplete);

  *pReadDone += readDone;
}

VOID InsertDirect(
    PC0C_RAW_DATA pRawData,
    PIRP pIrpRead,
    PNTSTATUS pStatusWrite,
    PNTSTATUS pStatusRead,
    PSIZE_T pReadDone)
{
  SIZE_T readDone;
  SIZE_T readLength;
  PVOID pReadBuf;

  pReadBuf = GET_REST_BUFFER(pIrpRead, pIrpRead->IoStatus.Information);
  readLength = IoGetCurrentIrpStackLocation(pIrpRead)->Parameters.Read.Length
                                                - pIrpRead->IoStatus.Information;

  readDone = WriteRawData(pRawData, pStatusWrite, pReadBuf, readLength);

  pIrpRead->IoStatus.Information += readDone;

  if (readDone == readLength)
    *pStatusRead = STATUS_SUCCESS;

  *pReadDone += readDone;
}

PIRP StartCurrentIrp(PC0C_IRP_QUEUE pQueue, PDRIVER_CANCEL *ppCancelRoutine, PBOOLEAN pFirst)
{
  while (pQueue->pCurrent) {
    PIRP pIrp;

    pIrp = pQueue->pCurrent;

    #pragma warning(push, 3)
    *ppCancelRoutine = IoSetCancelRoutine(pIrp, NULL);
    #pragma warning(pop)

    if (*ppCancelRoutine) {
#if DBG
      HALT_UNLESS(!pQueue->started);
      pQueue->started = TRUE;
#endif /* DBG */
      return pIrp;
    }

    ShiftQueue(pQueue);
    *pFirst = FALSE;
  }
  return NULL;
}

NTSTATUS StopCurrentIrp(
    NTSTATUS status,
    PDRIVER_CANCEL pCancelRoutine,
    BOOLEAN first,
    SIZE_T done,
    PC0C_IO_PORT pIoPort,
    PC0C_IRP_QUEUE pQueue,
    PLIST_ENTRY pQueueToComplete)
{
  PIRP pIrp;
  PC0C_IRP_STATE pState;

#if DBG
  HALT_UNLESS(pQueue->started);
  pQueue->started = FALSE;
#endif /* DBG */

  pIrp = pQueue->pCurrent;

  pState = GetIrpState(pIrp);
  HALT_UNLESS(pState);

  if (status == STATUS_PENDING && done) {
    if ((pState->flags & C0C_IRP_FLAG_WAIT_ONE) != 0) {
      status = STATUS_SUCCESS;
    }
    else
    if (first && (pState->flags & C0C_IRP_FLAG_INTERVAL_TIMEOUT) != 0) {
      SetIntervalTimeout(pIoPort);
    }
  }

  if (status == STATUS_PENDING && (pState->flags & C0C_IRP_FLAG_EXPIRED) != 0) {
    status = STATUS_TIMEOUT;
  }
  else
  if (!first && status == STATUS_PENDING) {
    status = SetIrpTimeout(pIoPort, pIrp);
  }

  HALT_UNLESS(pCancelRoutine);

  if (status == STATUS_PENDING) {
    #pragma warning(push, 3)
    IoSetCancelRoutine(pIrp, pCancelRoutine);
    #pragma warning(pop)
    if (pIrp->Cancel) {
      ShiftQueue(pQueue);
      CompleteIrp(pIrp, STATUS_CANCELLED, pQueueToComplete);
      return STATUS_CANCELLED;
    }
  } else {
    ShiftQueue(pQueue);
    pIrp->IoStatus.Status = status;
    InsertTailList(pQueueToComplete, &pIrp->Tail.Overlay.ListEntry);
  }

  return status;
}

VOID StartXoffCounter(PC0C_IO_PORT pIoPortWrite, PLIST_ENTRY pQueueToComplete)
{
  PIRP pIrpXoffCounter;
  PC0C_IRP_STATE pState;
  PC0C_IRP_QUEUE pQueue;

  pQueue = &pIoPortWrite->irpQueues[C0C_QUEUE_WRITE];

#if DBG
  HALT_UNLESS(!pQueue->started);
#endif /* DBG */

  pIrpXoffCounter = pQueue->pCurrent;
  HALT_UNLESS(pIrpXoffCounter);

  ShiftQueue(pQueue);

  while (pQueue->pCurrent) {
    PIRP pCurrent = pQueue->pCurrent;

    if (IoGetCurrentIrpStackLocation(pCurrent)->MajorFunction != IRP_MJ_FLUSH_BUFFERS) {
      CompleteIrp(pIrpXoffCounter, STATUS_SERIAL_MORE_WRITES, pQueueToComplete);
      return;
    }

    ShiftQueue(pQueue);
    CompleteIrp(pCurrent, STATUS_SUCCESS, pQueueToComplete);
  }

  pIoPortWrite->xoffCounter = ((PSERIAL_XOFF_COUNTER)pIrpXoffCounter->AssociatedIrp.SystemBuffer)->Counter;

  pState = GetIrpState(pIrpXoffCounter);
  HALT_UNLESS(pState);

  pQueue->pCurrent = pIrpXoffCounter;
  pState->flags |= C0C_IRP_FLAG_IS_CURRENT;

  SetXoffCounterTimeout(pIoPortWrite, pIrpXoffCounter);
}

NTSTATUS FdoPortIo(
    short ioType,
    PVOID pParam,
    PC0C_IO_PORT pIoPort,
    PC0C_IRP_QUEUE pQueue,
    PLIST_ENTRY pQueueToComplete)
{
  NTSTATUS status;
  BOOLEAN first;
  BOOLEAN firstCurrent;
  PIRP pIrpCurrent;
  PDRIVER_CANCEL pCancelRoutineCurrent;

  first = TRUE;

  status = STATUS_PENDING;

  for (firstCurrent = TRUE ; (pIrpCurrent = StartCurrentIrp(pQueue, &pCancelRoutineCurrent, &firstCurrent)) != NULL ; firstCurrent = FALSE) {
    NTSTATUS statusCurrent;
    SIZE_T doneCurrent;

    statusCurrent = STATUS_PENDING;
    doneCurrent = 0;

    switch (ioType) {
    case C0C_IO_TYPE_WAIT_COMPLETE:
      HALT_UNLESS(pParam);
      *((PULONG)pIrpCurrent->AssociatedIrp.SystemBuffer) = *((PULONG)pParam);
      *((PULONG)pParam) = 0;
      pIrpCurrent->IoStatus.Information = sizeof(ULONG);
      statusCurrent = STATUS_SUCCESS;
      break;
    case C0C_IO_TYPE_INSERT:
#if ENABLE_TRACING
      if (C0C_BUFFER_BUSY(&pIoPort->readBuf))
        Trace0((PC0C_COMMON_EXTENSION)pIoPort->pDevExt, L"ERROR: direct INSERT with no empty buf");
#endif /* ENABLE_TRACING */

      HALT_UNLESS(pParam);
      InsertDirect((PC0C_RAW_DATA)pParam, pIrpCurrent, &status, &statusCurrent, &doneCurrent);
      break;
    case C0C_IO_TYPE_CLOSE_COMPLETE:
      InterlockedDecrement(&pIoPort->pDevExt->openCount);
      pIrpCurrent->IoStatus.Information = 0;
      statusCurrent = STATUS_SUCCESS;
      break;
    }

    statusCurrent = StopCurrentIrp(statusCurrent,
                                   pCancelRoutineCurrent,
                                   firstCurrent,
                                   doneCurrent,
                                   pIoPort,
                                   pQueue,
                                   pQueueToComplete);

    if (statusCurrent == STATUS_PENDING)
      break;
  }

  if (status == STATUS_PENDING) {
    switch (ioType) {
    case C0C_IO_TYPE_INSERT:
      HALT_UNLESS(pParam);
      status = WriteRawDataToBuffer((PC0C_RAW_DATA)pParam, &pIoPort->readBuf);
      if (status == STATUS_PENDING && !pIoPort->emuOverrun)
        status = MoveRawData(&pIoPort->readBuf.insertData, (PC0C_RAW_DATA)pParam);
      UpdateHandFlow(pIoPort, FALSE, pQueueToComplete);
      break;
    }
  }
  return status;
}

VOID InsertLsrMst(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN isMST,
    UCHAR value,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 3;
  insertData.data[0] = pIoPortRead->escapeChar;
  insertData.data[1] = (UCHAR)(isMST ? SERIAL_LSRMST_MST : SERIAL_LSRMST_LSR_NODATA);
  insertData.data[2] = value;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace00((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt,
        L"WARNING: Lost SERIAL_LSRMST_", isMST ? L"MST" : L"LSR_NODATA");
  }
}

VOID InsertRemoteBr(
    PC0C_IO_PORT pIoPortRead,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 2 + sizeof(ULONG);
  insertData.data[0] = pIoPortRead->escapeChar;
  insertData.data[1] = C0CE_INSERT_RBR;
  *(ULONG *)&insertData.data[2] = pIoPortRead->pIoPortRemote->baudRate.BaudRate;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"WARNING: Lost C0CE_INSERT_RBR");
  }
}

VOID InsertRemoteLc(
    PC0C_IO_PORT pIoPortRead,
    PLIST_ENTRY pQueueToComplete)
{
  C0C_RAW_DATA insertData;

  insertData.size = 5;
  insertData.data[0] = pIoPortRead->escapeChar;
  insertData.data[1] = C0CE_INSERT_RLC;
  insertData.data[2] = pIoPortRead->pIoPortRemote->lineControl.WordLength;
  insertData.data[3] = pIoPortRead->pIoPortRemote->lineControl.Parity;
  insertData.data[4] = pIoPortRead->pIoPortRemote->lineControl.StopBits;

  if (FdoPortIo(
      C0C_IO_TYPE_INSERT,
      &insertData,
      pIoPortRead,
      &pIoPortRead->irpQueues[C0C_QUEUE_READ],
      pQueueToComplete) == STATUS_PENDING)
  {
    AlertOverrun(pIoPortRead, pQueueToComplete);
    Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"WARNING: Lost C0CE_INSERT_RLC");
  }
}

NTSTATUS TryReadWrite(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN startRead,
    PC0C_IO_PORT pIoPortWrite,
    BOOLEAN startWrite,
    PLIST_ENTRY pQueueToComplete)
{
/*
 * With the real serial ports the data goes this way:
 *
 * ---------software--------|------------hardware---------------
 * TX QUEUE ------------------> TX FIFO --> TX shift register -
 *                                                             |
 * RX QUEUE <-- RX buffer <--- RX FIFO <-- RX shift register <-
 * -------------------------|-----------------------------------
 *
 * From application view point it's equivalent to:
 *
 * -------------------------------------------------------------
 * TX QUEUE ------------------> TX buffer ---------------------
 *                                                             |
 * RX QUEUE <-- RX buffer <------------------------------------
 * -------------------------------------------------------------
 *
 * Here the data goes by following steps:
 *
 *  - Move data from RX buffer to RX QUEUE while RX QUEUE is not empty;
 *  - Move shifted data from TX buffer to RX QUEUE while RX QUEUE is not empty;
 *  - Move shifted data from TX buffer to RX buffer if RX QUEUE is empty or
 *    move shifted data from TX QUEUE to RX QUEUE while RX QUEUE is not empty;
 *  - Move shifted data from TX QUEUE to RX buffer;
 *  - Move not shifted data from TX QUEUE to TX buffer while TX buffer not full;
 *
 */
  NTSTATUS status;
  SIZE_T readBufBusyBeg, readBufBusyEnd;

  RW_DATA dataIrpRead;
  PC0C_IRP_QUEUE pQueueRead;
  BOOLEAN firstRead;
  PDRIVER_CANCEL pCancelRoutineRead;
  SIZE_T doneRead;

  RW_DATA dataChar;

  RW_DATA dataIrpWrite;
  PC0C_IRP_QUEUE pQueueWrite;
  BOOLEAN firstWrite;
  PDRIVER_CANCEL pCancelRoutineWrite;
  SIZE_T doneWrite;
  SIZE_T doneSend;

  PC0C_ADAPTIVE_DELAY pWriteDelay;
  SIZE_T writeLimit;
  PSIZE_T pWriteLimit;

  dataIrpRead.type = RW_DATA_TYPE_IRP;
  dataChar.type = RW_DATA_TYPE_CHR;
  dataIrpWrite.type = RW_DATA_TYPE_IRP;

  pQueueRead = &pIoPortRead->irpQueues[C0C_QUEUE_READ];
  pQueueWrite = &pIoPortWrite->irpQueues[C0C_QUEUE_WRITE];
  pWriteDelay = pIoPortWrite->pWriteDelay;
  status = STATUS_SUCCESS;

  if (pWriteDelay) {
    if (!C0C_TX_BUFFER_EMPTY(&pIoPortWrite->txBuf) ||
        pQueueWrite->pCurrent ||
        pIoPortWrite->sendBreak ||
        pIoPortWrite->sendXonXoff ||
        pIoPortWrite->brokeIdleChars)
    {
      StartWriteDelayTimer(pWriteDelay);
      writeLimit = GetWriteLimit(pWriteDelay);
    } else {
      writeLimit = 0;
    }

    pWriteLimit = &writeLimit;
  } else {
    pWriteLimit = NULL;
  }

  doneSend = 0;
  readBufBusyBeg = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

  /******************************************************************************
   * Prepare RX QUEUE                                                           *
   ******************************************************************************/

  /* get first pIrpRead */

  dataIrpRead.data.irp.status = STATUS_PENDING;
  doneRead = 0;
  firstRead = TRUE;

  if (startRead) {
    dataIrpRead.data.irp.pIrp = pQueueRead->pCurrent;
    pCancelRoutineRead = NULL;
  } else {
    dataIrpRead.data.irp.pIrp = StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
  }

  /******************************************************************************
   * Move data from RX buffer to RX QUEUE while RX QUEUE is not empty           *
   * Move shifted data from TX buffer to RX QUEUE while RX QUEUE is not empty   *
   ******************************************************************************/

  while (dataIrpRead.data.irp.pIrp) {
    dataIrpRead.data.irp.status = ReadFromBuffers(dataIrpRead.data.irp.pIrp,
                                                  pIoPortRead,
                                                  pQueueToComplete,
                                                  pWriteLimit,
                                                  pWriteDelay,
                                                  &doneRead, &doneSend);

    if (dataIrpRead.data.irp.status == STATUS_PENDING)
      break;

    if (startRead && firstRead) {
      status = dataIrpRead.data.irp.status;
      ShiftQueue(pQueueRead);
    } else {
      StopCurrentIrp(dataIrpRead.data.irp.status, pCancelRoutineRead, firstRead,
                     doneRead, pIoPortRead, pQueueRead, pQueueToComplete);
    }

    /* get next pIrpRead */

    doneRead = 0;
    firstRead = FALSE;

    dataIrpRead.data.irp.pIrp =
        StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
  }

  /******************************************************************************
   * Move shifted data from TX buffer to RX buffer if RX QUEUE is empty         *
   ******************************************************************************/

  if (!dataIrpRead.data.irp.pIrp) {
    pIoPortWrite->brokeIdleChars -=
        SendBrokenChars(pIoPortRead, pQueueToComplete, pIoPortWrite->brokeIdleChars);

    SendTxBuffer(pIoPortRead, pIoPortWrite, pQueueToComplete, pWriteLimit, pWriteDelay, &doneSend);
  }

  /******************************************************************************
   * Prepare TX QUEUE                                                           *
   ******************************************************************************/

  /* get XON or XOFF char */

  switch (pIoPortWrite->sendXonXoff) {
    case C0C_XCHAR_ON:
      dataChar.data.chr.type = RW_DATA_TYPE_CHR_XCHR;
      dataChar.data.chr.chr = pIoPortWrite->specialChars.XonChar;
      dataChar.data.chr.isChr = TRUE;
      break;
    case C0C_XCHAR_OFF:
      dataChar.data.chr.type = RW_DATA_TYPE_CHR_XCHR;
      dataChar.data.chr.chr = pIoPortWrite->specialChars.XoffChar;
      dataChar.data.chr.isChr = TRUE;
      break;
    default:
      if (pIoPortWrite->sendBreak) {
        /* get BREAK char */

        dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
        dataChar.data.chr.chr = 0;
        dataChar.data.chr.isChr = TRUE;
        break;
      }

      dataChar.data.chr.type = RW_DATA_TYPE_CHR_NONE;
      dataChar.data.chr.isChr = FALSE;
  }

  /* get first pIrpWrite */

  doneWrite = 0;
  firstWrite = TRUE;

  if(startWrite) {
    dataIrpWrite.data.irp.pIrp = pQueueWrite->pCurrent;
    pCancelRoutineWrite = NULL;
  } else {
    dataIrpWrite.data.irp.pIrp =
        StartCurrentIrp(pQueueWrite, &pCancelRoutineWrite, &firstWrite);
  }

  /******************************************************************************
   * Move shifted data from TX QUEUE to RX QUEUE while RX QUEUE is not empty    *
   ******************************************************************************/

  while (dataIrpRead.data.irp.pIrp) {
#if ENABLE_TRACING
            if (C0C_BUFFER_BUSY(&pIoPortRead->readBuf))
              Trace0((PC0C_COMMON_EXTENSION)pIoPortRead->pDevExt, L"ERROR: direct R/W with no empty buf");
#endif /* ENABLE_TRACING */

    if (dataChar.data.chr.isChr) {
      if (!pWriteLimit || *pWriteLimit) {
        if (CAN_WRITE_RW_DATA_CHR(pIoPortWrite, dataChar)) {
          if (dataIrpRead.data.irp.status == STATUS_PENDING) {
            ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                            &dataChar,
                            &dataIrpRead.data.irp.status,
                            pIoPortRead,
                            pQueueToComplete,
                            pWriteLimit,
                            pWriteDelay,
                            &doneRead, &doneSend);
          }
        }
        else
        if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
          /* send BREAK char */

          dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
          dataChar.data.chr.chr = 0;
          dataChar.data.chr.isChr = TRUE;

          if (dataIrpRead.data.irp.status == STATUS_PENDING) {
            ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                            &dataChar,
                            &dataIrpRead.data.irp.status,
                            pIoPortRead,
                            pQueueToComplete,
                            pWriteLimit,
                            pWriteDelay,
                            &doneRead, &doneSend);
          }
        }
        else
        if (pWriteDelay) {
          if (pIoPortWrite->brokeCharsProbability > 0) {
            pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);

            ReadBrokenIdleChars(dataIrpRead.data.irp.pIrp,
                                &dataIrpRead.data.irp.status,
                                pIoPortRead,
                                pQueueToComplete,
                                &doneRead);
          }

          pWriteDelay->sentFrames += *pWriteLimit;
          *pWriteLimit = 0;
        }
      }
    }

    while (dataIrpWrite.data.irp.pIrp) {
      PIO_STACK_LOCATION pIrpStackWrite = IoGetCurrentIrpStackLocation(dataIrpWrite.data.irp.pIrp);

      if (pIrpStackWrite->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {
        dataIrpWrite.data.irp.status = STATUS_SUCCESS;
      } else {
        dataIrpWrite.data.irp.status = STATUS_PENDING;

        if (!pWriteLimit || *pWriteLimit) {
          if (!pIoPortWrite->writeHolding) {
            if (dataIrpRead.data.irp.status == STATUS_PENDING) {
              SIZE_T done = 0;

              ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                              &dataIrpWrite,
                              &dataIrpRead.data.irp.status,
                              pIoPortRead,
                              pQueueToComplete,
                              pWriteLimit,
                              pWriteDelay,
                              &doneRead, &done);

              if (done) {
                doneWrite += done;
                doneSend += done;
              }
            }
          }
          else
          if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
            /* send BREAK char */

            dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
            dataChar.data.chr.chr = 0;
            dataChar.data.chr.isChr = TRUE;

            if (dataIrpRead.data.irp.status == STATUS_PENDING) {
              ReadWriteDirect(dataIrpRead.data.irp.pIrp,
                              &dataChar,
                              &dataIrpRead.data.irp.status,
                              pIoPortRead,
                              pQueueToComplete,
                              pWriteLimit,
                              pWriteDelay,
                              &doneRead, &doneSend);
            }
          }
          else
          if (pWriteDelay) {
            if (pIoPortWrite->brokeCharsProbability > 0) {
              pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);

              ReadBrokenIdleChars(dataIrpRead.data.irp.pIrp,
                                  &dataIrpRead.data.irp.status,
                                  pIoPortRead,
                                  pQueueToComplete,
                                  &doneRead);
            }

            pWriteDelay->sentFrames += *pWriteLimit;
            *pWriteLimit = 0;
          }
        }
      }

      if (dataIrpWrite.data.irp.status == STATUS_PENDING)
        break;

      /* stop current pIrpWrite */

      if (dataIrpWrite.data.irp.status == STATUS_SUCCESS &&
          pIrpStackWrite->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
          pIrpStackWrite->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)
      {
        if(startWrite && firstWrite)
          status = STATUS_PENDING;
        else
          StopCurrentIrp(STATUS_PENDING, pCancelRoutineWrite, firstWrite,
                         doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);

        if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent) {
          if (doneWrite)
            StartXoffCounter(pIoPortWrite, pQueueToComplete);

          if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent) {
            dataIrpWrite.data.irp.pIrp = NULL;
            break;
          }
        }
      } else {
        if(startWrite && firstWrite) {
          status = dataIrpWrite.data.irp.status;
          ShiftQueue(pQueueWrite);
        } else {
          StopCurrentIrp(dataIrpWrite.data.irp.status, pCancelRoutineWrite, firstWrite,
                         doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);
        }
      }

      /* get next pIrpWrite */

      doneWrite = 0;
      firstWrite = FALSE;

      dataIrpWrite.data.irp.pIrp =
          StartCurrentIrp(pQueueWrite, &pCancelRoutineWrite, &firstWrite);
    }

    if (startRead && firstRead) {
      if (dataIrpRead.data.irp.status == STATUS_PENDING)
        dataIrpRead.data.irp.status =
            SetIrpTimeout(pIoPortRead, dataIrpRead.data.irp.pIrp);

      status = dataIrpRead.data.irp.status;

      if (dataIrpRead.data.irp.status != STATUS_PENDING)
        ShiftQueue(pQueueRead);
    } else {
      dataIrpRead.data.irp.status = StopCurrentIrp(
          dataIrpRead.data.irp.status, pCancelRoutineRead, firstRead,
          doneRead, pIoPortRead, pQueueRead, pQueueToComplete);
    }

    /* get next pIrpRead */

    if (dataIrpRead.data.irp.status != STATUS_PENDING) {
      dataIrpRead.data.irp.status = STATUS_PENDING;
      doneRead = 0;
      firstRead = FALSE;
      dataIrpRead.data.irp.pIrp =
          StartCurrentIrp(pQueueRead, &pCancelRoutineRead, &firstRead);
    } else {
      dataIrpRead.data.irp.pIrp = NULL;
    }
  }

  /******************************************************************************
   * Move shifted data from TX QUEUE to RX buffer                               *
   * Move not shifted data from TX QUEUE to TX buffer while TX buffer not full  *
   ******************************************************************************/

  if (dataChar.data.chr.isChr) {
    if (CAN_WRITE_RW_DATA_CHR(pIoPortWrite, dataChar)) {
      SIZE_T done = 0;

      WriteToBuffers(&dataChar, pIoPortRead,
                     pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
    }
    else
    if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
      /* send BREAK char */

      SIZE_T done = 0;

      dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
      dataChar.data.chr.chr = 0;
      dataChar.data.chr.isChr = TRUE;

      WriteToBuffers(&dataChar, pIoPortRead,
                     pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
    }
    else
    if (pWriteDelay) {
      if (pIoPortWrite->brokeCharsProbability > 0) {
        pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);
        pIoPortWrite->brokeIdleChars -=
            SendBrokenChars(pIoPortRead, pQueueToComplete, pIoPortWrite->brokeIdleChars);
      }

      pWriteDelay->sentFrames += *pWriteLimit;
      *pWriteLimit = 0;
    }
  }

  while (dataIrpWrite.data.irp.pIrp) {
    PIO_STACK_LOCATION pIrpStackWrite = IoGetCurrentIrpStackLocation(dataIrpWrite.data.irp.pIrp);

    if (pIrpStackWrite->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {
      dataIrpWrite.data.irp.status = STATUS_SUCCESS;
    } else {
      dataIrpWrite.data.irp.status = STATUS_PENDING;

      if (!pIoPortWrite->writeHolding) {
        WriteToBuffers(&dataIrpWrite, pIoPortRead,
                       pQueueToComplete, pWriteLimit, pWriteDelay, &doneWrite, &doneSend);
      }
      else
      if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
        /* send BREAK char */

        SIZE_T done = 0;

        dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
        dataChar.data.chr.chr = 0;
        dataChar.data.chr.isChr = TRUE;

        WriteToBuffers(&dataChar, pIoPortRead,
                       pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
      }
      else
      if (pWriteDelay) {
        if (pIoPortWrite->brokeCharsProbability > 0) {
          pIoPortWrite->brokeIdleChars += GetBrokenChars(pIoPortWrite->brokeCharsProbability, *pWriteLimit);
          pIoPortWrite->brokeIdleChars -=
              SendBrokenChars(pIoPortRead, pQueueToComplete, pIoPortWrite->brokeIdleChars);
        }

        pWriteDelay->sentFrames += *pWriteLimit;
        *pWriteLimit = 0;
      }
    }

    /* stop current pIrpWrite */

    if (dataIrpWrite.data.irp.status == STATUS_SUCCESS &&
        pIrpStackWrite->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
        pIrpStackWrite->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)
    {
      if(startWrite && firstWrite)
        status = STATUS_PENDING;
      else
        StopCurrentIrp(STATUS_PENDING, pCancelRoutineWrite, firstWrite,
                       doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);

      if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent) {
        if (doneWrite)
          StartXoffCounter(pIoPortWrite, pQueueToComplete);

        if (dataIrpWrite.data.irp.pIrp == pQueueWrite->pCurrent)
          break;
      }
    } else {
      if(startWrite && firstWrite) {
        if (dataIrpWrite.data.irp.status == STATUS_PENDING)
          dataIrpWrite.data.irp.status =
              SetIrpTimeout(pIoPortWrite, dataIrpWrite.data.irp.pIrp);

        status = dataIrpWrite.data.irp.status;

        if (dataIrpWrite.data.irp.status != STATUS_PENDING)
          ShiftQueue(pQueueWrite);
      } else {
        dataIrpWrite.data.irp.status =
            StopCurrentIrp(dataIrpWrite.data.irp.status, pCancelRoutineWrite, firstWrite,
                           doneWrite, pIoPortWrite, pQueueWrite, pQueueToComplete);
      }
    }

    /* get next pIrpWrite */

    if (dataIrpWrite.data.irp.status != STATUS_PENDING) {
      doneWrite = 0;
      firstWrite = FALSE;
      dataIrpWrite.data.irp.pIrp = StartCurrentIrp(pQueueWrite, &pCancelRoutineWrite, &firstWrite);
    } else {
      dataIrpWrite.data.irp.pIrp = NULL;
    }
  }

  if (dataChar.data.chr.type != RW_DATA_TYPE_CHR_BREAK && pIoPortWrite->sendBreak) {
    /* send BREAK char */

    SIZE_T done = 0;

    dataChar.data.chr.type = RW_DATA_TYPE_CHR_BREAK;
    dataChar.data.chr.chr = 0;
    dataChar.data.chr.isChr = TRUE;

    WriteToBuffers(&dataChar, pIoPortRead,
                   pQueueToComplete, pWriteLimit, pWriteDelay, &done, &doneSend);
  }

  /******************************************************************************/

  readBufBusyEnd = C0C_BUFFER_BUSY(&pIoPortRead->readBuf);

  if (readBufBusyBeg > readBufBusyEnd) {
    UpdateHandFlow(pIoPortRead, TRUE, pQueueToComplete);
  }
  else
  if (readBufBusyBeg < readBufBusyEnd) {
    if ((pIoPortRead->waitMask & SERIAL_EV_RX80FULL) &&
        readBufBusyEnd > pIoPortRead->readBuf.size80 &&
        readBufBusyBeg <= pIoPortRead->readBuf.size80)
    {
      pIoPortRead->eventMask |= SERIAL_EV_RX80FULL;
      WaitComplete(pIoPortRead, pQueueToComplete);
    }

    UpdateHandFlow(pIoPortRead, FALSE, pQueueToComplete);
  }

  if ((pIoPortWrite->waitMask & SERIAL_EV_TXEMPTY) && doneSend &&
      !pQueueWrite->pCurrent && C0C_TX_BUFFER_THR_EMPTY(&pIoPortWrite->txBuf))
  {
    pIoPortWrite->eventMask |= SERIAL_EV_TXEMPTY;
    WaitComplete(pIoPortWrite, pQueueToComplete);
  }

  if (C0C_TX_BUFFER_EMPTY(&pIoPortWrite->txBuf))
    pIoPortWrite->brokeChars = 0;  /* reset on idle */

  UpdateTransmitToggle(pIoPortWrite, pQueueToComplete);

  return status;
}

NTSTATUS ReadWrite(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN startRead,
    PC0C_IO_PORT pIoPortWrite,
    BOOLEAN startWrite,
    PLIST_ENTRY pQueueToComplete)
{
  NTSTATUS status;

  pIoPortWrite->tryWrite = FALSE;

  status = TryReadWrite(
      pIoPortRead, startRead,
      pIoPortWrite, startWrite,
      pQueueToComplete);

  while (pIoPortWrite->tryWrite || pIoPortRead->tryWrite) {
    if (!pIoPortWrite->tryWrite) {
      PC0C_IO_PORT pIoPortTmp;

      pIoPortTmp = pIoPortRead;
      pIoPortRead = pIoPortWrite;
      pIoPortWrite = pIoPortTmp;
    }

    pIoPortWrite->tryWrite = FALSE;

    TryReadWrite(
        pIoPortRead, FALSE,
        pIoPortWrite, FALSE,
        pQueueToComplete);
  }

  return status;
}

VOID SetModemStatus(
    IN PC0C_IO_PORT pIoPort,
    IN UCHAR bits,
    IN UCHAR mask,
    PLIST_ENTRY pQueueToComplete)
{
  UCHAR modemStatusOld;
  UCHAR modemStatusNew;
  UCHAR modemStatusChanged;

  modemStatusOld = modemStatusNew = pIoPort->modemStatus;

  modemStatusNew |= bits & mask;
  modemStatusNew &= ~(~bits & mask);

  modemStatusChanged = modemStatusOld ^ modemStatusNew;

  if (modemStatusChanged) {
    pIoPort->modemStatus = modemStatusNew;

    TraceModemStatus(pIoPort);

    SetModemStatusHolding(pIoPort);

    if (pIoPort->escapeChar && (pIoPort->insertMask & C0CE_INSERT_ENABLE_MST))
      InsertLsrMst(pIoPort, TRUE,
          (UCHAR)(pIoPort->modemStatus | (modemStatusChanged >> 4)), pQueueToComplete);

    if (modemStatusChanged & C0C_MSB_CTS)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_CTS;

    if (modemStatusChanged & C0C_MSB_DSR)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_DSR;

    if (modemStatusChanged & C0C_MSB_RING)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_RING;

    if (modemStatusChanged & C0C_MSB_RLSD)
      pIoPort->eventMask |= pIoPort->waitMask & SERIAL_EV_RLSD;

    WaitComplete(pIoPort, pQueueToComplete);
  }
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/wmi.c

/*
 * $Id: wmi.c,v 1.6 2008/12/02 16:10:09 vfrolov Exp $
 *
 * Copyright (c) 2006-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: wmi.c,v $
 * Revision 1.6  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.5  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.4  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.3  2006/10/27 12:44:14  vfrolov
 * Fixed typecasting
 *
 * Revision 1.2  2006/10/17 06:54:37  vfrolov
 * Disabled SERIAL_PORT_WMI_HW_GUID for binary compatibility with
 * both W2K and WXP
 *
 * Revision 1.1  2006/08/23 13:09:55  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include <wmidata.h>
#include <wmilib.h>
#pragma warning(push, 3)
#include <wmistr.h>
#pragma warning(pop)
#include "strutils.h"
#include "commprop.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 0xB

GUID guidWmiPortName       = SERIAL_PORT_WMI_NAME_GUID;
GUID guidWmiPortComm       = SERIAL_PORT_WMI_COMM_GUID;
#ifdef ALLOW_WMI_HW_GUID
GUID guidWmiPortHW         = SERIAL_PORT_WMI_HW_GUID;
#endif /* ALLOW_WMI_HW_GUID */
GUID guidWmiPortPerf       = SERIAL_PORT_WMI_PERF_GUID;
GUID guidWmiPortProperties = SERIAL_PORT_WMI_PROPERTIES_GUID;

enum COC_GUID_INDEX {
  COC_WMI_PORT_NAME,
  COC_WMI_PORT_COMM,
#ifdef ALLOW_WMI_HW_GUID
  COC_WMI_PORT_HW,
#endif /* ALLOW_WMI_HW_GUID */
  COC_WMI_PORT_PERF,
  COC_WMI_PORT_PROPERTIES,

  COC_WMI_LIST_SIZE
};

WMIGUIDREGINFO guidWmiList[COC_WMI_LIST_SIZE] = {
  {&guidWmiPortName,       1, 0},
  {&guidWmiPortComm,       1, 0},
#ifdef ALLOW_WMI_HW_GUID
  {&guidWmiPortHW,         1, 0},
#endif /* ALLOW_WMI_HW_GUID */
  {&guidWmiPortPerf,       1, 0},
  {&guidWmiPortProperties, 1, 0},
};

NTSTATUS QueryWmiRegInfo(
    IN PDEVICE_OBJECT pDevObj,
    OUT PULONG pRegFlags,
    OUT PUNICODE_STRING pInstanceName,
    OUT PUNICODE_STRING *ppRegistryPath,
    OUT PUNICODE_STRING pMofResourceName,
    OUT PDEVICE_OBJECT *ppPhDevObj)
{
  PC0C_FDOPORT_EXTENSION pDevExt = (PC0C_FDOPORT_EXTENSION)pDevObj->DeviceExtension;

  UNREFERENCED_PARAMETER(pInstanceName);
  UNREFERENCED_PARAMETER(pMofResourceName);

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiRegInfo");

  *ppRegistryPath = &c0cGlobal.registryPath;

  *pRegFlags = WMIREG_FLAG_INSTANCE_PDO;
  *ppPhDevObj = pDevExt->pIoPortLocal->pPhDevObj;

  return STATUS_SUCCESS;
}

NTSTATUS QueryWmiDataBlock(
    IN PDEVICE_OBJECT pDevObj,
    IN PIRP pIrp,
    IN ULONG guidIndex,
    IN ULONG instanceIndex,
    IN ULONG instanceCount,
    IN OUT PULONG pInstanceLengthArray,
    IN ULONG bufSize,
    OUT PUCHAR pBuf)
{
  NTSTATUS status;
  ULONG size;
  KIRQL oldIrql;
  PC0C_FDOPORT_EXTENSION pDevExt = (PC0C_FDOPORT_EXTENSION)pDevObj->DeviceExtension;
  PC0C_IO_PORT pIoPort = pDevExt->pIoPortLocal;

  UNREFERENCED_PARAMETER(instanceIndex);
  UNREFERENCED_PARAMETER(instanceCount);

  switch(guidIndex) {
  case COC_WMI_PORT_NAME:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiDataBlock PORT_NAME");

    size = (ULONG)wcslen(pDevExt->portName) * sizeof(pDevExt->portName[0]);

    if (bufSize < (size + sizeof(USHORT))) {
      size += sizeof(USHORT);
      status = STATUS_BUFFER_TOO_SMALL;
      break;
    }

    *(USHORT *)pBuf = (USHORT)size;
    RtlCopyMemory(pBuf + sizeof(USHORT), pDevExt->portName, size);

    size += sizeof(USHORT);
    status = STATUS_SUCCESS;
    break;
  case COC_WMI_PORT_COMM:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiDataBlock PORT_COMM");

    size = sizeof(SERIAL_WMI_COMM_DATA);

    if (bufSize < size) {
      status = STATUS_BUFFER_TOO_SMALL;
      break;
    }

    KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

    ((PSERIAL_WMI_COMM_DATA)pBuf)->BaudRate = pIoPort->baudRate.BaudRate;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->BitsPerByte = pIoPort->lineControl.WordLength;

    ((PSERIAL_WMI_COMM_DATA)pBuf)->ParityCheckEnable = TRUE;

    switch (pIoPort->lineControl.Parity) {
    default:
    case NO_PARITY:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->Parity = SERIAL_WMI_PARITY_NONE;
      ((PSERIAL_WMI_COMM_DATA)pBuf)->ParityCheckEnable = FALSE;
      break;
    case ODD_PARITY:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->Parity = SERIAL_WMI_PARITY_ODD;
      break;
    case EVEN_PARITY:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->Parity = SERIAL_WMI_PARITY_EVEN;
      break;
    case MARK_PARITY:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->Parity = SERIAL_WMI_PARITY_MARK;
      break;
    case SPACE_PARITY:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->Parity = SERIAL_WMI_PARITY_SPACE;
      break;
    }

    switch (pIoPort->lineControl.StopBits) {
    default:
    case STOP_BIT_1:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->StopBits = SERIAL_WMI_STOP_1;
      break;
    case STOP_BITS_1_5:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->StopBits = SERIAL_WMI_STOP_1_5;
      break;
    case STOP_BITS_2:
      ((PSERIAL_WMI_COMM_DATA)pBuf)->StopBits = SERIAL_WMI_STOP_2;
      break;
    }

    ((PSERIAL_WMI_COMM_DATA)pBuf)->XoffCharacter = pIoPort->specialChars.XoffChar;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->XoffXmitThreshold = pIoPort->handFlow.XoffLimit;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->XonCharacter = pIoPort->specialChars.XonChar;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->XonXmitThreshold = pIoPort->handFlow.XonLimit;

    KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

    ((PSERIAL_WMI_COMM_DATA)pBuf)->MaximumBaudRate = 128L * 1024L;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->MaximumOutputBufferSize = (ULONG)-1L;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->MaximumInputBufferSize = (ULONG)-1L;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->Support16BitMode = FALSE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SupportDTRDSR = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SupportIntervalTimeouts = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SupportParityCheck = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SupportRTSCTS = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SupportXonXoff = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SettableBaudRate = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SettableDataBits = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SettableFlowControl = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SettableParity = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SettableParityCheck = TRUE;
    ((PSERIAL_WMI_COMM_DATA)pBuf)->SettableStopBits = TRUE;

    ((PSERIAL_WMI_COMM_DATA)pBuf)->IsBusy = (BOOLEAN)pDevExt->openCount;

    status = STATUS_SUCCESS;
    break;
#ifdef ALLOW_WMI_HW_GUID
  /*
   * W2K and WXP have different SERIAL_WMI_HW_DATA structures
   * so we don't allow SERIAL_PORT_WMI_HW_GUID by default.
   * Define ALLOW_WMI_HW_GUID if you need it.
   */
  case COC_WMI_PORT_HW:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiDataBlock PORT_HW");

    size = sizeof(SERIAL_WMI_HW_DATA);

    if (bufSize < size) {
      status = STATUS_BUFFER_TOO_SMALL;
      break;
    }

    RtlZeroMemory((PSERIAL_WMI_HW_DATA)pBuf, size);

    status = STATUS_SUCCESS;
    break;
#endif /* ALLOW_WMI_HW_GUID */
  case COC_WMI_PORT_PERF:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiDataBlock PORT_PERF");

    size = sizeof(SERIAL_WMI_PERF_DATA);

    if (bufSize < size) {
      status = STATUS_BUFFER_TOO_SMALL;
      break;
    }

    KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

    ((PSERIAL_WMI_PERF_DATA)pBuf)->ReceivedCount = pIoPort->perfStats.ReceivedCount;
    ((PSERIAL_WMI_PERF_DATA)pBuf)->TransmittedCount = pIoPort->perfStats.TransmittedCount;
    ((PSERIAL_WMI_PERF_DATA)pBuf)->FrameErrorCount = pIoPort->perfStats.FrameErrorCount;
    ((PSERIAL_WMI_PERF_DATA)pBuf)->SerialOverrunErrorCount = pIoPort->perfStats.SerialOverrunErrorCount;
    ((PSERIAL_WMI_PERF_DATA)pBuf)->BufferOverrunErrorCount = pIoPort->perfStats.BufferOverrunErrorCount;
    ((PSERIAL_WMI_PERF_DATA)pBuf)->ParityErrorCount = pIoPort->perfStats.ParityErrorCount;

    KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

    status = STATUS_SUCCESS;
    break;
  case COC_WMI_PORT_PROPERTIES:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiDataBlock PORT_PROPERTIES");

    status = GetCommProp(pDevExt, pBuf, bufSize, &size);
    break;
  default:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"QueryWmiDataBlock ???");
    size = 0;
    status = STATUS_WMI_GUID_NOT_FOUND;
  }

  if (status == STATUS_SUCCESS)
    *pInstanceLengthArray = size;

  status = WmiCompleteRequest(pDevObj, pIrp, status, size, IO_NO_INCREMENT);

  return status;
}

NTSTATUS SetWmiDataBlock(
    IN PDEVICE_OBJECT pDevObj,
    IN PIRP pIrp,
    IN ULONG guidIndex,
    IN ULONG instanceIndex,
    IN ULONG bufSize,
    IN PUCHAR pBuf)
{
  NTSTATUS status;
  ULONG size = 0;

  UNREFERENCED_PARAMETER(guidIndex);
  UNREFERENCED_PARAMETER(instanceIndex);
  UNREFERENCED_PARAMETER(bufSize);
  UNREFERENCED_PARAMETER(pBuf);

  Trace0((PC0C_COMMON_EXTENSION)pDevObj->DeviceExtension, L"SetWmiDataBlock");

  status = STATUS_WMI_GUID_NOT_FOUND;

  status = WmiCompleteRequest(pDevObj, pIrp, status, size, IO_NO_INCREMENT);

  return status;
}

NTSTATUS SetWmiDataItem(
    IN PDEVICE_OBJECT pDevObj,
    IN PIRP pIrp,
    IN ULONG guidIndex,
    IN ULONG instanceIndex,
    IN ULONG dataItemId,
    IN ULONG bufSize,
    IN PUCHAR pBuf)
{
  NTSTATUS status;
  ULONG size = 0;

  UNREFERENCED_PARAMETER(guidIndex);
  UNREFERENCED_PARAMETER(instanceIndex);
  UNREFERENCED_PARAMETER(dataItemId);
  UNREFERENCED_PARAMETER(bufSize);
  UNREFERENCED_PARAMETER(pBuf);

  Trace0((PC0C_COMMON_EXTENSION)pDevObj->DeviceExtension, L"SetWmiDataItem");

  status = STATUS_WMI_GUID_NOT_FOUND;

  status = WmiCompleteRequest(pDevObj, pIrp, status, size, IO_NO_INCREMENT);

  return status;
}

WMILIB_CONTEXT wmiLibContext = {
  COC_WMI_LIST_SIZE,
  guidWmiList,

  QueryWmiRegInfo,
  QueryWmiDataBlock,
  SetWmiDataBlock,
  SetWmiDataItem,
  NULL /*ExecuteWmiMethod*/,
  NULL /*WmiFunctionControl*/
};

NTSTATUS FdoPortWmi(
    IN PC0C_FDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp)
{
  NTSTATUS status;
  SYSCTL_IRP_DISPOSITION disposition;

  status = WmiSystemControl(&wmiLibContext, pDevExt->pDevObj, pIrp, &disposition);

  switch(disposition) {
  case IrpProcessed:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"IrpProcessed");
    break;
  case IrpNotCompleted:
    TraceCode((PC0C_COMMON_EXTENSION)pDevExt, "IrpNotCompleted ", NULL,
        (ULONG)(ULONG_PTR)IoGetCurrentIrpStackLocation(pIrp)->Parameters.WMI.DataPath, &status);
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    break;
  case IrpForward:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"IrpForward");
    goto forward;
  case IrpNotWmi:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"IrpNotWmi");
    goto forward;
  default:
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Irp???");
    goto forward;
  forward:
    IoSkipCurrentIrpStackLocation(pIrp);
    status = IoCallDriver(pDevExt->pLowDevObj, pIrp);
  }

  return status;
}

NTSTATUS c0cSystemControlDispatch(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

#if ENABLE_TRACING
  ULONG code = IoGetCurrentIrpStackLocation(pIrp)->MinorFunction;
#endif /* ENABLE_TRACING */

  HALT_UNLESS2(IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_SYSTEM_CONTROL,
      IoGetCurrentIrpStackLocation(pIrp)->MajorFunction,
      IoGetCurrentIrpStackLocation(pIrp)->MinorFunction);

  TraceIrp("c0cSystemControlDispatch", pIrp, NULL, TRACE_FLAG_PARAMS);

  status = STATUS_NO_SUCH_DEVICE;

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    status = FdoPortWmi((PC0C_FDOPORT_EXTENSION)pDevExt, pIrp);
    break;
  case C0C_DOTYPE_FB:
    IoSkipCurrentIrpStackLocation(pIrp);
    status = IoCallDriver(((PC0C_COMMON_FDO_EXTENSION)pDevExt)->pLowDevObj, pIrp);
    break;
  case C0C_DOTYPE_PP:
    status = STATUS_NOT_SUPPORTED;
  default:
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

#if ENABLE_TRACING
  if (status != STATUS_SUCCESS)
    TraceCode(pDevExt, "WMI_", codeNameTableWmi, code, &status);
#endif /* ENABLE_TRACING */

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/timeout.c

/*
 * $Id: timeout.c,v 1.12 2010/08/04 10:38:56 vfrolov Exp $
 *
 * Copyright (c) 2004-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: timeout.c,v $
 * Revision 1.12  2010/08/04 10:38:56  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.11  2008/09/17 07:58:32  vfrolov
 * Added AddRTTO and AddRITO parameters
 *
 * Revision 1.10  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.9  2007/06/04 15:24:33  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.8  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.7  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.6  2006/06/08 11:33:35  vfrolov
 * Fixed bugs with amountInWriteQueue
 *
 * Revision 1.5  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.4  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.3  2005/08/16 16:36:33  vfrolov
 * Hidden timeout functions
 *
 * Revision 1.2  2005/07/14 13:51:09  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "timeout.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 3

VOID TimeoutRoutine(
    PC0C_IO_PORT pIoPort,
    IN PC0C_IRP_QUEUE pQueue)
{
  LIST_ENTRY queueToComplete;
  KIRQL oldIrql;

  InitializeListHead(&queueToComplete);

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  if (pQueue->pCurrent) {
    PC0C_IRP_STATE pState;

    pState = GetIrpState(pQueue->pCurrent);
    HALT_UNLESS(pState);

    pState->flags |= C0C_IRP_FLAG_EXPIRED;

    switch (pState->iQueue) {
      case C0C_QUEUE_WRITE:
        ReadWrite(pIoPort->pIoPortRemote, FALSE, pIoPort, FALSE, &queueToComplete);
        break;
      case C0C_QUEUE_READ:
        ReadWrite(pIoPort, FALSE, pIoPort->pIoPortRemote, FALSE, &queueToComplete);
        break;
      case C0C_QUEUE_CLOSE:
        FdoPortIo(C0C_IO_TYPE_CLOSE_COMPLETE,
                  NULL,
                  pIoPort,
                  &pIoPort->irpQueues[C0C_QUEUE_CLOSE],
                  &queueToComplete);
        break;
    }
  }

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  FdoPortCompleteQueue(&queueToComplete);
}

NTSTATUS SetReadTimeout(PC0C_IO_PORT pIoPort, PIRP pIrp)
{
  SERIAL_TIMEOUTS timeouts;
  BOOLEAN setTotal;
  ULONG multiplier;
  ULONG constant;
  PC0C_IRP_STATE pState;

  KeCancelTimer(&pIoPort->timerReadTotal);
  KeCancelTimer(&pIoPort->timerReadInterval);

  pState = GetIrpState(pIrp);
  HALT_UNLESS(pState);

  timeouts = pIoPort->timeouts;

  if (timeouts.ReadIntervalTimeout == MAXULONG &&
      !timeouts.ReadTotalTimeoutMultiplier &&
      !timeouts.ReadTotalTimeoutConstant) {
    return STATUS_SUCCESS;
  }

  setTotal = FALSE;
  multiplier = 0;
  constant = 0;

  if (timeouts.ReadIntervalTimeout == MAXULONG &&
      timeouts.ReadTotalTimeoutMultiplier == MAXULONG &&
      timeouts.ReadTotalTimeoutConstant < MAXULONG &&
      timeouts.ReadTotalTimeoutConstant > 0) {

    if (pIrp->IoStatus.Information) {
      return STATUS_SUCCESS;
    }

    pState->flags |= C0C_IRP_FLAG_WAIT_ONE;

    setTotal = TRUE;
    multiplier = 0;
    constant = timeouts.ReadTotalTimeoutConstant;
  } else {
    if (timeouts.ReadTotalTimeoutMultiplier || timeouts.ReadTotalTimeoutConstant) {
      setTotal = TRUE;
      multiplier = timeouts.ReadTotalTimeoutMultiplier;
      constant = timeouts.ReadTotalTimeoutConstant;
    }

    if (timeouts.ReadIntervalTimeout) {
      pState->flags |= C0C_IRP_FLAG_INTERVAL_TIMEOUT;

      pIoPort->timeoutInterval.QuadPart =
          ((LONGLONG)timeouts.ReadIntervalTimeout + pIoPort->addRITO) * -10000;

      if (pIrp->IoStatus.Information)
        SetIntervalTimeout(pIoPort);
    }
  }

  if (setTotal) {
    LARGE_INTEGER total;
    ULONG length;

    length = IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length;

    total.QuadPart = ((LONGLONG)(
        UInt32x32To64(length, multiplier) + constant + pIoPort->addRTTO)) * -10000;

    KeSetTimer(
        &pIoPort->timerReadTotal,
        total,
        &pIoPort->timerReadTotalDpc);
  }

  return STATUS_PENDING;
}

NTSTATUS SetWriteTimeout(PC0C_IO_PORT pIoPort, PIRP pIrp)
{
  SERIAL_TIMEOUTS timeouts;
  BOOLEAN setTotal;
  ULONG multiplier;
  ULONG constant;

  KeCancelTimer(&pIoPort->timerWriteTotal);

  timeouts = pIoPort->timeouts;

  setTotal = FALSE;
  multiplier = 0;
  constant = 0;

  if (timeouts.WriteTotalTimeoutMultiplier || timeouts.WriteTotalTimeoutConstant) {
    setTotal = TRUE;
    multiplier = timeouts.WriteTotalTimeoutMultiplier;
    constant = timeouts.WriteTotalTimeoutConstant;
  }

  if (setTotal) {
    LARGE_INTEGER total;
    ULONG length;

    length = GetWriteLength(pIrp);

    total.QuadPart = ((LONGLONG)(UInt32x32To64(length, multiplier) + constant)) * -10000;

    KeSetTimer(
        &pIoPort->timerWriteTotal,
        total,
        &pIoPort->timerWriteTotalDpc);
  }

  return STATUS_PENDING;
}

VOID SetXoffCounterTimeout(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp)
{
  PSERIAL_XOFF_COUNTER pXoffCounter;
  LARGE_INTEGER total;

  KeCancelTimer(&pIoPort->timerWriteTotal);

  pXoffCounter = (PSERIAL_XOFF_COUNTER)pIrp->AssociatedIrp.SystemBuffer;

  if (pXoffCounter->Timeout) {
    total.QuadPart = ((LONGLONG)pXoffCounter->Timeout) * -10000;

    KeSetTimer(
        &pIoPort->timerWriteTotal,
        total,
        &pIoPort->timerWriteTotalDpc);
  }
}

KDEFERRED_ROUTINE TimeoutReadTotal;
VOID TimeoutReadTotal(
    IN PKDPC pDpc,
    IN PVOID deferredContext,
    IN PVOID systemArgument1,
    IN PVOID systemArgument2)
{
  PC0C_IO_PORT pIoPort;

  UNREFERENCED_PARAMETER(pDpc);
  UNREFERENCED_PARAMETER(systemArgument1);
  UNREFERENCED_PARAMETER(systemArgument2);

  HALT_UNLESS(deferredContext != NULL);

  pIoPort = (PC0C_IO_PORT)deferredContext;

  TimeoutRoutine(pIoPort, &pIoPort->irpQueues[C0C_QUEUE_READ]);
}

KDEFERRED_ROUTINE TimeoutReadInterval;
VOID TimeoutReadInterval(
    IN PKDPC pDpc,
    IN PVOID deferredContext,
    IN PVOID systemArgument1,
    IN PVOID systemArgument2)
{
  PC0C_IO_PORT pIoPort;

  UNREFERENCED_PARAMETER(pDpc);
  UNREFERENCED_PARAMETER(systemArgument1);
  UNREFERENCED_PARAMETER(systemArgument2);

  HALT_UNLESS(deferredContext != NULL);

  pIoPort = (PC0C_IO_PORT)deferredContext;

  TimeoutRoutine(pIoPort, &pIoPort->irpQueues[C0C_QUEUE_READ]);
}

KDEFERRED_ROUTINE TimeoutWriteTotal;
VOID TimeoutWriteTotal(
    IN PKDPC pDpc,
    IN PVOID deferredContext,
    IN PVOID systemArgument1,
    IN PVOID systemArgument2)
{
  PC0C_IO_PORT pIoPort;

  UNREFERENCED_PARAMETER(pDpc);
  UNREFERENCED_PARAMETER(systemArgument1);
  UNREFERENCED_PARAMETER(systemArgument2);

  HALT_UNLESS(deferredContext != NULL);

  pIoPort = (PC0C_IO_PORT)deferredContext;

  TimeoutRoutine(pIoPort, &pIoPort->irpQueues[C0C_QUEUE_WRITE]);
}

KDEFERRED_ROUTINE TimeoutClose;
VOID TimeoutClose(
    IN PKDPC pDpc,
    IN PVOID deferredContext,
    IN PVOID systemArgument1,
    IN PVOID systemArgument2)
{
  PC0C_IO_PORT pIoPort;

  UNREFERENCED_PARAMETER(pDpc);
  UNREFERENCED_PARAMETER(systemArgument1);
  UNREFERENCED_PARAMETER(systemArgument2);

  HALT_UNLESS(deferredContext != NULL);

  pIoPort = (PC0C_IO_PORT)deferredContext;

  TimeoutRoutine(pIoPort, &pIoPort->irpQueues[C0C_QUEUE_CLOSE]);
}

VOID AllocTimeouts(PC0C_IO_PORT pIoPort)
{
  KeInitializeTimer(&pIoPort->timerReadTotal);
  KeInitializeTimer(&pIoPort->timerReadInterval);
  KeInitializeTimer(&pIoPort->timerWriteTotal);
  KeInitializeTimer(&pIoPort->timerClose);

  KeInitializeDpc(&pIoPort->timerReadTotalDpc, TimeoutReadTotal, pIoPort);
  KeInitializeDpc(&pIoPort->timerReadIntervalDpc, TimeoutReadInterval, pIoPort);
  KeInitializeDpc(&pIoPort->timerWriteTotalDpc, TimeoutWriteTotal, pIoPort);
  KeInitializeDpc(&pIoPort->timerCloseDpc, TimeoutClose, pIoPort);
}

VOID FreeTimeouts(PC0C_IO_PORT pIoPort)
{
    KeCancelTimer(&pIoPort->timerReadTotal);
    KeCancelTimer(&pIoPort->timerReadInterval);
    KeCancelTimer(&pIoPort->timerWriteTotal);
    KeCancelTimer(&pIoPort->timerClose);

    KeRemoveQueueDpc(&pIoPort->timerReadTotalDpc);
    KeRemoveQueueDpc(&pIoPort->timerReadIntervalDpc);
    KeRemoveQueueDpc(&pIoPort->timerWriteTotalDpc);
    KeRemoveQueueDpc(&pIoPort->timerCloseDpc);
}

VOID SetIntervalTimeout(PC0C_IO_PORT pIoPort)
{
  KeSetTimer(&pIoPort->timerReadInterval, pIoPort->timeoutInterval, &pIoPort->timerReadIntervalDpc);
}

VOID SetCloseTimeout(PC0C_IO_PORT pIoPort)
{
  LARGE_INTEGER total;

  total.QuadPart = ((LONGLONG)1000) * -10000;

  KeSetTimer(&pIoPort->timerClose, total, &pIoPort->timerCloseDpc);
}

NTSTATUS SetIrpTimeout(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp)
{
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  switch (pIrpStack->MajorFunction) {
  case IRP_MJ_WRITE:
    return SetWriteTimeout(pIoPort, pIrp);
  case IRP_MJ_DEVICE_CONTROL:
    switch (pIrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SERIAL_XOFF_COUNTER:
    case IOCTL_SERIAL_IMMEDIATE_CHAR:
      return SetWriteTimeout(pIoPort, pIrp);
    }
    break;
  case IRP_MJ_READ:
    return SetReadTimeout(pIoPort, pIrp);
  }

  return STATUS_PENDING;
}

NTSTATUS FdoPortSetTimeouts(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp,
    PIO_STACK_LOCATION pIrpStack)
{
  KIRQL oldIrql;
  PSERIAL_TIMEOUTS pSysBuf;

  if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_TIMEOUTS))
    return STATUS_BUFFER_TOO_SMALL;

  pSysBuf = (PSERIAL_TIMEOUTS)pIrp->AssociatedIrp.SystemBuffer;

  if (pSysBuf->ReadIntervalTimeout == MAXULONG &&
      pSysBuf->ReadTotalTimeoutMultiplier == MAXULONG &&
      pSysBuf->ReadTotalTimeoutConstant == MAXULONG)
    return STATUS_INVALID_PARAMETER;

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);
  pIoPort->timeouts = *pSysBuf;
  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  return STATUS_SUCCESS;
}

NTSTATUS FdoPortGetTimeouts(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp,
    PIO_STACK_LOCATION pIrpStack)
{
  KIRQL oldIrql;
  PSERIAL_TIMEOUTS pSysBuf;

  if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_TIMEOUTS))
    return STATUS_BUFFER_TOO_SMALL;

  pSysBuf = (PSERIAL_TIMEOUTS)pIrp->AssociatedIrp.SystemBuffer;

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);
  *pSysBuf = pIoPort->timeouts;
  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  pIrp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);

  return STATUS_SUCCESS;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/openclos.c

/*
 * $Id: openclos.c,v 1.27 2011/12/16 17:35:17 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: openclos.c,v $
 * Revision 1.27  2011/12/16 17:35:17  vfrolov
 * Added resuming i/o after opening port (Bugs item #3460850)
 *
 * Revision 1.26  2011/07/26 16:07:42  vfrolov
 * Fixed double closing
 *
 * Revision 1.25  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.24  2008/07/11 10:38:00  vfrolov
 * Added nonstandard ability to enable LSR insertion on BREAK OFF
 *
 * Revision 1.23  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.22  2008/04/08 10:30:35  vfrolov
 * Fixed modem control setting on close
 *
 * Revision 1.21  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.20  2007/09/17 14:31:06  vfrolov
 * Implemented pseudo pin OPEN
 *
 * Revision 1.19  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.18  2007/06/04 15:24:32  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.17  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.16  2007/01/11 14:50:29  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.15  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.14  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.13  2006/06/08 11:33:35  vfrolov
 * Fixed bugs with amountInWriteQueue
 *
 * Revision 1.12  2006/04/05 07:22:15  vfrolov
 * Replaced flipXoffLimit flag by writeHoldingRemote to correct handFlow changing
 *
 * Revision 1.11  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.10  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.9  2005/11/30 16:04:12  vfrolov
 * Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
 *
 * Revision 1.8  2005/11/29 12:33:21  vfrolov
 * Changed SetModemStatus() to ability set and clear bits simultaneously
 *
 * Revision 1.7  2005/11/28 12:57:16  vfrolov
 * Moved some C0C_BUFFER code to bufutils.c
 *
 * Revision 1.6  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.5  2005/05/14 17:07:02  vfrolov
 * Implemented SERIAL_LSRMST_MST insertion
 *
 * Revision 1.4  2005/05/13 16:58:03  vfrolov
 * Implemented IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.3  2005/02/01 16:51:51  vfrolov
 * Used C0C_BUFFER_PURGE()
 *
 * Revision 1.2  2005/02/01 08:37:55  vfrolov
 * Changed SetModemStatus() to set multiple bits
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "handflow.h"
#include "bufutils.h"
#include "strutils.h"
#include "timeout.h"
#include "delay.h"

NTSTATUS FdoPortOpen(IN PC0C_FDOPORT_EXTENSION pDevExt)
{
  LIST_ENTRY queueToComplete;
  PUCHAR pBase;
  ULONG size;
  KIRQL oldIrql;
  PC0C_IO_PORT pIoPort;

  if (InterlockedIncrement(&pDevExt->openCount) != 1) {
    InterlockedDecrement(&pDevExt->openCount);
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"FdoPortOpen ACCESS_DENIED (openCount > 0)");
    return STATUS_ACCESS_DENIED;
  }

  pIoPort = pDevExt->pIoPortLocal;

  if (pIoPort->plugInMode && !pIoPort->pIoPortRemote->isOpen) {
    InterlockedDecrement(&pDevExt->openCount);
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"FdoPortOpen ACCESS_DENIED (plugInMode && !pIoPortRemote->isOpen)");
    return STATUS_ACCESS_DENIED;
  }

  if (pIoPort->exclusiveMode)
    IoInvalidateDeviceRelations(pIoPort->pPhDevObj, BusRelations);

  switch (MmQuerySystemSize()) {
  case MmLargeSystem:
    size = 4096;
    pBase = (PUCHAR)C0C_ALLOCATE_POOL(NonPagedPool, size);
    if (pBase)
      break;
  case MmMediumSystem:
    size = 1024;
    pBase = (PUCHAR)C0C_ALLOCATE_POOL(NonPagedPool, size);
    if (pBase)
      break;
  case MmSmallSystem:
    size = 128;
    pBase = (PUCHAR)C0C_ALLOCATE_POOL(NonPagedPool, size);
    if (pBase)
      break;
  default:
    size = 0;
    pBase = NULL;
  }

  InitializeListHead(&queueToComplete);

#if ENABLE_TRACING
  if (pIoPort->amountInWriteQueue) {
    NTSTATUS status;
    UNICODE_STRING msg;

    status = STATUS_SUCCESS;
    RtlInitUnicodeString(&msg, NULL);
    StrAppendStr0(&status, &msg, L"!!!WARNING!!! amountInWriteQueue = ");
    StrAppendNum(&status, &msg, pIoPort->amountInWriteQueue, 10);

    Trace0((PC0C_COMMON_EXTENSION)pDevExt, msg.Buffer);

    StrFree(&msg);
  }
#endif /* ENABLE_TRACING */

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  InitBuffer(&pIoPort->readBuf, pBase, size);

  pIoPort->amountInWriteQueue = 0;
  pIoPort->tryWrite = FALSE;
  pIoPort->errors = 0;
  pIoPort->waitMask = 0;
  pIoPort->eventMask = 0;
  RtlZeroMemory(&pIoPort->perfStats, sizeof(pIoPort->perfStats));
  pIoPort->handFlow.XoffLimit = size >> 3;
  pIoPort->handFlow.XonLimit = size >> 1;
  pIoPort->pIoPortRemote->brokeIdleChars = 0;

  SetHandFlow(pIoPort, NULL, &queueToComplete);
  SetModemControl(pIoPort, C0C_MCR_OPEN, C0C_MCR_OPEN, &queueToComplete);

  ReadWrite(
      pIoPort, FALSE,
      pIoPort->pIoPortRemote, FALSE,
      &queueToComplete);

  if (pIoPort->pIoPortRemote->pWriteDelay && pIoPort->pIoPortRemote->brokeCharsProbability > 0)
    StartWriteDelayTimer(pIoPort->pIoPortRemote->pWriteDelay);

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  pIoPort->isOpen = TRUE;

  if (pIoPort->pIoPortRemote->plugInMode)
    IoInvalidateDeviceRelations(pIoPort->pIoPortRemote->pPhDevObj, BusRelations);

  FdoPortCompleteQueue(&queueToComplete);

  return STATUS_SUCCESS;
}

NTSTATUS StartIrpClose(
    IN PC0C_IO_PORT pIoPort,
    IN PLIST_ENTRY pQueueToComplete)
{
  UNREFERENCED_PARAMETER(pQueueToComplete);

  if (!pIoPort->exclusiveMode) {
    PIRP pIrp;

    InterlockedDecrement(&pIoPort->pDevExt->openCount);
    pIrp = pIoPort->irpQueues[C0C_QUEUE_CLOSE].pCurrent;
    pIrp->IoStatus.Information = 0;
    return STATUS_SUCCESS;
  }

  IoInvalidateDeviceRelations(pIoPort->pPhDevObj, BusRelations);
  SetCloseTimeout(pIoPort);

  return STATUS_PENDING;
}

NTSTATUS FdoPortClose(IN PC0C_FDOPORT_EXTENSION pDevExt, IN PIRP pIrp)
{
  NTSTATUS status;
  LIST_ENTRY queueToComplete;
  KIRQL oldIrql;
  PC0C_IO_PORT pIoPort;

  pIoPort = pDevExt->pIoPortLocal;

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  if (!pIoPort->isOpen) {
    KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"FdoPortClose INVALID_DEVICE_REQUEST (!isOpen)");

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;
  }

  pIoPort->isOpen = FALSE;

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  if (pIoPort->pIoPortRemote->plugInMode)
    IoInvalidateDeviceRelations(pIoPort->pIoPortRemote->pPhDevObj, BusRelations);

  InitializeListHead(&queueToComplete);

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  pIoPort->escapeChar = 0;
  pIoPort->writeHoldingRemote = 0;
  pIoPort->sendXonXoff = 0;
  SetModemControl(pIoPort, C0C_MCR_OUT2, C0C_MCR_MASK | C0C_MCR_OPEN, &queueToComplete);
  FreeBuffer(&pIoPort->readBuf);
  SetBreakHolding(pIoPort, FALSE, &queueToComplete);

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  FdoPortCompleteQueue(&queueToComplete);

  status = FdoPortStartIrp(pIoPort, pIrp, C0C_QUEUE_CLOSE, StartIrpClose);

  if (status != STATUS_PENDING) {
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}

NTSTATUS c0cOpen(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

  TraceIrp("--- Open ---", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    status = FdoPortOpen((PC0C_FDOPORT_EXTENSION)pDevExt);
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
  }

  pIrp->IoStatus.Information = 0;

#if ENABLE_TRACING
  if (!NT_SUCCESS(status))
    TraceIrp("c0cOpen", pIrp, &status, TRACE_FLAG_RESULTS);
#endif /* ENABLE_TRACING */

  pIrp->IoStatus.Status = status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}

NTSTATUS c0cClose(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

#if ENABLE_TRACING
  ULONG code = IoGetCurrentIrpStackLocation(pIrp)->MajorFunction;
#endif /* ENABLE_TRACING */

  TraceIrp("--- Close ---", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    status = FdoPortClose((PC0C_FDOPORT_EXTENSION)pDevExt, pIrp);
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

#if ENABLE_TRACING
  if (status != STATUS_SUCCESS)
    TraceCode(pDevExt, "IRP_MJ_", codeNameTableIrpMj, code, &status);
#endif /* ENABLE_TRACING */

  return status;
}

NTSTATUS c0cCleanup(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

  TraceIrp("c0cCleanup", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    FdoPortCancelQueues(((PC0C_FDOPORT_EXTENSION)pDevExt)->pIoPortLocal);

    status = STATUS_SUCCESS;
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
  }

  pIrp->IoStatus.Information = 0;

  TraceIrp("c0cCleanup", pIrp, &status, TRACE_FLAG_RESULTS);

  pIrp->IoStatus.Status = status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/makefile

!INCLUDE $(NTMAKEENV)\makefile.def


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/handflow.c

/*
 * $Id: handflow.c,v 1.13 2010/12/27 14:14:06 vfrolov Exp $
 *
 * Copyright (c) 2005-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: handflow.c,v $
 * Revision 1.13  2010/12/27 14:14:06  vfrolov
 * Added cleaning SERIAL_TX_WAITING_FOR_XON on opening port
 *
 * Revision 1.12  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.11  2008/08/25 14:18:58  vfrolov
 * Fixed SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.10  2008/08/19 12:40:58  vfrolov
 * Replaces C0CE_INSERT_ENABLE_LSR_NBI (insertion on BREAK OFF)
 * by C0CE_INSERT_ENABLE_LSR_BI (insertion on BREAK change)
 *
 * Revision 1.9  2008/07/11 10:38:00  vfrolov
 * Added nonstandard ability to enable LSR insertion on BREAK OFF
 *
 * Revision 1.8  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.7  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.6  2006/05/19 12:16:19  vfrolov
 * Implemented SERIAL_XOFF_CONTINUE
 *
 * Revision 1.5  2006/05/17 15:31:14  vfrolov
 * Implemented SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.4  2006/04/05 07:22:15  vfrolov
 * Replaced flipXoffLimit flag by writeHoldingRemote to correct handFlow changing
 *
 * Revision 1.3  2006/03/15 13:49:15  vfrolov
 * Fixed [1446861] Problems with setting DCB.fOutxCtsFlow and DCB.fRtsControl
 * Thanks to Brad (bdwade100 at users.sourceforge.net)
 *
 * Revision 1.2  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.1  2006/01/10 10:12:05  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "handflow.h"
#include "bufutils.h"
#include "../include/cncext.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 9

NTSTATUS SetHandFlow(
    PC0C_IO_PORT pIoPort,
    PSERIAL_HANDFLOW pHandFlow,
    PLIST_ENTRY pQueueToComplete)
{
  UCHAR bits, mask;
  PC0C_BUFFER pReadBuf;
  PSERIAL_HANDFLOW pNewHandFlow;
  BOOLEAN setModemStatusHolding;

  pReadBuf = &pIoPort->readBuf;

  if (pHandFlow) {
    if ((pIoPort->escapeChar && (pHandFlow->FlowReplace & SERIAL_ERROR_CHAR)) ||
        ((SIZE_T)pHandFlow->XonLimit > C0C_BUFFER_SIZE(pReadBuf)) ||
        ((SIZE_T)pHandFlow->XoffLimit > C0C_BUFFER_SIZE(pReadBuf)))
    {
      return STATUS_INVALID_PARAMETER;
    }

    pNewHandFlow = pHandFlow;
  } else {
    pNewHandFlow = &pIoPort->handFlow;
  }

  // Set local side
  if (!pHandFlow)
    pIoPort->writeHolding &= ~SERIAL_TX_WAITING_FOR_XON;

  if (pHandFlow &&
      ((pIoPort->handFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) != 0) &&
      ((pHandFlow->FlowReplace & SERIAL_AUTO_TRANSMIT) == 0))
  {
    SetXonXoffHolding(pIoPort, C0C_XCHAR_ON);
  }

  if (!pHandFlow ||
      (pIoPort->handFlow.ControlHandShake & SERIAL_OUT_HANDSHAKEMASK) !=
          (pHandFlow->ControlHandShake & SERIAL_OUT_HANDSHAKEMASK))
  {
    setModemStatusHolding = TRUE;
  } else {
    setModemStatusHolding = FALSE;
  }

  // Set remote side
  bits = mask = 0;

  if (!pHandFlow ||
      (pIoPort->handFlow.FlowReplace & SERIAL_RTS_MASK) !=
          (pHandFlow->FlowReplace & SERIAL_RTS_MASK))
  {
    switch (pNewHandFlow->FlowReplace & SERIAL_RTS_MASK) {
    case 0:
      pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_CTS;
      mask |= C0C_MCR_RTS;
      break;
    case SERIAL_RTS_CONTROL:
      pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_CTS;
      bits |= C0C_MCR_RTS;
      mask |= C0C_MCR_RTS;
      break;
    case SERIAL_RTS_HANDSHAKE:
      if (C0C_BUFFER_BUSY(pReadBuf) > (C0C_BUFFER_SIZE(pReadBuf) - pNewHandFlow->XoffLimit)) {
        pIoPort->writeHoldingRemote |= SERIAL_TX_WAITING_FOR_CTS;
        mask |= C0C_MCR_RTS;
      }
      else
      if (pIoPort->writeHoldingRemote & SERIAL_TX_WAITING_FOR_CTS) {
        if (C0C_BUFFER_BUSY(pReadBuf) <= (SIZE_T)pNewHandFlow->XonLimit) {
          pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_CTS;
          bits |= C0C_MCR_RTS;
          mask |= C0C_MCR_RTS;
        }
      }
      else {
        bits |= C0C_MCR_RTS;
        mask |= C0C_MCR_RTS;
      }
    }
  }

  if (!pHandFlow ||
      (pIoPort->handFlow.ControlHandShake & SERIAL_DTR_MASK) !=
          (pHandFlow->ControlHandShake & SERIAL_DTR_MASK))
  {
    switch (pNewHandFlow->ControlHandShake & SERIAL_DTR_MASK) {
    case 0:
      pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_DSR;
      mask |= C0C_MCR_DTR;
      break;
    case SERIAL_DTR_CONTROL:
      pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_DSR;
      bits |= C0C_MCR_DTR;
      mask |= C0C_MCR_DTR;
      break;
    case SERIAL_DTR_HANDSHAKE:
      if (C0C_BUFFER_BUSY(pReadBuf) > (C0C_BUFFER_SIZE(pReadBuf) - pNewHandFlow->XoffLimit)) {
        pIoPort->writeHoldingRemote |= SERIAL_TX_WAITING_FOR_DSR;
        mask |= C0C_MCR_DTR;
      }
      else
      if (pIoPort->writeHoldingRemote & SERIAL_TX_WAITING_FOR_DSR) {
        if (C0C_BUFFER_BUSY(pReadBuf) <= (SIZE_T)pNewHandFlow->XonLimit) {
          pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_DSR;
          bits |= C0C_MCR_DTR;
          mask |= C0C_MCR_DTR;
        }
      }
      else {
        bits |= C0C_MCR_DTR;
        mask |= C0C_MCR_DTR;
      }
    }
  }

  if (!pHandFlow ||
      (pIoPort->handFlow.FlowReplace & SERIAL_AUTO_RECEIVE) !=
          (pHandFlow->FlowReplace & SERIAL_AUTO_RECEIVE))
  {
    if (pNewHandFlow->FlowReplace & SERIAL_AUTO_RECEIVE) {
      if (C0C_BUFFER_BUSY(pReadBuf) > (C0C_BUFFER_SIZE(pReadBuf) - pNewHandFlow->XoffLimit)) {
        pIoPort->writeHoldingRemote |= SERIAL_TX_WAITING_FOR_XON;
        if ((pNewHandFlow->FlowReplace & SERIAL_XOFF_CONTINUE) == 0)
          pIoPort->writeHolding |= SERIAL_TX_WAITING_FOR_XON;
        pIoPort->sendXonXoff = C0C_XCHAR_OFF;
        pIoPort->tryWrite = TRUE;
      }
    }
    else
    if (pIoPort->writeHoldingRemote & SERIAL_TX_WAITING_FOR_XON) {
      pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_XON;
      pIoPort->writeHolding &= ~SERIAL_TX_WAITING_FOR_XON;
      if (pIoPort->sendXonXoff != C0C_XCHAR_OFF) {
        // XOFF was sent so send XON
        pIoPort->sendXonXoff = C0C_XCHAR_ON;
        pIoPort->tryWrite = TRUE;
      } else {
        // XOFF still was not sent so cancel it
        pIoPort->sendXonXoff = 0;
      }
    }
  }

  if (pHandFlow)
    pIoPort->handFlow = *pHandFlow;

  if (setModemStatusHolding)
    SetModemStatusHolding(pIoPort);

  if (mask)
    SetModemControl(pIoPort, bits, mask, pQueueToComplete);

  UpdateTransmitToggle(pIoPort, pQueueToComplete);

  SetLimit(pIoPort->pIoPortRemote);
  SetLimit(pIoPort);

  if (pIoPort->pIoPortRemote->tryWrite) {
    ReadWrite(
        pIoPort, FALSE,
        pIoPort->pIoPortRemote, FALSE,
        pQueueToComplete);
  }

  if (pIoPort->tryWrite) {
    ReadWrite(
        pIoPort->pIoPortRemote, FALSE,
        pIoPort, FALSE,
        pQueueToComplete);
  }

  return STATUS_SUCCESS;
}

VOID UpdateHandFlow(
    PC0C_IO_PORT pIoPort,
    BOOLEAN freed,
    PLIST_ENTRY pQueueToComplete)
{
  UCHAR bits, mask;
  PC0C_BUFFER pReadBuf;
  PSERIAL_HANDFLOW pHandFlowLocal, pHandFlowRemote;

  pHandFlowLocal = &pIoPort->handFlow;
  pHandFlowRemote = &pIoPort->pIoPortRemote->handFlow;
  pReadBuf = &pIoPort->readBuf;

  bits = mask = 0;

  if (!pIoPort->writeHoldingRemote) {
    if (!freed && C0C_BUFFER_BUSY(pReadBuf) > (C0C_BUFFER_SIZE(pReadBuf) - pHandFlowLocal->XoffLimit)) {
      if ((pHandFlowLocal->FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE) {
        pIoPort->writeHoldingRemote |= SERIAL_TX_WAITING_FOR_CTS;
        mask |= C0C_MCR_RTS;
      }

      if ((pHandFlowLocal->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE) {
        pIoPort->writeHoldingRemote |= SERIAL_TX_WAITING_FOR_DSR;
        mask |= C0C_MCR_DTR;
      }

      if (pHandFlowLocal->FlowReplace & SERIAL_AUTO_RECEIVE) {
        pIoPort->writeHoldingRemote |= SERIAL_TX_WAITING_FOR_XON;
        if ((pHandFlowLocal->FlowReplace & SERIAL_XOFF_CONTINUE) == 0)
          pIoPort->writeHolding |= SERIAL_TX_WAITING_FOR_XON;
        pIoPort->sendXonXoff = C0C_XCHAR_OFF;
        pIoPort->tryWrite = TRUE;
      }
    }
  } else {
    if (freed && C0C_BUFFER_BUSY(pReadBuf) <= (SIZE_T)pHandFlowLocal->XonLimit) {
      if ((pHandFlowLocal->FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE) {
        pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_CTS;
        bits |= C0C_MCR_RTS;
        mask |= C0C_MCR_RTS;
      }

      if ((pHandFlowLocal->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE) {
        pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_DSR;
        bits |= C0C_MCR_DTR;
        mask |= C0C_MCR_DTR;
      }

      if (pHandFlowLocal->FlowReplace & SERIAL_AUTO_RECEIVE) {
        pIoPort->writeHoldingRemote &= ~SERIAL_TX_WAITING_FOR_XON;
        pIoPort->writeHolding &= ~SERIAL_TX_WAITING_FOR_XON;
        pIoPort->sendXonXoff = C0C_XCHAR_ON;
        pIoPort->tryWrite = TRUE;
      }
    }
  }

  if (mask)
    SetModemControl(pIoPort, bits, mask, pQueueToComplete);
}

VOID UpdateTransmitToggle(
    PC0C_IO_PORT pIoPort,
    PLIST_ENTRY pQueueToComplete)
{
  if ((pIoPort->handFlow.FlowReplace & SERIAL_RTS_MASK) == SERIAL_TRANSMIT_TOGGLE) {
    UCHAR bits;

    if ((pIoPort->writeHolding & SERIAL_TX_WAITING_ON_BREAK) != 0 ||
        !C0C_TX_BUFFER_EMPTY(&pIoPort->txBuf) ||
        (pIoPort->irpQueues[C0C_QUEUE_WRITE].pCurrent && !pIoPort->writeHolding) ||
        (pIoPort->sendXonXoff && (pIoPort->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) == 0))
    {
      bits = C0C_MCR_RTS;
    } else {
      bits = 0;
    }

    SetModemControl(pIoPort, bits, C0C_MCR_RTS, pQueueToComplete);
  }
}

VOID SetLimit(PC0C_IO_PORT pIoPort)
{
  PC0C_BUFFER pReadBuf;
  SIZE_T limit;
  PSERIAL_HANDFLOW pHandFlowLocal, pHandFlowRemote;

  pHandFlowLocal = &pIoPort->handFlow;
  pHandFlowRemote = &pIoPort->pIoPortRemote->handFlow;
  pReadBuf = &pIoPort->readBuf;

  /* DCD = DSR */
  #define C0C_DSR_HANDSHAKE (SERIAL_DSR_HANDSHAKE|SERIAL_DCD_HANDSHAKE)

  if ((((pHandFlowLocal->FlowReplace & SERIAL_RTS_MASK) == SERIAL_RTS_HANDSHAKE) &&
                             (pHandFlowRemote->ControlHandShake & SERIAL_CTS_HANDSHAKE)) ||
      (((pHandFlowLocal->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_HANDSHAKE) &&
                             (pHandFlowRemote->ControlHandShake & C0C_DSR_HANDSHAKE)))
  {
    limit = C0C_BUFFER_SIZE(pReadBuf) - pHandFlowLocal->XoffLimit + 1;
  } else {
    limit = C0C_BUFFER_SIZE(pReadBuf);
  }
  SetBufferLimit(pReadBuf, limit);
}

VOID SetModemStatusHolding(PC0C_IO_PORT pIoPort)
{
  ULONG writeHolding;
  PSERIAL_HANDFLOW pHandFlow;

  pHandFlow = &pIoPort->handFlow;
  writeHolding = pIoPort->writeHolding;

  if ((pHandFlow->ControlHandShake & SERIAL_CTS_HANDSHAKE) && !(pIoPort->modemStatus & C0C_MSB_CTS))
    writeHolding |= SERIAL_TX_WAITING_FOR_CTS;
  else
    writeHolding &= ~SERIAL_TX_WAITING_FOR_CTS;

  if ((pHandFlow->ControlHandShake & SERIAL_DSR_HANDSHAKE) && !(pIoPort->modemStatus & C0C_MSB_DSR))
    writeHolding |= SERIAL_TX_WAITING_FOR_DSR;
  else
    writeHolding &= ~SERIAL_TX_WAITING_FOR_DSR;

  if ((pHandFlow->ControlHandShake & SERIAL_DCD_HANDSHAKE) && !(pIoPort->modemStatus & C0C_MSB_RLSD))
    writeHolding |= SERIAL_TX_WAITING_FOR_DCD;
  else
    writeHolding &= ~SERIAL_TX_WAITING_FOR_DCD;

  if (!(writeHolding & ~SERIAL_TX_WAITING_FOR_XON) &&
      (pIoPort->writeHolding & ~SERIAL_TX_WAITING_FOR_XON))
  {
    if (pIoPort->sendXonXoff || (!writeHolding && pIoPort->irpQueues[C0C_QUEUE_WRITE].pCurrent))
      pIoPort->tryWrite = TRUE;
  }

  pIoPort->writeHolding = writeHolding;
}

VOID SetXonXoffHolding(PC0C_IO_PORT pIoPort, short xonXoff)
{
  switch (xonXoff) {
  case C0C_XCHAR_ON:
    if (pIoPort->writeHolding & SERIAL_TX_WAITING_FOR_XON) {
      pIoPort->writeHolding &= ~SERIAL_TX_WAITING_FOR_XON;

      if (!pIoPort->writeHolding && pIoPort->irpQueues[C0C_QUEUE_WRITE].pCurrent)
        pIoPort->tryWrite = TRUE;
    }
    break;
  case C0C_XCHAR_OFF:
    pIoPort->writeHolding |= SERIAL_TX_WAITING_FOR_XON;
    break;
  }
}

VOID SetBreakHolding(PC0C_IO_PORT pIoPort, BOOLEAN on, PLIST_ENTRY pQueueToComplete)
{
  if (on) {
    if ((pIoPort->writeHolding & SERIAL_TX_WAITING_ON_BREAK) == 0) {
      pIoPort->writeHolding |= SERIAL_TX_WAITING_ON_BREAK;
      pIoPort->sendBreak = TRUE;
      pIoPort->tryWrite = TRUE;
    }
  } else {
    if (pIoPort->writeHolding & SERIAL_TX_WAITING_ON_BREAK) {
      PC0C_IO_PORT pIoPortRead;

      pIoPort->writeHolding &= ~SERIAL_TX_WAITING_ON_BREAK;
      pIoPort->sendBreak = FALSE;

      pIoPortRead = pIoPort->pIoPortRemote;

      pIoPortRead->rcvdBreak = FALSE;

      if (pIoPortRead->escapeChar && (pIoPortRead->insertMask & C0CE_INSERT_ENABLE_LSR_BI)) {
        UCHAR lsr = 0;

        if (C0C_TX_BUFFER_THR_EMPTY(&pIoPortRead->txBuf)) {
          lsr |= 0x20;  /* transmit holding register empty */

          if (C0C_TX_BUFFER_EMPTY(&pIoPortRead->txBuf))
            lsr |= 0x40;  /* transmit holding register empty and line is idle */
        }

        InsertLsrMst(pIoPortRead, FALSE,  lsr, pQueueToComplete);
      }

      if ((!(pIoPort->writeHolding & ~SERIAL_TX_WAITING_FOR_XON) && pIoPort->sendXonXoff) ||
          (!pIoPort->writeHolding && pIoPort->irpQueues[C0C_QUEUE_WRITE].pCurrent))
      {
        pIoPort->tryWrite = TRUE;
      }
    }
  }
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/delay.c

/*
 * $Id: delay.c,v 1.12 2010/08/04 10:38:55 vfrolov Exp $
 *
 * Copyright (c) 2005-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: delay.c,v $
 * Revision 1.12  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.11  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.10  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.9  2007/07/20 07:59:20  vfrolov
 * Fixed idleCount
 *
 * Revision 1.8  2007/06/09 08:49:47  vfrolov
 * Improved baudrate emulation
 *
 * Revision 1.7  2007/06/01 16:15:02  vfrolov
 * Fixed previous fix
 *
 * Revision 1.6  2007/06/01 08:36:26  vfrolov
 * Changed parameter type for SetWriteDelay()
 *
 * Revision 1.5  2007/01/11 14:50:29  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.4  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.3  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.2  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.1  2005/08/23 15:30:22  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "delay.h"
#include "noise.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 7

KDEFERRED_ROUTINE WriteDelayRoutine;
VOID WriteDelayRoutine(
    IN PKDPC pDpc,
    IN PVOID deferredContext,
    IN PVOID systemArgument1,
    IN PVOID systemArgument2)
{
  PC0C_IO_PORT pIoPort;
  PC0C_ADAPTIVE_DELAY pWriteDelay;

  UNREFERENCED_PARAMETER(pDpc);
  UNREFERENCED_PARAMETER(systemArgument1);
  UNREFERENCED_PARAMETER(systemArgument2);

  HALT_UNLESS(deferredContext != NULL);

  pIoPort = (PC0C_IO_PORT)deferredContext;
  pWriteDelay = pIoPort->pWriteDelay;

  if (pWriteDelay) {
    LIST_ENTRY queueToComplete;
    KIRQL oldIrql;

    InitializeListHead(&queueToComplete);

    KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

    if (pWriteDelay->started) {
      pWriteDelay->idleCount++;

      ReadWrite(
          pIoPort->pIoPortRemote, FALSE,
          pIoPort, FALSE,
          &queueToComplete);

      if (pWriteDelay->idleCount > 3) {
        if (pIoPort->brokeCharsProbability > 0 && pIoPort->pIoPortRemote->isOpen) {
          SIZE_T idleChars = GetWriteLimit(pWriteDelay);

          pWriteDelay->idleCount = 0;
          pIoPort->brokeIdleChars += GetBrokenChars(pIoPort->brokeCharsProbability, idleChars);
          pWriteDelay->sentFrames += idleChars;

          if (pIoPort->brokeIdleChars > 0) {
            ReadWrite(
                pIoPort->pIoPortRemote, FALSE,
                pIoPort, FALSE,
                &queueToComplete);
          }
        } else {
          StopWriteDelayTimer(pWriteDelay);
        }
      }
    }

    KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

    FdoPortCompleteQueue(&queueToComplete);
  }
}

SIZE_T GetWriteLimit(PC0C_ADAPTIVE_DELAY pWriteDelay)
{
  ULONGLONG curTime;
  ULONGLONG maxFrames;

  HALT_UNLESS(pWriteDelay);

  curTime = KeQueryInterruptTime();

  HALT_UNLESS(pWriteDelay->params.decibits_per_frame);

  maxFrames = ((curTime - pWriteDelay->startTime) * pWriteDelay->params.baudRate)/
          (pWriteDelay->params.decibits_per_frame * 1000000L);

  if (maxFrames < pWriteDelay->sentFrames)
    return 0;

  return (SIZE_T)(maxFrames - pWriteDelay->sentFrames);
}

NTSTATUS AllocWriteDelay(PC0C_IO_PORT pIoPort)
{
  PC0C_ADAPTIVE_DELAY pWriteDelay;

  pWriteDelay = (PC0C_ADAPTIVE_DELAY)C0C_ALLOCATE_POOL(NonPagedPool, sizeof(*pWriteDelay));

  if (!pWriteDelay)
    return STATUS_INSUFFICIENT_RESOURCES;

  RtlZeroMemory(pWriteDelay, sizeof(*pWriteDelay));

  KeInitializeTimer(&pWriteDelay->timer);
  KeInitializeDpc(&pWriteDelay->timerDpc, WriteDelayRoutine, pIoPort);

  pIoPort->pWriteDelay = pWriteDelay;

  return STATUS_SUCCESS;
}

VOID FreeWriteDelay(PC0C_IO_PORT pIoPort)
{
  PC0C_ADAPTIVE_DELAY pWriteDelay;

  pWriteDelay = pIoPort->pWriteDelay;

  if (pWriteDelay) {
    pIoPort->pWriteDelay = NULL;
    StopWriteDelayTimer(pWriteDelay);
    C0C_FREE_POOL(pWriteDelay);
  }
}

VOID SetWriteDelay(PC0C_IO_PORT pIoPort)
{
  PC0C_ADAPTIVE_DELAY pWriteDelay;
  C0C_DELAY_PARAMS params;

  pWriteDelay = pIoPort->pWriteDelay;

  if (!pWriteDelay)
    return;

  params.baudRate = pIoPort->baudRate.BaudRate;

  /* Startbit + WordLength */
  params.decibits_per_frame = (1 + pIoPort->lineControl.WordLength) * 10;

  switch (pIoPort->lineControl.Parity) {
  case NO_PARITY:
    break;
  default:
  case ODD_PARITY:
  case EVEN_PARITY:
  case MARK_PARITY:
  case SPACE_PARITY:
    params.decibits_per_frame += 10;
    break;
  }

  switch (pIoPort->lineControl.StopBits) {
  default:
  case STOP_BIT_1:
    params.decibits_per_frame += 10;
    break;
  case STOP_BITS_1_5:
    params.decibits_per_frame += 15;
    break;
  case STOP_BITS_2:
    params.decibits_per_frame += 30;
    break;
  }

  if (pWriteDelay->params.baudRate != params.baudRate ||
      pWriteDelay->params.decibits_per_frame != params.decibits_per_frame)
  {
    pWriteDelay->params = params;
    if (pWriteDelay->started) {
      StopWriteDelayTimer(pWriteDelay);
      StartWriteDelayTimer(pWriteDelay);
    }
  }
}

VOID StartWriteDelayTimer(PC0C_ADAPTIVE_DELAY pWriteDelay)
{
  LARGE_INTEGER dueTime;
  ULONG period;
  ULONG intervals_100ns;

  if (pWriteDelay->started)
    return;

  if (!pWriteDelay->params.baudRate)
    return;

  pWriteDelay->startTime = KeQueryInterruptTime();
  pWriteDelay->sentFrames = 0;
  pWriteDelay->idleCount = 0;

  /* 100-nanosecond intervals per frame */
  intervals_100ns = (pWriteDelay->params.decibits_per_frame * 1000000L)/pWriteDelay->params.baudRate;

  if (!intervals_100ns)
    intervals_100ns = 1;

  period = intervals_100ns/10000;  /* 1-millisecond intervals per frame */

  dueTime.QuadPart = -(LONGLONG)intervals_100ns;

  if (!period)
    period = 1;

  KeSetTimerEx(
      &pWriteDelay->timer,
      dueTime, period,
      &pWriteDelay->timerDpc);

  pWriteDelay->started = TRUE;
}

VOID StopWriteDelayTimer(PC0C_ADAPTIVE_DELAY pWriteDelay)
{
  pWriteDelay->started = FALSE;
  KeCancelTimer(&pWriteDelay->timer);
  KeRemoveQueueDpc(&pWriteDelay->timerDpc);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/showport.c

/*
 * $Id: showport.c,v 1.5 2010/08/04 10:38:56 vfrolov Exp $
 *
 * Copyright (c) 2007-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: showport.c,v $
 * Revision 1.5  2010/08/04 10:38:56  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.4  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.3  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.2  2008/05/04 09:51:45  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.1  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 */

#include "precomp.h"
#include "showport.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 0xD

BOOLEAN HidePortName(IN PC0C_FDOPORT_EXTENSION pDevExt)
{
  BOOLEAN res;
  HANDLE hKey;
  NTSTATUS status;

  if (pDevExt->pIoPortLocal->isComClass)
    return TRUE;

  res = TRUE;

  status = IoOpenDeviceRegistryKey(pDevExt->pIoPortLocal->pPhDevObj,
                                   PLUGPLAY_REGKEY_DEVICE,
                                   STANDARD_RIGHTS_WRITE,
                                   &hKey);

  if (NT_SUCCESS(status)) {
    UNICODE_STRING keyName;

    RtlInitUnicodeString(&keyName, L"PortName");

    status = ZwDeleteValueKey(hKey, &keyName);

    if (NT_SUCCESS(status)) {
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Hidden PORTNAME");
    }
    else
    if ((pDevExt->shown & C0C_SHOW_PORTNAME) != 0) {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"HidePortName ZwDeleteValueKey(PortName) FAIL");
    }

    ZwClose(hKey);
  }
  else
  if ((pDevExt->shown & C0C_SHOW_PORTNAME) != 0) {
    res = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"HidePortName IoOpenDeviceRegistryKey(PLUGPLAY_REGKEY_DEVICE) FAIL");
  }

  pDevExt->shown &= ~C0C_SHOW_PORTNAME;

  return res;
}

BOOLEAN HidePort(IN PC0C_FDOPORT_EXTENSION pDevExt)
{
  BOOLEAN res;
  NTSTATUS status;

  if (!pDevExt->shown)
    return TRUE;

  res = TRUE;

  if ((pDevExt->shown & C0C_SHOW_WMIREG) != 0) {
    status = IoWMIRegistrationControl(pDevExt->pDevObj, WMIREG_ACTION_DEREGISTER);
    pDevExt->shown &= ~C0C_SHOW_WMIREG;

    if (NT_SUCCESS(status)) {
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Hidden WMIREG");
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"HidePort IoWMIRegistrationControl FAIL");
    }
  }

  if (pDevExt->symbolicLinkName.Buffer && (pDevExt->shown & C0C_SHOW_INTERFACE) != 0) {
    status = IoSetDeviceInterfaceState(&pDevExt->symbolicLinkName, FALSE);
    pDevExt->shown &= ~C0C_SHOW_INTERFACE;

    if (NT_SUCCESS(status)) {
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Hidden INTERFACE");
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"HidePort IoSetDeviceInterfaceState FAIL");
    }
  }

  if (pDevExt->ntDeviceName.Buffer && (pDevExt->shown & C0C_SHOW_DEVICEMAP) != 0) {
    status = RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP, C0C_SERIAL_DEVICEMAP,
                                    pDevExt->ntDeviceName.Buffer);
    pDevExt->shown &= ~C0C_SHOW_DEVICEMAP;

    if (NT_SUCCESS(status)) {
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Hidden DEVICEMAP");
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"HidePort RtlDeleteRegistryValue " C0C_SERIAL_DEVICEMAP L" FAIL");
    }
  }

  if (pDevExt->win32DeviceName.Buffer && (pDevExt->shown & C0C_SHOW_SYMLINK) != 0) {
    status = IoDeleteSymbolicLink(&pDevExt->win32DeviceName);
    pDevExt->shown &= ~C0C_SHOW_SYMLINK;

    if (NT_SUCCESS(status)) {
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Hidden SYMLINK");
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"HidePort IoDeleteSymbolicLink FAIL");
    }
  }

  if ((pDevExt->shown & C0C_SHOW_PORTNAME) != 0)
    res = (HidePortName(pDevExt) && res);

  pDevExt->shown &= ~C0C_SHOW_SHOWN;

  Trace00((PC0C_COMMON_EXTENSION)pDevExt, L"HidePort - ", res ? L"OK" : L"FAIL");

  return res;
}

BOOLEAN ShowPort(IN PC0C_FDOPORT_EXTENSION pDevExt)
{
  BOOLEAN res;
  NTSTATUS status;

  if ((pDevExt->shown & C0C_SHOW_SHOWN) != 0)
    return TRUE;

  res = TRUE;

  if (!pDevExt->pIoPortLocal->isComClass &&
      (pDevExt->shown & C0C_SHOW_PORTNAME) == 0 &&
      (pDevExt->hide & C0C_SHOW_PORTNAME) == 0)
  {
    HANDLE hKey;

    status = IoOpenDeviceRegistryKey(pDevExt->pIoPortLocal->pPhDevObj,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_WRITE,
                                     &hKey);

    if (NT_SUCCESS(status)) {
      UNICODE_STRING keyName;

      RtlInitUnicodeString(&keyName, L"PortName");

      status = ZwSetValueKey(hKey,
                             &keyName,
                             0,
                             REG_SZ,
                             pDevExt->portName,
                             (ULONG)((wcslen(pDevExt->portName) + 1) * sizeof(WCHAR)));

      if (NT_SUCCESS(status)) {
        pDevExt->shown |= C0C_SHOW_PORTNAME;
        Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Shown PORTNAME");
      } else {
        res = FALSE;
        Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort ZwSetValueKey(PortName) FAIL");
      }

      ZwClose(hKey);
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort IoOpenDeviceRegistryKey(PLUGPLAY_REGKEY_DEVICE) FAIL");
    }
  }

  if (pDevExt->ntDeviceName.Buffer) {
    if (pDevExt->win32DeviceName.Buffer &&
        (pDevExt->shown & C0C_SHOW_SYMLINK) == 0 &&
        (pDevExt->hide & C0C_SHOW_SYMLINK) == 0)
    {
      status = IoCreateSymbolicLink(&pDevExt->win32DeviceName, &pDevExt->ntDeviceName);

      if (NT_SUCCESS(status)) {
        pDevExt->shown |= C0C_SHOW_SYMLINK;
        Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Shown SYMLINK");
      } else {
        res = FALSE;
        Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort IoCreateSymbolicLink FAIL");
      }
    }

    if ((pDevExt->shown & C0C_SHOW_SYMLINK) != 0 &&
        (pDevExt->shown & C0C_SHOW_DEVICEMAP) == 0 &&
        (pDevExt->hide & C0C_SHOW_DEVICEMAP) == 0)
    {
      status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, C0C_SERIAL_DEVICEMAP,
                                     pDevExt->ntDeviceName.Buffer, REG_SZ,
                                     pDevExt->portName,
                                     (ULONG)((wcslen(pDevExt->portName) + 1) * sizeof(WCHAR)));

      if (NT_SUCCESS(status)) {
        pDevExt->shown |= C0C_SHOW_DEVICEMAP;
        Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Shown DEVICEMAP");
      } else {
        res = FALSE;
        Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort RtlWriteRegistryValue " C0C_SERIAL_DEVICEMAP L" FAIL");
      }
    }
  }

  if (pDevExt->symbolicLinkName.Buffer &&
      (pDevExt->shown & C0C_SHOW_INTERFACE) == 0 &&
      (pDevExt->hide & C0C_SHOW_INTERFACE) == 0)
  {
    status = IoSetDeviceInterfaceState(&pDevExt->symbolicLinkName, TRUE);

    if (NT_SUCCESS(status)) {
      pDevExt->shown |= C0C_SHOW_INTERFACE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Shown INTERFACE");
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort IoSetDeviceInterfaceState FAIL");
    }
  }

  if ((pDevExt->shown & C0C_SHOW_WMIREG) == 0 && (pDevExt->hide & C0C_SHOW_WMIREG) == 0) {
    status = IoWMIRegistrationControl(pDevExt->pDevObj, WMIREG_ACTION_REGISTER);

    if (NT_SUCCESS(status)) {
      pDevExt->shown |= C0C_SHOW_WMIREG;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Shown WMIREG");
    } else {
      res = FALSE;
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort IoWMIRegistrationControl FAIL");
    }
  }

  pDevExt->shown |= C0C_SHOW_SHOWN;

  Trace00((PC0C_COMMON_EXTENSION)pDevExt, L"ShowPort - ", res ? L"OK" : L"FAIL");

  return res;
}

VOID SetHiddenMode(IN PC0C_FDOPORT_EXTENSION pDevExt, ULONG hiddenMode)
{
  if (hiddenMode == 0xFFFFFFFF)
    pDevExt->hide = (C0C_SHOW_PORTNAME|C0C_SHOW_DEVICEMAP|C0C_SHOW_WMIREG);
  else
    pDevExt->hide = (UCHAR)hiddenMode;

#if ENABLE_TRACING
  if (pDevExt->hide)
    TraceMask((PC0C_COMMON_EXTENSION)pDevExt, "Enabled hidden mode ", codeNameTableShowPort, pDevExt->hide);
  else
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled hidden mode");
#endif /* ENABLE_TRACING */
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/syslog.h

/*
 * $Id: syslog.h,v 1.2 2011/12/15 06:17:12 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: syslog.h,v $
 * Revision 1.2  2011/12/15 06:17:12  vfrolov
 * Removed usage undocumented PDRIVER_OBJECT->Type
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 *
 */

#ifndef _C0C_SYSLOG_H_
#define _C0C_SYSLOG_H_

VOID SysLogDrv(
    IN PDRIVER_OBJECT pDrvObj,
    IN NTSTATUS status,
    IN PWCHAR pStr);

VOID SysLogDev(
    IN PDEVICE_OBJECT pDevObj,
    IN NTSTATUS status,
    IN PWCHAR pStr);

#endif /* _C0C_SYSLOG_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/bufutils.c

/*
 * $Id: bufutils.c,v 1.19 2011/12/06 16:03:22 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: bufutils.c,v $
 * Revision 1.19  2011/12/06 16:03:22  vfrolov
 * Added cleaning high data bits for less then 8 bit data
 * Added AllDataBits option to force 8 bit data
 *
 * Revision 1.18  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.17  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.16  2008/10/27 15:13:58  vfrolov
 * Fixed buffer overrun bug
 *
 * Revision 1.15  2008/09/12 10:07:50  vfrolov
 * Fixed LSR insertion
 *
 * Revision 1.14  2008/09/02 07:36:22  vfrolov
 * Added missing SERIAL_EV_BREAK
 *
 * Revision 1.13  2008/09/01 16:54:28  vfrolov
 * Replaced SERIAL_LSRMST_LSR_NODATA by SERIAL_LSRMST_LSR_DATA for BREAK
 *
 * Revision 1.12  2008/07/11 10:30:39  vfrolov
 * Added missing data available bit to LSR
 *
 * Revision 1.11  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.10  2007/10/05 07:34:21  vfrolov
 * Added missing *pOverrun initialization
 * Changed TX FIFO writing emulation to be interrupt driven
 *
 * Revision 1.9  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.8  2007/01/11 14:50:29  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.7  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.6  2006/05/17 15:28:03  vfrolov
 * Implemented SERIAL_DSR_SENSITIVITY
 *
 * Revision 1.5  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.4  2005/11/29 08:35:14  vfrolov
 * Implemented SERIAL_EV_RX80FULL
 *
 * Revision 1.3  2005/11/28 12:57:16  vfrolov
 * Moved some C0C_BUFFER code to bufutils.c
 *
 * Revision 1.2  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.1  2005/08/25 15:38:17  vfrolov
 * Some code moved from io.c to bufutils.c
 *
 */

#include "precomp.h"
#include "bufutils.h"
#include "noise.h"
#include "../include/cncext.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 8

/********************************************************************/
VOID CompactRawData(PC0C_RAW_DATA pRawData, SIZE_T writeDone)
{
  if (writeDone) {
    pRawData->size = (UCHAR)(pRawData->size - writeDone);

    if (pRawData->size) {
      HALT_UNLESS3((pRawData->size + writeDone) <= sizeof(pRawData->data),
          pRawData->size, writeDone, sizeof(pRawData->data));

      RtlMoveMemory(pRawData->data, pRawData->data + writeDone, pRawData->size);
    }
  }
}

SIZE_T AddRawData(PC0C_RAW_DATA pDstRawData, PUCHAR pSrc, SIZE_T length)
{
  SIZE_T len;

  if (!length)
    return 0;

  HALT_UNLESS2(pDstRawData->size <= sizeof(pDstRawData->data),
      pDstRawData->size, sizeof(pDstRawData->data));

  len = sizeof(pDstRawData->data) - pDstRawData->size;

  if (!len)
    return 0;

  if (len > length)
    len = length;

  HALT_UNLESS3((pDstRawData->size + len) <= sizeof(pDstRawData->data),
      pDstRawData->size, len, sizeof(pDstRawData->data));

  RtlCopyMemory(pDstRawData->data + pDstRawData->size, pSrc, len);
  pDstRawData->size = (UCHAR)(pDstRawData->size + len);

  return len;
}

NTSTATUS MoveRawData(PC0C_RAW_DATA pDstRawData, PC0C_RAW_DATA pSrcRawData)
{
  CompactRawData(pSrcRawData, AddRawData(pDstRawData, pSrcRawData->data, pSrcRawData->size));

  return pSrcRawData->size ? STATUS_PENDING : STATUS_SUCCESS;
}
/********************************************************************/
#define C0C_FLOW_FILTER_FL_AUTO_TRANSMIT   0x01
#define C0C_FLOW_FILTER_FL_NULL_STRIPPING  0x02
#define C0C_FLOW_FILTER_FL_IGNORE_RECEIVED 0x04

VOID FlowFilterInit(PC0C_IO_PORT pIoPort, PC0C_FLOW_FILTER pFlowFilter)
{
  PSERIAL_HANDFLOW pHandFlow;

  RtlZeroMemory(pFlowFilter, sizeof(*pFlowFilter));

  pFlowFilter->pIoPort = pIoPort;

  pHandFlow = &pIoPort->handFlow;

  if ((pHandFlow->ControlHandShake & SERIAL_DSR_SENSITIVITY) &&
      (pIoPort->modemStatus & C0C_MSB_DSR) == 0)
  {
    pFlowFilter->flags |= C0C_FLOW_FILTER_FL_IGNORE_RECEIVED;
  }

  if (pHandFlow->FlowReplace & SERIAL_AUTO_TRANSMIT)
    pFlowFilter->flags |= C0C_FLOW_FILTER_FL_AUTO_TRANSMIT;

  if (pHandFlow->FlowReplace & SERIAL_NULL_STRIPPING)
    pFlowFilter->flags |= C0C_FLOW_FILTER_FL_NULL_STRIPPING;
}

VOID CopyCharsWithEscape(
    PC0C_BUFFER pBuf,
    PC0C_FLOW_FILTER pFlowFilter,
    PUCHAR pReadBuf, SIZE_T readLength,
    PUCHAR pWriteBuf, SIZE_T writeLength,
    PSIZE_T pReadDone,
    PSIZE_T pWriteDone)
{
  SIZE_T readDone;
  SIZE_T writeDone;

/********************************************************************
 * Special cases if pFlowFilter != NULL:
 *
 *   pReadBuf == NULL && readLength == 0
 *                               - skip writing to pReadBuf
 *
 *   pWriteBuf == NULL           - emulate writeLength noise impulses
 *
 ********************************************************************/

  HALT_UNLESS3(pReadBuf || (pFlowFilter && !readLength), pReadBuf != NULL, pFlowFilter != NULL, readLength);
  HALT_UNLESS2(pWriteBuf || pFlowFilter, pReadBuf != NULL, pFlowFilter != NULL);

  readDone = 0;

  if (pBuf->insertData.size && (readLength || pReadBuf == NULL)) {
    SIZE_T length = pBuf->insertData.size;

    HALT_UNLESS2(length <= sizeof(pBuf->insertData.data),
        length, sizeof(pBuf->insertData.data));

    if (pReadBuf) {
      if (length > readLength)
        length = readLength;

      RtlCopyMemory(pReadBuf, pBuf->insertData.data, length);
      pReadBuf += length;
      readLength -= length;
    }

    readDone += length;
    CompactRawData(&pBuf->insertData, length);
  }

  if (!pFlowFilter) {
    writeDone = writeLength < readLength ? writeLength : readLength;

    if (writeDone) {
      RtlCopyMemory(pReadBuf, pWriteBuf, writeDone);
      readDone += writeDone;
    }
  }
  else {
    PC0C_IO_PORT pIoPort = pFlowFilter->pIoPort;
    PC0C_IO_PORT pIoPortRemote = pIoPort->pIoPortRemote;
    UCHAR dataMask;

    {
      static const UCHAR masks[] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF};
      UCHAR wordLength = 8;

      if (!pIoPort->allDataBits && wordLength > pIoPort->lineControl.WordLength)
        wordLength = pIoPort->lineControl.WordLength;

      if (!pIoPortRemote->allDataBits && wordLength > pIoPortRemote->lineControl.WordLength)
        wordLength = pIoPortRemote->lineControl.WordLength;

      dataMask = masks[wordLength];
    }

    for (writeDone = 0 ; writeDone < writeLength && (readLength || pReadBuf == NULL) ; writeDone++) {
      UCHAR curChar;
      UCHAR lsr = 0;

      if (pWriteBuf) {
        if (pIoPortRemote->sendBreak) {
          pIoPortRemote->sendBreak = FALSE;
          pIoPort->rcvdBreak = TRUE;
          BreakError(pIoPort, &lsr);
          pFlowFilter->events |= SERIAL_EV_BREAK;

          curChar = 0x00;  /* -----------____________ */
                           /* iiiiiiiiiiis00000000bbb */
                           /* dddddddddddt\______/rrr */
                           /* llllllllllla  0x00  eee */
                           /* eeeeeeeeeeer        aaa */
                           /*            t        kkk */
        } else {
          if ((pIoPortRemote->writeHolding & SERIAL_TX_WAITING_ON_BREAK) == 0) {
            if (pIoPortRemote->brokeChars) {
              pIoPortRemote->brokeChars--;
              curChar = GarbageChar(pIoPortRemote, pIoPort, &lsr);
            } else {
              curChar = *pWriteBuf++;

              if (pIoPortRemote->brokeCharsProbability > 0)
                BrokeChar(pIoPortRemote, pIoPort, &curChar, &lsr);
            }
          } else {
            if (pIoPortRemote->brokeCharsProbability <= 0 ||
                GetBrokenChars(pIoPortRemote->brokeCharsProbability, 1) == 0)
            {
              continue;
            }

            BreakError(pIoPort, &lsr);
            pFlowFilter->events |= SERIAL_EV_BREAK;

            curChar = 0x00;  /* __________-____________ */
                             /* bbbbbbbbbbss00000000bbb */
                             /* rrrrrrrrrrtt\______/rrr */
                             /* eeeeeeeeeeoa  0x00  eee */
                             /* aaaaaaaaaapr        aaa */
                             /* kkkkkkkkkk t        kkk */
          }
        }
      } else {
        if (pIoPort->rcvdBreak) {
          /* emulate one noise impulse for BREAK state */

          BreakError(pIoPort, &lsr);
          pFlowFilter->events |= SERIAL_EV_BREAK;

          curChar = 0x00;  /* __________-____________ */
                           /* bbbbbbbbbbss00000000bbb */
                           /* rrrrrrrrrrtt\______/rrr */
                           /* eeeeeeeeeeoa  0x00  eee */
                           /* aaaaaaaaaapr        aaa */
                           /* kkkkkkkkkk t        kkk */
        } else {
          /* emulate one noise impulse for IDLE state */

          curChar = 0xFF;  /* ----------_------------ */
                           /* iiiiiiiiiis11111111siii */
                           /* ddddddddddt\______/tddd */
                           /* lllllllllla  0xFF  olll */
                           /* eeeeeeeeeer        peee */
                           /*           t             */
        }
      }

      curChar &= dataMask;
      pFlowFilter->rxCount++;

      if (lsr) {
        BOOLEAN noCurChar = FALSE;
        BOOLEAN isBreak = ((lsr & 0x10) != 0);
        pFlowFilter->events |= SERIAL_EV_ERR;

        if (pIoPort->escapeChar &&
            ((pIoPort->insertMask & C0CE_INSERT_ENABLE_LSR) != 0 ||
             (isBreak && (pIoPort->insertMask & C0CE_INSERT_ENABLE_LSR_BI) != 0)))
        {
          UCHAR buf[4];
          SIZE_T length = sizeof(buf);
          SIZE_T len;

          lsr |= 0x81;    /* errornous data in FIFO and data available */

          if (C0C_TX_BUFFER_THR_EMPTY(&pIoPort->txBuf)) {
            lsr |= 0x20;  /* transmit holding register empty */

            if (C0C_TX_BUFFER_EMPTY(&pIoPort->txBuf))
              lsr |= 0x40;  /* transmit holding register empty and line is idle */
          }

          if ((pIoPort->insertMask & C0CE_INSERT_ENABLE_LSR_BI) != 0 && pIoPort->rcvdBreak)
            lsr |= 0x10;  /* break interrupt indicator */

          buf[0] = pIoPort->escapeChar;
          buf[1] = SERIAL_LSRMST_LSR_DATA;
          buf[2] = lsr;
          buf[3] = curChar;

          noCurChar = TRUE;

          if (length > readLength)
            len = readLength;
          else
            len = length;

          if (len) {
            RtlCopyMemory(pReadBuf, buf, len);
            pReadBuf += len;
            readDone += len;
            readLength -= len;
            length -= len;
          }

          if (length) {
            if (pReadBuf == NULL) {
              readDone += length;
            } else {
#if DBG
              SIZE_T done =
#endif /* DBG */
              AddRawData(&pBuf->insertData, buf + len, length);
#if DBG
              HALT_UNLESS2(done == length, done, length);
#endif /* DBG */
            }
          }
        }

        if (isBreak) {
          if (pIoPort->handFlow.FlowReplace & SERIAL_BREAK_CHAR) {
            UCHAR errorChar = pIoPort->specialChars.BreakChar;

            if (!readLength) {
              if (pReadBuf == NULL) {
                readDone++;
              } else {
#if DBG
                SIZE_T done =
#endif /* DBG */
                AddRawData(&pBuf->insertData, &errorChar, sizeof(errorChar));
#if DBG
                HALT_UNLESS1(done == sizeof(errorChar), done);
#endif /* DBG */
              }
            } else {
              *pReadBuf++ = errorChar;
              readLength--;
              readDone++;
            }
          }
        }
        else
        if (pIoPort->handFlow.FlowReplace & SERIAL_ERROR_CHAR) {
          UCHAR errorChar = pIoPort->specialChars.ErrorChar;

          if (!readLength) {
            if (pReadBuf == NULL) {
              readDone++;
            } else {
#if DBG
              SIZE_T done =
#endif /* DBG */
              AddRawData(&pBuf->insertData, &errorChar, sizeof(errorChar));
#if DBG
              HALT_UNLESS1(done == sizeof(errorChar), done);
#endif /* DBG */
            }
          } else {
            *pReadBuf++ = errorChar;
            readLength--;
            readDone++;
          }
        }

        if (noCurChar)
          continue;
      }

      if (pFlowFilter->flags & C0C_FLOW_FILTER_FL_IGNORE_RECEIVED) {
      }
      else
      if (!curChar && (pFlowFilter->flags & C0C_FLOW_FILTER_FL_NULL_STRIPPING)) {
      }
      else
      if ((pFlowFilter->flags & C0C_FLOW_FILTER_FL_AUTO_TRANSMIT) &&
          (curChar == pIoPort->specialChars.XoffChar || curChar == pIoPort->specialChars.XonChar))
      {
        if (curChar == pIoPort->specialChars.XoffChar)
          pFlowFilter->lastXonXoff = C0C_XCHAR_OFF;
        else
          pFlowFilter->lastXonXoff = C0C_XCHAR_ON;
      }
      else {
          if (!readLength) {
            if (pReadBuf == NULL) {
              readDone++;
            } else {
#if DBG
              SIZE_T done =
#endif /* DBG */
              AddRawData(&pBuf->insertData, &curChar, sizeof(curChar));
#if DBG
              HALT_UNLESS1(done == sizeof(curChar), done);
#endif /* DBG */
            }
          } else {
            *pReadBuf++ = curChar;
            readLength--;
            readDone++;
          }

          pFlowFilter->events |= SERIAL_EV_RXCHAR;

          if ((pIoPort->waitMask & SERIAL_EV_RXFLAG) &&
              curChar == pIoPort->specialChars.EventChar)
          {
            pFlowFilter->events |= SERIAL_EV_RXFLAG;
          }

          if (pIoPort->escapeChar && curChar == pIoPort->escapeChar) {
            curChar = SERIAL_LSRMST_ESCAPE;

            if (!readLength) {
              if (pReadBuf == NULL) {
                readDone++;
              } else {
#if DBG
                SIZE_T done =
#endif /* DBG */
                AddRawData(&pBuf->insertData, &curChar, sizeof(curChar));
#if DBG
                HALT_UNLESS1(done == sizeof(curChar), done);
#endif /* DBG */
              }
            } else {
              *pReadBuf++ = curChar;
              readLength--;
              readDone++;
            }
          }
      }
    }
  }

  *pReadDone = readDone;
  *pWriteDone = writeDone;
}

SIZE_T ReadFromBuffer(PC0C_BUFFER pBuf, PVOID pRead, SIZE_T readLength)
{
  PUCHAR pReadBuf = (PUCHAR)pRead;

  while (readLength) {
    SIZE_T length, writeLength;
    PUCHAR pWriteBuf;

    if (!pBuf->busy) {
      if (pBuf->insertData.size) {
        length = pBuf->insertData.size;

        HALT_UNLESS2(length <= sizeof(pBuf->insertData.data),
            length, sizeof(pBuf->insertData.data));

        if (length > readLength)
          length = readLength;

        RtlCopyMemory(pReadBuf, pBuf->insertData.data, length);
        pReadBuf += length;
        readLength -= length;
        CompactRawData(&pBuf->insertData, length);
        if (!readLength)
          break;
      }
      break;
    }

    HALT_UNLESS(pBuf->pBase);

    pWriteBuf = pBuf->pBusy;

    writeLength = pBuf->pFree <= pWriteBuf ?
        pBuf->pEnd - pWriteBuf : pBuf->busy;

    length = writeLength < readLength ? writeLength : readLength;

    RtlCopyMemory(pReadBuf, pWriteBuf, length);

    pBuf->busy -= length;
    pBuf->pBusy += length;
    if (pBuf->pBusy == pBuf->pEnd)
      pBuf->pBusy = pBuf->pBase;

    pReadBuf += length;
    readLength -= length;
  }

  return pReadBuf - (PUCHAR)pRead;
}

SIZE_T WriteToBuffer(
    PC0C_BUFFER pBuf,
    PVOID pWrite,
    SIZE_T writeLength,
    PC0C_FLOW_FILTER pFlowFilter,
    PSIZE_T pOverrun)
{
  SIZE_T writeDoneTotal = 0;
  PUCHAR pWriteBuf = (PUCHAR)pWrite;

  if (pOverrun)
    *pOverrun = 0;

  while (writeLength) {
    SIZE_T readDone, writeDone;
    SIZE_T readLength;
    PUCHAR pReadBuf;

    if (pBuf->limit <= pBuf->busy) {
      if (pOverrun) {
        if (pBuf->busy >= C0C_BUFFER_SIZE(pBuf)) {
          CopyCharsWithEscape(
              pBuf, pFlowFilter,
              NULL, 0,
              pWriteBuf, writeLength,
              pOverrun, &writeDone);

          writeDoneTotal += writeDone;
        }
      }
      break;
    }

    pReadBuf = pBuf->pFree;

    readLength = pBuf->pBusy <= pReadBuf ?
        pBuf->pEnd - pReadBuf : pBuf->pBusy - pReadBuf;

    if (readLength > (pBuf->limit - pBuf->busy))
      readLength = pBuf->limit - pBuf->busy;

    CopyCharsWithEscape(
        pBuf, pFlowFilter,
        pReadBuf, readLength,
        pWriteBuf, writeLength,
        &readDone, &writeDone);

    pBuf->busy += readDone;
    pBuf->pFree += readDone;
    if (pBuf->pFree == pBuf->pEnd)
      pBuf->pFree = pBuf->pBase;

    writeDoneTotal += writeDone;
    writeLength -= writeDone;

    if (pWriteBuf)
      pWriteBuf += writeDone;
  }

  return writeDoneTotal;
}

VOID WriteMandatoryToBuffer(PC0C_BUFFER pBuf, UCHAR mandatoryChar)
{
  if (C0C_BUFFER_SIZE(pBuf) <= pBuf->busy) {
    if (pBuf->pBase) {
      if (pBuf->pFree == pBuf->pBase)
        *(pBuf->pEnd - 1) = mandatoryChar;
      else
        *(pBuf->pFree - 1) = mandatoryChar;
    }
  } else {
    pBuf->busy++;
    *pBuf->pFree = mandatoryChar;
    if (++pBuf->pFree == pBuf->pEnd)
      pBuf->pFree = pBuf->pBase;
  }
}

NTSTATUS WriteRawDataToBuffer(PC0C_RAW_DATA pRawData, PC0C_BUFFER pBuf)
{
  NTSTATUS status;

  if (!pBuf->pBase)
    return STATUS_PENDING;

  status = STATUS_PENDING;

  for (;;) {
    SIZE_T readDone, writeDone;
    SIZE_T writeLength, readLength;
    PVOID pWriteBuf, pReadBuf;

    writeLength = pRawData->size;

    if (!writeLength) {
      status = STATUS_SUCCESS;
      break;
    }

    HALT_UNLESS2(writeLength <= sizeof(pRawData->data),
        writeLength, sizeof(pRawData->data));

    pWriteBuf = pRawData->data;

    if (C0C_BUFFER_SIZE(pBuf) <= pBuf->busy)
      break;

    readLength = pBuf->pBusy <= pBuf->pFree  ?
        pBuf->pEnd - pBuf->pFree : pBuf->pBusy - pBuf->pFree;

    pReadBuf = pBuf->pFree;

    CopyCharsWithEscape(
        pBuf, NULL,
        pReadBuf, readLength,
        pWriteBuf, writeLength,
        &readDone, &writeDone);

    pBuf->busy += readDone;
    pBuf->pFree += readDone;
    if (pBuf->pFree == pBuf->pEnd)
      pBuf->pFree = pBuf->pBase;

    CompactRawData(pRawData, writeDone);
  }

  return status;
}

SIZE_T WriteRawData(PC0C_RAW_DATA pRawData, PNTSTATUS pStatus, PVOID pReadBuf, SIZE_T readLength)
{
  SIZE_T length, writeLength;
  PVOID pWriteBuf;

  pWriteBuf = pRawData->data;
  writeLength = pRawData->size;

  HALT_UNLESS2(writeLength <= sizeof(pRawData->data),
      writeLength, sizeof(pRawData->data));

  length = writeLength < readLength ? writeLength : readLength;

  RtlCopyMemory(pReadBuf, pWriteBuf, length);

  CompactRawData(pRawData, length);

  if (!pRawData->size)
    *pStatus = STATUS_SUCCESS;

  return length;
}

VOID InitBufferBase(PC0C_BUFFER pBuf, __drv_aliasesMem PUCHAR pBase, SIZE_T size)
{
  pBuf->pBase = pBase;
  pBuf->pEnd = pBuf->pBase + size;
  pBuf->limit = size;
  pBuf->size80 = (size*4 + 4)/5;
}

BOOLEAN SetNewBufferBase(PC0C_BUFFER pBuf, PUCHAR pBase, SIZE_T size)
{
  C0C_BUFFER newBuf;

  if (size <= C0C_BUFFER_SIZE(pBuf)) {
    C0C_FREE_POOL(pBase);
    return FALSE;
  }

  InitBufferBase(&newBuf, pBase, size);

  newBuf.pFree = newBuf.pBusy = newBuf.pBase;
  newBuf.busy = 0;

  if (pBuf->pBase) {
    while (pBuf->busy) {
      SIZE_T length;

      length = pBuf->pFree <= pBuf->pBusy ?
          pBuf->pEnd - pBuf->pBusy : pBuf->busy;

      RtlCopyMemory(newBuf.pFree, pBuf->pBusy, length);

      pBuf->busy -= length;
      pBuf->pBusy += length;
      if (pBuf->pBusy == pBuf->pEnd)
        pBuf->pBusy = pBuf->pBase;

      newBuf.busy += length;
      newBuf.pFree += length;
    }

    C0C_FREE_POOL(pBuf->pBase);
  }

  newBuf.insertData = pBuf->insertData;

  *pBuf = newBuf;

  return TRUE;
}

VOID PurgeBuffer(PC0C_BUFFER pBuf)
{
  pBuf->pFree = pBuf->pBusy = pBuf->pBase;
  pBuf->busy = 0;
  pBuf->insertData.size = 0;
}

VOID InitBuffer(PC0C_BUFFER pBuf, __drv_aliasesMem PUCHAR pBase, SIZE_T size)
{
  RtlZeroMemory(pBuf, sizeof(*pBuf));
  InitBufferBase(pBuf, pBase, size);
  PurgeBuffer(pBuf);
}

VOID FreeBuffer(PC0C_BUFFER pBuf)
{
  if (pBuf->pBase)
    C0C_FREE_POOL(pBuf->pBase);

  RtlZeroMemory(pBuf, sizeof(*pBuf));
}

VOID SetBufferLimit(PC0C_BUFFER pBuf, SIZE_T limit)
{
  if (limit > C0C_BUFFER_SIZE(pBuf))
    limit = C0C_BUFFER_SIZE(pBuf);

  pBuf->limit = limit;
}
/********************************************************************/
SIZE_T ReadFromTxBuffer(
    PC0C_BUFFER pBuf,
    PC0C_FLOW_FILTER pFlowFilter,
    PVOID pRead, SIZE_T readLength,
    PC0C_TX_BUFFER pTxBuf, SIZE_T txLimit,
    PSIZE_T pWriteDone)
{
  PUCHAR pReadBuf = (PUCHAR)pRead;

  *pWriteDone = 0;

  while (readLength) {
    SIZE_T writeLength;
    SIZE_T readDone, writeDone;
    PUCHAR pWriteBuf;

    pWriteBuf = pTxBuf->pBusy;

    if (pTxBuf->busy) {
      writeLength = pTxBuf->pFree <= pWriteBuf ?
          pTxBuf->pEnd - pWriteBuf : pTxBuf->busy;

      if (writeLength > txLimit)
        writeLength = txLimit;
    } else {
      writeLength = 0;
    }

    CopyCharsWithEscape(pBuf, pFlowFilter,
                       pReadBuf, readLength,
                       pWriteBuf, writeLength,
                       &readDone, &writeDone);

    pTxBuf->busy -= writeDone;
    pTxBuf->pBusy += writeDone;
    if (pTxBuf->pBusy == pTxBuf->pEnd)
      pTxBuf->pBusy = pTxBuf->pBase;

    *pWriteDone += writeDone;

    if (readDone == 0)
      break;

    pReadBuf += readDone;
    readLength -= readDone;
    txLimit -= writeDone;
  }

  return pReadBuf - (PUCHAR)pRead;
}

SIZE_T WriteToTxBuffer(
    PC0C_TX_BUFFER pTxBuf,
    PVOID pWrite,
    SIZE_T writeLength)
{
  PUCHAR pWriteBuf;
  SIZE_T sizeTxBuf;

  /* Writing to TX FIFO is interrupt driven so we can write only if it's empty */

  if (!C0C_TX_BUFFER_THR_EMPTY(pTxBuf))
    return 0;

  sizeTxBuf = C0C_TX_BUFFER_SIZE(pTxBuf);

  /* Write not more then TxFIFO registry value */

  if (writeLength > sizeTxBuf - 1)
    writeLength = sizeTxBuf - 1;

  pWriteBuf = (PUCHAR)pWrite;

  while (writeLength && pTxBuf->busy < sizeTxBuf) {
    SIZE_T readLength;
    PUCHAR pReadBuf;

    pReadBuf = pTxBuf->pFree;

    readLength = pTxBuf->pBusy <= pReadBuf ?
        pTxBuf->pEnd - pReadBuf : pTxBuf->pBusy - pReadBuf;

    if (readLength > writeLength)
      readLength = writeLength;

    RtlCopyMemory(pReadBuf, pWriteBuf, readLength);

    pTxBuf->busy += readLength;
    pTxBuf->pFree += readLength;
    if (pTxBuf->pFree == pTxBuf->pEnd)
      pTxBuf->pFree = pTxBuf->pBase;

    pWriteBuf += readLength;
    writeLength -= readLength;
  }

  return pWriteBuf - (PUCHAR)pWrite;
}

SIZE_T MoveFromTxBuffer(
    PC0C_BUFFER pBuf,
    PC0C_TX_BUFFER pTxBuf,
    SIZE_T txLimit,
    PC0C_FLOW_FILTER pFlowFilter,
    PSIZE_T pOverrun)
{
  SIZE_T done = 0;

  if (pOverrun)
    *pOverrun = 0;

  while (pTxBuf->busy) {
    SIZE_T writeLength;
    SIZE_T writeDone;
    PUCHAR pWriteBuf;

    pWriteBuf = pTxBuf->pBusy;

    writeLength = pTxBuf->pFree <= pWriteBuf ?
        pTxBuf->pEnd - pWriteBuf : pTxBuf->busy;

    if (writeLength > txLimit)
      writeLength = txLimit;

    if (writeLength == 0)
      break;

    if (pOverrun) {
      SIZE_T overrun;

      writeDone = WriteToBuffer(pBuf, pWriteBuf, writeLength, pFlowFilter, &overrun);

      *pOverrun += overrun;
    } else {
      writeDone = WriteToBuffer(pBuf, pWriteBuf, writeLength, pFlowFilter, NULL);
    }

    if (writeDone == 0)
      break;

    pTxBuf->busy -= writeDone;
    pTxBuf->pBusy += writeDone;
    if (pTxBuf->pBusy == pTxBuf->pEnd)
      pTxBuf->pBusy = pTxBuf->pBase;

    done += writeDone;
    txLimit -= writeDone;
  }

  return done;
}

VOID SetTxBuffer(PC0C_TX_BUFFER pTxBuf, SIZE_T size, BOOLEAN cleanFifo)
{
  PUCHAR pBase;

  UNREFERENCED_PARAMETER(cleanFifo);

  size = sizeof(pTxBuf->leastBuf) - 1;

  size += 1;  /* add shift register */
  pBase = pTxBuf->leastBuf;

  pTxBuf->pFree = pTxBuf->pBusy = pTxBuf->pBase = pBase;
  pTxBuf->pEnd = pTxBuf->pBase + size;
  pTxBuf->busy = 0;
}

VOID FreeTxBuffer(PC0C_TX_BUFFER pTxBuf)
{
  if (pTxBuf->pBase && pTxBuf->pBase != pTxBuf->leastBuf)
    C0C_FREE_POOL(pTxBuf->pBase);

  RtlZeroMemory(pTxBuf, sizeof(*pTxBuf));
}
/********************************************************************/


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/tracetbl.c

/*
 * $Id: tracetbl.c,v 1.19 2011/07/12 18:16:46 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: tracetbl.c,v $
 * Revision 1.19  2011/07/12 18:16:46  vfrolov
 * Discarded WDM garbage
 *
 * Revision 1.18  2010/08/10 16:45:58  vfrolov
 * Added STATUS_WAIT_1..3
 *
 * Revision 1.17  2010/08/09 16:08:37  vfrolov
 * Added STATUS_NOT_IMPLEMENTED
 *
 * Revision 1.16  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.15  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.14  2008/05/04 09:51:45  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.13  2007/09/17 14:31:06  vfrolov
 * Implemented pseudo pin OPEN
 *
 * Revision 1.12  2007/02/21 16:52:34  vfrolov
 * Added tracing of IRP_MJ_POWER with more details
 *
 * Revision 1.11  2007/02/20 11:57:59  vfrolov
 * Added STATUS_SERIAL_COUNTER_TIMEOUT and STATUS_SERIAL_MORE_WRITES
 *
 * Revision 1.10  2006/09/27 07:24:51  vfrolov
 * Added IRP_MN_REGINFO_EX
 *
 * Revision 1.9  2006/08/23 12:56:20  vfrolov
 * Added codeNameTableWmi
 *
 * Revision 1.8  2006/06/23 07:38:39  vfrolov
 * Added STATUS_DEVICE_BUSY
 *
 * Revision 1.7  2006/05/19 15:02:03  vfrolov
 * Implemented IOCTL_SERIAL_GET_MODEM_CONTROL
 *
 * Revision 1.6  2006/01/10 09:32:20  vfrolov
 * Added codeNameTableHoldReasons[]
 *
 * Revision 1.5  2005/12/06 13:01:54  vfrolov
 * Implemented IOCTL_SERIAL_GET_DTRRTS
 *
 * Revision 1.4  2005/09/28 10:06:42  vfrolov
 * Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION
 *
 * Revision 1.3  2005/09/06 06:49:38  vfrolov
 * Added codeNameTableErrors[]
 *
 * Revision 1.2  2005/08/25 07:48:39  vfrolov
 * Changed type of code names from wchar to char
 * Fixed HandFlow tracing
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"

#if ENABLE_TRACING

#define TOCODE2NAME1(s) { (ULONG)s, #s }
#define TOCODE2NAME(p, s) { (ULONG)p##s, #s }

#define TOFIELD2NAME2(p, s) { (ULONG)p##s, (ULONG)p##s, #s }
#define TOFIELD2NAME(p, s, m) { (ULONG)p##s, (ULONG)m, #s }

CODE2NAME codeNameTableWaitMask[] = {
  TOCODE2NAME(SERIAL_EV_, RXCHAR),
  TOCODE2NAME(SERIAL_EV_, RXFLAG),
  TOCODE2NAME(SERIAL_EV_, TXEMPTY),
  TOCODE2NAME(SERIAL_EV_, CTS),
  TOCODE2NAME(SERIAL_EV_, DSR),
  TOCODE2NAME(SERIAL_EV_, RLSD),
  TOCODE2NAME(SERIAL_EV_, BREAK),
  TOCODE2NAME(SERIAL_EV_, ERR),
  TOCODE2NAME(SERIAL_EV_, RING),
  TOCODE2NAME(SERIAL_EV_, PERR),
  TOCODE2NAME(SERIAL_EV_, RX80FULL),
  TOCODE2NAME(SERIAL_EV_, EVENT1),
  TOCODE2NAME(SERIAL_EV_, EVENT2),
  {0, NULL}
};

CODE2NAME codeNameTablePurgeMask[] = {
  TOCODE2NAME(SERIAL_PURGE_, TXABORT),
  TOCODE2NAME(SERIAL_PURGE_, RXABORT),
  TOCODE2NAME(SERIAL_PURGE_, TXCLEAR),
  TOCODE2NAME(SERIAL_PURGE_, RXCLEAR),
  {0, NULL}
};

CODE2NAME codeNameTableIoctl[] = {
  TOCODE2NAME(IOCTL_SERIAL_, SET_BAUD_RATE),
  TOCODE2NAME(IOCTL_SERIAL_, SET_QUEUE_SIZE),
  TOCODE2NAME(IOCTL_SERIAL_, SET_LINE_CONTROL),
  TOCODE2NAME(IOCTL_SERIAL_, SET_BREAK_ON),
  TOCODE2NAME(IOCTL_SERIAL_, SET_BREAK_OFF),
  TOCODE2NAME(IOCTL_SERIAL_, IMMEDIATE_CHAR),
  TOCODE2NAME(IOCTL_SERIAL_, SET_TIMEOUTS),
  TOCODE2NAME(IOCTL_SERIAL_, GET_TIMEOUTS),
  TOCODE2NAME(IOCTL_SERIAL_, SET_DTR),
  TOCODE2NAME(IOCTL_SERIAL_, CLR_DTR),
  TOCODE2NAME(IOCTL_SERIAL_, RESET_DEVICE),
  TOCODE2NAME(IOCTL_SERIAL_, SET_RTS),
  TOCODE2NAME(IOCTL_SERIAL_, CLR_RTS),
  TOCODE2NAME(IOCTL_SERIAL_, SET_XOFF),
  TOCODE2NAME(IOCTL_SERIAL_, SET_XON),
  TOCODE2NAME(IOCTL_SERIAL_, GET_WAIT_MASK),
  TOCODE2NAME(IOCTL_SERIAL_, SET_WAIT_MASK),
  TOCODE2NAME(IOCTL_SERIAL_, WAIT_ON_MASK),
  TOCODE2NAME(IOCTL_SERIAL_, PURGE),
  TOCODE2NAME(IOCTL_SERIAL_, GET_BAUD_RATE),
  TOCODE2NAME(IOCTL_SERIAL_, GET_LINE_CONTROL),
  TOCODE2NAME(IOCTL_SERIAL_, GET_CHARS),
  TOCODE2NAME(IOCTL_SERIAL_, SET_CHARS),
  TOCODE2NAME(IOCTL_SERIAL_, GET_HANDFLOW),
  TOCODE2NAME(IOCTL_SERIAL_, SET_HANDFLOW),
  TOCODE2NAME(IOCTL_SERIAL_, GET_MODEMSTATUS),
  TOCODE2NAME(IOCTL_SERIAL_, GET_COMMSTATUS),
  TOCODE2NAME(IOCTL_SERIAL_, XOFF_COUNTER),
  TOCODE2NAME(IOCTL_SERIAL_, GET_PROPERTIES),
  TOCODE2NAME(IOCTL_SERIAL_, GET_DTRRTS),
  TOCODE2NAME(IOCTL_SERIAL_, LSRMST_INSERT),

  TOCODE2NAME(IOCTL_, SERENUM_EXPOSE_HARDWARE),
  TOCODE2NAME(IOCTL_, SERENUM_REMOVE_HARDWARE),
  TOCODE2NAME(IOCTL_, SERENUM_PORT_DESC),
  TOCODE2NAME(IOCTL_, SERENUM_GET_PORT_NAME),

  TOCODE2NAME(IOCTL_SERIAL_, CONFIG_SIZE),
  TOCODE2NAME(IOCTL_SERIAL_, GET_COMMCONFIG),
  TOCODE2NAME(IOCTL_SERIAL_, SET_COMMCONFIG),
  TOCODE2NAME(IOCTL_SERIAL_, GET_STATS),
  TOCODE2NAME(IOCTL_SERIAL_, CLEAR_STATS),
  TOCODE2NAME(IOCTL_SERIAL_, GET_MODEM_CONTROL),
  TOCODE2NAME(IOCTL_SERIAL_, SET_MODEM_CONTROL),
  TOCODE2NAME(IOCTL_SERIAL_, SET_FIFO_CONTROL),
  {0, NULL}
};

CODE2NAME codeNameTablePnp[] = {
  TOCODE2NAME(IRP_MN_, START_DEVICE),
  TOCODE2NAME(IRP_MN_, QUERY_REMOVE_DEVICE),
  TOCODE2NAME(IRP_MN_, REMOVE_DEVICE),
  TOCODE2NAME(IRP_MN_, CANCEL_REMOVE_DEVICE),
  TOCODE2NAME(IRP_MN_, STOP_DEVICE),
  TOCODE2NAME(IRP_MN_, QUERY_STOP_DEVICE),
  TOCODE2NAME(IRP_MN_, CANCEL_STOP_DEVICE),
  TOCODE2NAME(IRP_MN_, QUERY_DEVICE_RELATIONS),
  TOCODE2NAME(IRP_MN_, QUERY_INTERFACE),
  TOCODE2NAME(IRP_MN_, QUERY_CAPABILITIES),
  TOCODE2NAME(IRP_MN_, QUERY_RESOURCES),
  TOCODE2NAME(IRP_MN_, QUERY_RESOURCE_REQUIREMENTS),
  TOCODE2NAME(IRP_MN_, QUERY_DEVICE_TEXT),
  TOCODE2NAME(IRP_MN_, FILTER_RESOURCE_REQUIREMENTS),
  TOCODE2NAME(IRP_MN_, READ_CONFIG),
  TOCODE2NAME(IRP_MN_, WRITE_CONFIG),
  TOCODE2NAME(IRP_MN_, EJECT),
  TOCODE2NAME(IRP_MN_, SET_LOCK),
  TOCODE2NAME(IRP_MN_, QUERY_ID),
  TOCODE2NAME(IRP_MN_, QUERY_PNP_DEVICE_STATE),
  TOCODE2NAME(IRP_MN_, QUERY_BUS_INFORMATION),
  TOCODE2NAME(IRP_MN_, DEVICE_USAGE_NOTIFICATION),
  TOCODE2NAME(IRP_MN_, SURPRISE_REMOVAL),
#ifndef IRP_MN_QUERY_LEGACY_BUS_INFORMATION
  #define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#endif
  TOCODE2NAME(IRP_MN_, QUERY_LEGACY_BUS_INFORMATION),
  {0, NULL}
};

CODE2NAME codeNameTablePower[] = {
  TOCODE2NAME(IRP_MN_, WAIT_WAKE),
  TOCODE2NAME(IRP_MN_, POWER_SEQUENCE),
  TOCODE2NAME(IRP_MN_, SET_POWER),
  TOCODE2NAME(IRP_MN_, QUERY_POWER),
  {0, NULL}
};

CODE2NAME codeNameTablePowerType[] = {
  {SystemPowerState, "Sys"},
  {DevicePowerState, "Dev"},
  {0, NULL}
};

CODE2NAME codeNameTableSystemPowerState[] = {
  TOCODE2NAME(PowerSystem, Unspecified),
  TOCODE2NAME(PowerSystem, Working),
  TOCODE2NAME(PowerSystem, Sleeping1),
  TOCODE2NAME(PowerSystem, Sleeping2),
  TOCODE2NAME(PowerSystem, Sleeping3),
  TOCODE2NAME(PowerSystem, Hibernate),
  TOCODE2NAME(PowerSystem, Shutdown),
  TOCODE2NAME(PowerSystem, Maximum),
  {0, NULL}
};

CODE2NAME codeNameTableDevicePowerState[] = {
  TOCODE2NAME(PowerDevice, Unspecified),
  TOCODE2NAME(PowerDevice, D0),
  TOCODE2NAME(PowerDevice, D1),
  TOCODE2NAME(PowerDevice, D2),
  TOCODE2NAME(PowerDevice, D3),
  TOCODE2NAME(PowerDevice, Maximum),
  {0, NULL}
};

CODE2NAME codeNameTablePowerAction[] = {
  TOCODE2NAME(PowerAction, None),
  TOCODE2NAME(PowerAction, Reserved),
  TOCODE2NAME(PowerAction, Sleep),
  TOCODE2NAME(PowerAction, Hibernate),
  TOCODE2NAME(PowerAction, Shutdown),
  TOCODE2NAME(PowerAction, ShutdownReset),
  TOCODE2NAME(PowerAction, ShutdownOff),
  TOCODE2NAME(PowerAction, WarmEject),
  {0, NULL}
};

CODE2NAME codeNameTableWmi[] = {
  TOCODE2NAME(IRP_MN_, QUERY_ALL_DATA),
  TOCODE2NAME(IRP_MN_, QUERY_SINGLE_INSTANCE),
  TOCODE2NAME(IRP_MN_, CHANGE_SINGLE_INSTANCE),
  TOCODE2NAME(IRP_MN_, CHANGE_SINGLE_ITEM),
  TOCODE2NAME(IRP_MN_, ENABLE_EVENTS),
  TOCODE2NAME(IRP_MN_, DISABLE_EVENTS),
  TOCODE2NAME(IRP_MN_, ENABLE_COLLECTION),
  TOCODE2NAME(IRP_MN_, DISABLE_COLLECTION),
  TOCODE2NAME(IRP_MN_, REGINFO),
  TOCODE2NAME(IRP_MN_, EXECUTE_METHOD),
#ifndef IRP_MN_REGINFO_EX
  #define IRP_MN_REGINFO_EX                   0x0b
#endif
  TOCODE2NAME(IRP_MN_, REGINFO_EX),
  {0, NULL}
};

CODE2NAME codeNameTableDoType[] = {
  TOCODE2NAME(C0C_DOTYPE_, FB),
  TOCODE2NAME(C0C_DOTYPE_, PP),
  TOCODE2NAME(C0C_DOTYPE_, FP),
  {0, NULL}
};

CODE2NAME codeNameTableModemStatus[] = {
  TOCODE2NAME(C0C_MSB_, CTS),
  TOCODE2NAME(C0C_MSB_, DSR),
  TOCODE2NAME(C0C_MSB_, RING),
  TOCODE2NAME(C0C_MSB_, RLSD),
  {0, NULL}
};

CODE2NAME codeNameTableModemControl[] = {
  TOCODE2NAME(C0C_MCR_, DTR),
  TOCODE2NAME(C0C_MCR_, RTS),
  TOCODE2NAME(C0C_MCR_, OUT1),
  TOCODE2NAME(C0C_MCR_, OUT2),
  TOCODE2NAME(C0C_MCR_, LOOP),
  TOCODE2NAME(C0C_MCR_, OPEN),
  {0, NULL}
};

FIELD2NAME codeNameTableControlHandShake[] = {
  TOFIELD2NAME (SERIAL_, DTR_CONTROL,     SERIAL_DTR_MASK),
  TOFIELD2NAME (SERIAL_, DTR_HANDSHAKE,   SERIAL_DTR_MASK),
  TOFIELD2NAME2(SERIAL_, CTS_HANDSHAKE),
  TOFIELD2NAME2(SERIAL_, DSR_HANDSHAKE),
  TOFIELD2NAME2(SERIAL_, DCD_HANDSHAKE),
  TOFIELD2NAME2(SERIAL_, DSR_SENSITIVITY),
  TOFIELD2NAME2(SERIAL_, ERROR_ABORT),
  {0, 0, NULL}
};

FIELD2NAME codeNameTableFlowReplace[] = {
  TOFIELD2NAME2(SERIAL_, AUTO_TRANSMIT),
  TOFIELD2NAME2(SERIAL_, AUTO_RECEIVE),
  TOFIELD2NAME2(SERIAL_, ERROR_CHAR),
  TOFIELD2NAME2(SERIAL_, NULL_STRIPPING),
  TOFIELD2NAME2(SERIAL_, BREAK_CHAR),
  TOFIELD2NAME (SERIAL_, RTS_CONTROL,     SERIAL_RTS_MASK),
  TOFIELD2NAME (SERIAL_, RTS_HANDSHAKE,   SERIAL_RTS_MASK),
  TOFIELD2NAME (SERIAL_, TRANSMIT_TOGGLE, SERIAL_RTS_MASK),
  TOFIELD2NAME2(SERIAL_, XOFF_CONTINUE),
  {0, 0, NULL}
};

CODE2NAME codeNameTableStatus[] = {
  TOCODE2NAME(STATUS_, ACCESS_DENIED),
  TOCODE2NAME(STATUS_, BUFFER_TOO_SMALL),
  TOCODE2NAME(STATUS_, CANCELLED),
  TOCODE2NAME(STATUS_, DEVICE_BUSY),
  TOCODE2NAME(STATUS_, INSUFFICIENT_RESOURCES),
  TOCODE2NAME(STATUS_, INVALID_DEVICE_REQUEST),
  TOCODE2NAME(STATUS_, INVALID_PARAMETER),
  TOCODE2NAME(STATUS_, NO_SUCH_DEVICE),
  TOCODE2NAME(STATUS_, NOT_IMPLEMENTED),
  TOCODE2NAME(STATUS_, NOT_SUPPORTED),
  TOCODE2NAME(STATUS_, OBJECT_NAME_NOT_FOUND),
  TOCODE2NAME(STATUS_, PENDING),
  TOCODE2NAME(STATUS_, SERIAL_COUNTER_TIMEOUT),
  TOCODE2NAME(STATUS_, SERIAL_MORE_WRITES),
  TOCODE2NAME(STATUS_, SUCCESS),
  TOCODE2NAME(STATUS_, TIMEOUT),
  TOCODE2NAME(STATUS_, UNSUCCESSFUL),
  TOCODE2NAME(STATUS_, WAIT_1),
  TOCODE2NAME(STATUS_, WAIT_2),
  TOCODE2NAME(STATUS_, WAIT_3),
  TOCODE2NAME(STATUS_, WMI_GUID_NOT_FOUND),
  {0, NULL}
};

CODE2NAME codeNameTableIrpMj[] = {
  TOCODE2NAME(IRP_MJ_, CREATE),
  TOCODE2NAME(IRP_MJ_, CREATE_NAMED_PIPE),
  TOCODE2NAME(IRP_MJ_, CLOSE),
  TOCODE2NAME(IRP_MJ_, READ),
  TOCODE2NAME(IRP_MJ_, WRITE),
  TOCODE2NAME(IRP_MJ_, QUERY_INFORMATION),
  TOCODE2NAME(IRP_MJ_, SET_INFORMATION),
  TOCODE2NAME(IRP_MJ_, QUERY_EA),
  TOCODE2NAME(IRP_MJ_, SET_EA),
  TOCODE2NAME(IRP_MJ_, FLUSH_BUFFERS),
  TOCODE2NAME(IRP_MJ_, QUERY_VOLUME_INFORMATION),
  TOCODE2NAME(IRP_MJ_, SET_VOLUME_INFORMATION),
  TOCODE2NAME(IRP_MJ_, DIRECTORY_CONTROL),
  TOCODE2NAME(IRP_MJ_, FILE_SYSTEM_CONTROL),
  TOCODE2NAME(IRP_MJ_, DEVICE_CONTROL),
  TOCODE2NAME(IRP_MJ_, INTERNAL_DEVICE_CONTROL),
  TOCODE2NAME(IRP_MJ_, SHUTDOWN),
  TOCODE2NAME(IRP_MJ_, LOCK_CONTROL),
  TOCODE2NAME(IRP_MJ_, CLEANUP),
  TOCODE2NAME(IRP_MJ_, CREATE_MAILSLOT),
  TOCODE2NAME(IRP_MJ_, QUERY_SECURITY),
  TOCODE2NAME(IRP_MJ_, SET_SECURITY),
  TOCODE2NAME(IRP_MJ_, POWER),
  TOCODE2NAME(IRP_MJ_, SYSTEM_CONTROL),
  TOCODE2NAME(IRP_MJ_, DEVICE_CHANGE),
  TOCODE2NAME(IRP_MJ_, QUERY_QUOTA),
  TOCODE2NAME(IRP_MJ_, SET_QUOTA),
  TOCODE2NAME(IRP_MJ_, PNP),
  {0, NULL}
};

CODE2NAME codeNameTableRelations[] = {
  TOCODE2NAME1(BusRelations),
  TOCODE2NAME1(EjectionRelations),
  TOCODE2NAME1(PowerRelations),
  TOCODE2NAME1(RemovalRelations),
  TOCODE2NAME1(TargetDeviceRelation),
  {0, NULL}
};

CODE2NAME codeNameTableBusQuery[] = {
  TOCODE2NAME(BusQuery, DeviceID),
  TOCODE2NAME(BusQuery, HardwareIDs),
  TOCODE2NAME(BusQuery, CompatibleIDs),
  TOCODE2NAME(BusQuery, InstanceID),
  TOCODE2NAME(BusQuery, DeviceSerialNumber),
  {0, NULL}
};

CODE2NAME codeNameTableDeviceText[] = {
  TOCODE2NAME(DeviceText, Description),
  TOCODE2NAME(DeviceText, LocationInformation),
  {0, NULL}
};

CODE2NAME codeNameTableErrors[] = {
  TOCODE2NAME(SERIAL_ERROR_, BREAK),
  TOCODE2NAME(SERIAL_ERROR_, FRAMING),
  TOCODE2NAME(SERIAL_ERROR_, OVERRUN),
  TOCODE2NAME(SERIAL_ERROR_, QUEUEOVERRUN),
  TOCODE2NAME(SERIAL_ERROR_, PARITY),
  {0, NULL}
};

CODE2NAME codeNameTableHoldReasons[] = {
  TOCODE2NAME(SERIAL_TX_WAITING_, FOR_CTS),
  TOCODE2NAME(SERIAL_TX_WAITING_, FOR_DSR),
  TOCODE2NAME(SERIAL_TX_WAITING_, FOR_DCD),
  TOCODE2NAME(SERIAL_TX_WAITING_, FOR_XON),
  TOCODE2NAME(SERIAL_TX_WAITING_, XOFF_SENT),
  TOCODE2NAME(SERIAL_TX_WAITING_, ON_BREAK),
  TOCODE2NAME(SERIAL_RX_WAITING_, FOR_DSR),
  {0, NULL}
};

CODE2NAME codeNameTableFileInformationClass[] = {
  TOCODE2NAME1(FileDirectoryInformation),
  TOCODE2NAME1(FileFullDirectoryInformation),
  TOCODE2NAME1(FileBothDirectoryInformation),
  TOCODE2NAME1(FileBasicInformation),
  TOCODE2NAME1(FileStandardInformation),
  TOCODE2NAME1(FileInternalInformation),
  TOCODE2NAME1(FileEaInformation),
  TOCODE2NAME1(FileAccessInformation),
  TOCODE2NAME1(FileNameInformation),
  TOCODE2NAME1(FileRenameInformation),
  TOCODE2NAME1(FileLinkInformation),
  TOCODE2NAME1(FileNamesInformation),
  TOCODE2NAME1(FileDispositionInformation),
  TOCODE2NAME1(FilePositionInformation),
  TOCODE2NAME1(FileFullEaInformation),
  TOCODE2NAME1(FileModeInformation),
  TOCODE2NAME1(FileAlignmentInformation),
  TOCODE2NAME1(FileAllInformation),
  TOCODE2NAME1(FileAllocationInformation),
  TOCODE2NAME1(FileEndOfFileInformation),
  TOCODE2NAME1(FileAlternateNameInformation),
  TOCODE2NAME1(FileStreamInformation),
  TOCODE2NAME1(FilePipeInformation),
  TOCODE2NAME1(FilePipeLocalInformation),
  TOCODE2NAME1(FilePipeRemoteInformation),
  TOCODE2NAME1(FileMailslotQueryInformation),
  TOCODE2NAME1(FileMailslotSetInformation),
  TOCODE2NAME1(FileCompressionInformation),
  TOCODE2NAME1(FileObjectIdInformation),
  TOCODE2NAME1(FileCompletionInformation),
  TOCODE2NAME1(FileMoveClusterInformation),
  TOCODE2NAME1(FileQuotaInformation),
  TOCODE2NAME1(FileReparsePointInformation),
  TOCODE2NAME1(FileNetworkOpenInformation),
  TOCODE2NAME1(FileAttributeTagInformation),
  TOCODE2NAME1(FileTrackingInformation),
  TOCODE2NAME1(FileMaximumInformation),
  {0, NULL}
};

CODE2NAME codeNameTableShowPort[] = {
  TOCODE2NAME(C0C_SHOW_, PORTNAME),
  TOCODE2NAME(C0C_SHOW_, SYMLINK),
  TOCODE2NAME(C0C_SHOW_, DEVICEMAP),
  TOCODE2NAME(C0C_SHOW_, INTERFACE),
  TOCODE2NAME(C0C_SHOW_, WMIREG),
  {0, NULL}
};

#else /* ENABLE_TRACING */
  #pragma warning(disable:4206) // nonstandard extension used : translation unit is empty
#endif /* ENABLE_TRACING */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/read.c

/*
 * $Id: read.c,v 1.7 2008/12/02 16:21:11 vfrolov Exp $
 *
 * Copyright (c) 2004-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: read.c,v $
 * Revision 1.7  2008/12/02 16:21:11  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.6  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.5  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.4  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.3  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.2  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"

NTSTATUS StartIrpRead(
    IN PC0C_IO_PORT pIoPort,
    IN PLIST_ENTRY pQueueToComplete)
{
  return ReadWrite(
      pIoPort, TRUE,
      pIoPort->pIoPortRemote, FALSE,
      pQueueToComplete);
}

NTSTATUS FdoPortRead(IN PC0C_IO_PORT pIoPort, IN PIRP pIrp)
{
  NTSTATUS status;

  pIrp->IoStatus.Information = 0;

  if ((pIoPort->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pIoPort->errors) {
    status = STATUS_CANCELLED;
  } else {
    if (IoGetCurrentIrpStackLocation(pIrp)->Parameters.Read.Length)
      status = FdoPortStartIrp(pIoPort, pIrp, C0C_QUEUE_READ, StartIrpRead);
    else
      status = STATUS_SUCCESS;
  }

  if (status != STATUS_PENDING) {
    TraceIrp("FdoPortRead", pIrp, &status, TRACE_FLAG_RESULTS);
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}

NTSTATUS c0cRead(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

#if ENABLE_TRACING
  ULONG code = IoGetCurrentIrpStackLocation(pIrp)->MajorFunction;
#endif /* ENABLE_TRACING */

  TraceIrp("c0cRead", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    status = FdoPortRead(((PC0C_FDOPORT_EXTENSION)pDevExt)->pIoPortLocal, pIrp);
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

#if ENABLE_TRACING
  if (!NT_SUCCESS(status))
    TraceCode(pDevExt, "IRP_MJ_", codeNameTableIrpMj, code, &status);
#endif /* ENABLE_TRACING */

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/commprop.c

/*
 * $Id: commprop.c,v 1.1 2006/08/23 13:09:15 vfrolov Exp $
 *
 * Copyright (c) 2006 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: commprop.c,v $
 * Revision 1.1  2006/08/23 13:09:15  vfrolov
 * Initial revision
 *
 *
 */

#include "precomp.h"
#include "commprop.h"

NTSTATUS GetCommProp(
    PC0C_FDOPORT_EXTENSION pDevExt,
    PVOID pBuf,
    ULONG bufSize,
    PULONG pSize)
{
  *pSize = sizeof(SERIAL_COMMPROP);

  if (bufSize < sizeof(SERIAL_COMMPROP))
    return STATUS_BUFFER_TOO_SMALL;

  RtlZeroMemory(pBuf, sizeof(SERIAL_COMMPROP));

  ((PSERIAL_COMMPROP)pBuf)->PacketLength = sizeof(SERIAL_COMMPROP);
  ((PSERIAL_COMMPROP)pBuf)->PacketVersion = 2;
  ((PSERIAL_COMMPROP)pBuf)->ServiceMask = SERIAL_SP_SERIALCOMM;
  ((PSERIAL_COMMPROP)pBuf)->MaxTxQueue = 0;
  ((PSERIAL_COMMPROP)pBuf)->MaxRxQueue = 0;

  ((PSERIAL_COMMPROP)pBuf)->MaxBaud = SERIAL_BAUD_USER;

  ((PSERIAL_COMMPROP)pBuf)->SettableBaud =
    SERIAL_BAUD_075          |
    SERIAL_BAUD_110          |
    SERIAL_BAUD_134_5        |
    SERIAL_BAUD_150          |
    SERIAL_BAUD_300          |
    SERIAL_BAUD_600          |
    SERIAL_BAUD_1200         |
    SERIAL_BAUD_1800         |
    SERIAL_BAUD_2400         |
    SERIAL_BAUD_4800         |
    SERIAL_BAUD_7200         |
    SERIAL_BAUD_9600         |
    SERIAL_BAUD_14400        |
    SERIAL_BAUD_19200        |
    SERIAL_BAUD_38400        |
    SERIAL_BAUD_56K          |
    SERIAL_BAUD_128K         |
    SERIAL_BAUD_115200       |
    SERIAL_BAUD_57600        |
    SERIAL_BAUD_USER;

  ((PSERIAL_COMMPROP)pBuf)->ProvSubType = SERIAL_SP_RS232;

  ((PSERIAL_COMMPROP)pBuf)->ProvCapabilities =
    SERIAL_PCF_DTRDSR        |
    SERIAL_PCF_RTSCTS        |
    SERIAL_PCF_CD            |
    SERIAL_PCF_PARITY_CHECK  |
    SERIAL_PCF_XONXOFF       |
    SERIAL_PCF_SETXCHAR      |
    SERIAL_PCF_TOTALTIMEOUTS |
    SERIAL_PCF_INTTIMEOUTS;

  ((PSERIAL_COMMPROP)pBuf)->SettableParams =
    SERIAL_SP_PARITY         |
    SERIAL_SP_BAUD           |
    SERIAL_SP_DATABITS       |
    SERIAL_SP_STOPBITS       |
    SERIAL_SP_HANDSHAKING    |
    SERIAL_SP_PARITY_CHECK   |
    SERIAL_SP_CARRIER_DETECT;

  ((PSERIAL_COMMPROP)pBuf)->SettableData =
    SERIAL_DATABITS_5        |
    SERIAL_DATABITS_6        |
    SERIAL_DATABITS_7        |
    SERIAL_DATABITS_8;

  ((PSERIAL_COMMPROP)pBuf)->SettableStopParity =
    SERIAL_STOPBITS_10       |
    SERIAL_STOPBITS_15       |
    SERIAL_STOPBITS_20       |
    SERIAL_PARITY_NONE       |
    SERIAL_PARITY_ODD        |
    SERIAL_PARITY_EVEN       |
    SERIAL_PARITY_MARK       |
    SERIAL_PARITY_SPACE;

  ((PSERIAL_COMMPROP)pBuf)->CurrentTxQueue = 0;
  ((PSERIAL_COMMPROP)pBuf)->CurrentRxQueue = (ULONG)C0C_BUFFER_SIZE(&pDevExt->pIoPortLocal->readBuf);

  return STATUS_SUCCESS;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/power.c

/*
 * $Id: power.c,v 1.3 2007/02/21 16:48:44 vfrolov Exp $
 *
 * Copyright (c) 2004-2007 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: power.c,v $
 * Revision 1.3  2007/02/21 16:48:44  vfrolov
 * Added MajorFunction checking
 *
 * Revision 1.2  2006/07/17 10:03:54  vfrolov
 * Moved pIrpStack
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 *
 */

#include "precomp.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 0xC

NTSTATUS PdoPortPower(
    IN PC0C_PDOPORT_EXTENSION pDevExt,
    IN PIRP                   pIrp)
{
  NTSTATUS status;
  PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

  switch (pIrpStack->MinorFunction) {
  case IRP_MN_SET_POWER:
    switch (pIrpStack->Parameters.Power.Type) {
    case DevicePowerState:
      PoSetPowerState(pDevExt->pDevObj, DevicePowerState, pIrpStack->Parameters.Power.State);
      status = STATUS_SUCCESS;
      break;
    case SystemPowerState:
      status = STATUS_SUCCESS;
      break;
    default:
      status = STATUS_NOT_SUPPORTED;
      break;
    }
    break;
  case IRP_MN_QUERY_POWER:
    status = STATUS_SUCCESS;
    break;
  case IRP_MN_WAIT_WAKE:
  case IRP_MN_POWER_SEQUENCE:
  default:
    status = STATUS_NOT_SUPPORTED;
    break;
  }

  if (status != STATUS_NOT_SUPPORTED)
    pIrp->IoStatus.Status = status;

  PoStartNextPowerIrp(pIrp);
  status = pIrp->IoStatus.Status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}

NTSTATUS c0cPowerDispatch(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

  HALT_UNLESS2(IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_POWER,
      IoGetCurrentIrpStackLocation(pIrp)->MajorFunction,
      IoGetCurrentIrpStackLocation(pIrp)->MinorFunction);

  TraceIrp("POWER", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FB:
  case C0C_DOTYPE_FP:
    PoStartNextPowerIrp(pIrp);
    IoSkipCurrentIrpStackLocation(pIrp);
    status = PoCallDriver(((PC0C_COMMON_FDO_EXTENSION)pDevExt)->pLowDevObj, pIrp);
    break;
  case C0C_DOTYPE_PP:
    status = PdoPortPower((PC0C_PDOPORT_EXTENSION)pDevExt, pIrp);
    break;
  default:
    status = STATUS_NO_SUCH_DEVICE;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/startirp.c

/*
 * $Id: startirp.c,v 1.21 2012/02/03 17:14:24 vfrolov Exp $
 *
 * Copyright (c) 2004-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: startirp.c,v $
 * Revision 1.21  2012/02/03 17:14:24  vfrolov
 * Optimized GetIrpState()
 *
 * Revision 1.20  2010/08/04 10:38:56  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.19  2009/09/21 08:49:56  vfrolov
 * Added missing removing from queue
 * (Thanks Kirill Bagrinovsky)
 *
 * Revision 1.18  2007/06/20 10:37:47  vfrolov
 * Fixed double decrementing of amountInWriteQueue on CANCEL
 *
 * Revision 1.17  2007/06/04 15:24:33  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.16  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.15  2007/01/22 17:05:16  vfrolov
 * Added missing IoMarkIrpPending()
 *
 * Revision 1.14  2007/01/15 16:09:16  vfrolov
 * Fixed non zero Information for IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.13  2006/06/28 13:52:09  vfrolov
 * Fixed double-release of spin lock
 *
 * Revision 1.12  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.11  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.10  2006/06/08 11:33:35  vfrolov
 * Fixed bugs with amountInWriteQueue
 *
 * Revision 1.9  2006/05/17 15:31:14  vfrolov
 * Implemented SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.8  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.7  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.6  2005/11/29 16:16:46  vfrolov
 * Removed FdoPortCancelQueue()
 *
 * Revision 1.5  2005/09/13 14:56:16  vfrolov
 * Implemented IRP_MJ_FLUSH_BUFFERS
 *
 * Revision 1.4  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.3  2005/08/24 12:50:40  vfrolov
 * Fixed IRP processing order
 *
 * Revision 1.2  2005/07/14 13:51:09  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "handflow.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 2

VOID ShiftQueue(PC0C_IRP_QUEUE pQueue)
{
  if (pQueue->pCurrent) {
    PC0C_IRP_STATE pState;

    pState = GetIrpState(pQueue->pCurrent);

    HALT_UNLESS(pState);

    pQueue->pCurrent = NULL;
    pState->flags &= ~C0C_IRP_FLAG_IS_CURRENT;
  }

  if (!IsListEmpty(&pQueue->queue)) {
    PC0C_IRP_STATE pState;
    PIRP pIrp;
    PLIST_ENTRY pListEntry;

    pListEntry = RemoveHeadList(&pQueue->queue);
    pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

    pState = GetIrpState(pIrp);

    HALT_UNLESS(pState);

    pQueue->pCurrent = pIrp;
    pState->flags &= ~C0C_IRP_FLAG_IN_QUEUE;
    pState->flags |= C0C_IRP_FLAG_IS_CURRENT;
  }
}

DRIVER_CANCEL CancelRoutine;
VOID CancelRoutine(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  LIST_ENTRY queueToComplete;
  PC0C_IO_PORT pIoPort;
  PC0C_IRP_STATE pState;
  KIRQL oldIrql;
  PC0C_IRP_QUEUE pQueue;

  IoReleaseCancelSpinLock(pIrp->CancelIrql);

  pIoPort = FDO_PORT_TO_IO_PORT(pDevObj);
  pState = GetIrpState(pIrp);
  HALT_UNLESS(pState);

  pQueue = &pIoPort->irpQueues[pState->iQueue];

  InitializeListHead(&queueToComplete);

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  if (pState->flags & C0C_IRP_FLAG_IN_QUEUE) {
    RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
    pState->flags &= ~C0C_IRP_FLAG_IN_QUEUE;
  }

  pIrp->IoStatus.Status = STATUS_CANCELLED;
  InsertTailList(&queueToComplete, &pIrp->Tail.Overlay.ListEntry);

  if (pState->flags & C0C_IRP_FLAG_IS_CURRENT) {
    ShiftQueue(pQueue);

    if (pState->iQueue == C0C_QUEUE_WRITE)
      ReadWrite(pIoPort->pIoPortRemote, FALSE, pIoPort, FALSE, &queueToComplete);
  }

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  FdoPortCompleteQueue(&queueToComplete);
}

VOID CompleteIrp(PIRP pIrp, NTSTATUS status, PLIST_ENTRY pQueueToComplete)
{
  PDRIVER_CANCEL pCancelRoutine;

  #pragma warning(push, 3)
  pCancelRoutine = IoSetCancelRoutine(pIrp, NULL);
  #pragma warning(pop)

  if (pCancelRoutine) {
    pIrp->IoStatus.Status = status;
    InsertTailList(pQueueToComplete, &pIrp->Tail.Overlay.ListEntry);
  }
}

VOID CancelQueue(PC0C_IRP_QUEUE pQueue, PLIST_ENTRY pQueueToComplete)
{
  while (pQueue->pCurrent) {
    PIRP pIrp;

    pIrp = pQueue->pCurrent;
    ShiftQueue(pQueue);

    CompleteIrp(pIrp, STATUS_CANCELLED, pQueueToComplete);
  }
}

VOID FdoPortCancelQueues(IN PC0C_IO_PORT pIoPort)
{
  LIST_ENTRY queueToComplete;
  KIRQL oldIrql;
  int i;

  InitializeListHead(&queueToComplete);
  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  for (i = 0 ; i < C0C_QUEUE_SIZE ; i++)
    CancelQueue(&pIoPort->irpQueues[i], &queueToComplete);

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);
  FdoPortCompleteQueue(&queueToComplete);
}

VOID FdoPortCompleteQueue(IN PLIST_ENTRY pQueueToComplete)
{
  while (!IsListEmpty(pQueueToComplete)) {
    PIRP pIrp;
    PC0C_IRP_STATE pState;
    PLIST_ENTRY pListEntry;
    PIO_STACK_LOCATION pIrpStack;

    pListEntry = RemoveHeadList(pQueueToComplete);
    pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    if (pIrp->IoStatus.Status == STATUS_TIMEOUT && pIrp->IoStatus.Information &&
        pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
            pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)
    {
      pIrp->IoStatus.Status = STATUS_SERIAL_COUNTER_TIMEOUT;
    }

    TraceIrp("complete", pIrp, &pIrp->IoStatus.Status, TRACE_FLAG_RESULTS);

    pState = GetIrpState(pIrp);
    HALT_UNLESS(pState);

    if (pState->iQueue == C0C_QUEUE_WRITE) {
      KIRQL oldIrql;
      PC0C_IO_PORT pIoPort;

      pIoPort = FDO_PORT_TO_IO_PORT(IoGetCurrentIrpStackLocation(pIrp)->DeviceObject);

      KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);
      pIoPort->amountInWriteQueue -=
          GetWriteLength(pIrp) - (ULONG)pIrp->IoStatus.Information;
      KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);
    }

    if (pIrp->IoStatus.Status == STATUS_CANCELLED ||
        (pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
            (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR ||
                pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)))
    {
      pIrp->IoStatus.Information = 0;
    }

    IoCompleteRequest(pIrp, IO_SERIAL_INCREMENT);
  }
}

NTSTATUS NoPending(IN PIRP pIrp, NTSTATUS status)
{
  PDRIVER_CANCEL pCancelRoutine;

  #pragma warning(push, 3)
  pCancelRoutine = IoSetCancelRoutine(pIrp, NULL);
  #pragma warning(pop)

  if (!pCancelRoutine) {
    IoMarkIrpPending(pIrp);
    return STATUS_PENDING;
  }

  return status;
}

NTSTATUS StartIrp(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp,
    PC0C_IRP_STATE pState,
    PC0C_IRP_QUEUE pQueue,
    PLIST_ENTRY pQueueToComplete,
    PC0C_FDOPORT_START_ROUTINE pStartRoutine)
{
  NTSTATUS status;

  pQueue->pCurrent = pIrp;
  pState->flags |= C0C_IRP_FLAG_IS_CURRENT;

  if (pState->iQueue == C0C_QUEUE_WRITE) {
    ULONG length = GetWriteLength(pIrp);

    if (length) {
      pIoPort->amountInWriteQueue += length;
      UpdateTransmitToggle(pIoPort, pQueueToComplete);
    }
  }

  status = pStartRoutine(pIoPort, pQueueToComplete);

  if (status == STATUS_PENDING) {
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);
  } else {
    status = NoPending(pIrp, status);

    if (status != STATUS_PENDING) {
      PIO_STACK_LOCATION pIrpStack;

      if (pState->iQueue == C0C_QUEUE_WRITE) {
        pIoPort->amountInWriteQueue -=
            GetWriteLength(pIrp) - (ULONG)pIrp->IoStatus.Information;
      }

      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

      if (status == STATUS_CANCELLED ||
          (pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
              (pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR ||
                  pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER)))
      {
        pIrp->IoStatus.Information = 0;
      }
    }

    if (pQueue->pCurrent == pIrp)
      ShiftQueue(pQueue);
  }

  return status;
}

NTSTATUS FdoPortStartIrp(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN UCHAR iQueue,
    IN PC0C_FDOPORT_START_ROUTINE pStartRoutine)
{
  NTSTATUS status;
  LIST_ENTRY queueToComplete;
  KIRQL oldIrql;
  PC0C_IRP_QUEUE pQueue;
  PC0C_IRP_STATE pState;

  InitializeListHead(&queueToComplete);
  pState = GetIrpState(pIrp);

  HALT_UNLESS(pState);

  pState->flags = 0;
  pState->iQueue = iQueue;

  pQueue = &pIoPort->irpQueues[iQueue];

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);

  #pragma warning(push, 3)
  IoSetCancelRoutine(pIrp, CancelRoutine);
  #pragma warning(pop)

  if (pIrp->Cancel) {
    status = NoPending(pIrp, STATUS_CANCELLED);
  } else {
    if (!pQueue->pCurrent) {
      status = StartIrp(pIoPort, pIrp, pState, pQueue, &queueToComplete, pStartRoutine);
    } else {
      PIO_STACK_LOCATION pIrpStack;
      PIO_STACK_LOCATION pCurrentStack;

      pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
      pCurrentStack = IoGetCurrentIrpStackLocation(pQueue->pCurrent);

      if (pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
          pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK)
      {
        status = NoPending(pIrp, STATUS_INVALID_PARAMETER);
      }
      else
      if (pIrpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
          pIrpStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
      {
        if (pCurrentStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
            pCurrentStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
        {
          status = NoPending(pIrp, STATUS_INVALID_PARAMETER);
        } else {
          PC0C_IRP_STATE pCurrentState;

          pCurrentState = GetIrpState(pQueue->pCurrent);

          HALT_UNLESS(pCurrentState);

          pCurrentState->flags &= ~C0C_IRP_FLAG_IS_CURRENT;
          InsertHeadList(&pQueue->queue, &pQueue->pCurrent->Tail.Overlay.ListEntry);
          pCurrentState->flags |= C0C_IRP_FLAG_IN_QUEUE;

          status = StartIrp(pIoPort, pIrp, pState, pQueue, &queueToComplete, pStartRoutine);
        }
      }
      else {
        InsertTailList(&pQueue->queue, &pIrp->Tail.Overlay.ListEntry);
        pState->flags |= C0C_IRP_FLAG_IN_QUEUE;

        if (pState->iQueue == C0C_QUEUE_WRITE) {
          pIoPort->amountInWriteQueue += GetWriteLength(pIrp);
        }

        if (pCurrentStack->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
            pCurrentStack->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_XOFF_COUNTER &&
            pQueue->pCurrent->IoStatus.Information)
        {
          if (pIrpStack->MajorFunction == IRP_MJ_FLUSH_BUFFERS) {
            RemoveEntryList(&pIrp->Tail.Overlay.ListEntry);
            pState->flags &= ~C0C_IRP_FLAG_IN_QUEUE;
            status = NoPending(pIrp, STATUS_SUCCESS);
          } else {
            PIRP pIrpXoffCounter = pQueue->pCurrent;

            ShiftQueue(pQueue);
            CompleteIrp(pIrpXoffCounter, STATUS_SERIAL_MORE_WRITES, &queueToComplete);

            status = StartIrp(pIoPort, pIrp, pState, pQueue, &queueToComplete, pStartRoutine);
          }
        } else {
          pIrp->IoStatus.Status = STATUS_PENDING;
          IoMarkIrpPending(pIrp);
          status = STATUS_PENDING;
        }
      }
    }
  }

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  FdoPortCompleteQueue(&queueToComplete);

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/noise.c

/*
 * $Id: noise.c,v 1.4 2008/10/30 07:54:37 vfrolov Exp $
 *
 * Copyright (c) 2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: noise.c,v $
 * Revision 1.4  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.3  2008/09/02 07:37:34  vfrolov
 * Fixed bits in BreakError()
 *
 * Revision 1.2  2008/09/01 16:45:12  vfrolov
 * Fixed bits in BreakError()
 *
 * Revision 1.1  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 */

#include "precomp.h"
#include "noise.h"
#include "rand.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 0xF

/********************************************************************/
VOID ParityError(PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)
{
  *pLsr |= 0x04;  /* parity error */
  pReadIoPort->errors |= SERIAL_ERROR_PARITY;
  pReadIoPort->perfStats.ParityErrorCount++;
}
/********************************************************************/
VOID FrameError(PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)
{
  *pLsr |= 0x08;  /* framing error */
  pReadIoPort->errors |= SERIAL_ERROR_FRAMING;
  pReadIoPort->perfStats.FrameErrorCount++;
}
/********************************************************************/
VOID BreakError(PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)
{
  *pLsr |= 0x18;  /* break interrupt indicator & framing error */
  pReadIoPort->errors |= SERIAL_ERROR_BREAK;

  if (pReadIoPort->lineControl.Parity == ODD_PARITY || pReadIoPort->lineControl.Parity == MARK_PARITY)
    *pLsr |= 0x04;  /* parity error */
}
/********************************************************************/
UCHAR GarbageChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pLsr)
{
  if (pWriteIoPort->lineControl.Parity != NO_PARITY && RAND()%2 > 0)
    ParityError(pReadIoPort, pLsr);

  if (RAND()%2 > 0)
    FrameError(pReadIoPort, pLsr);

  return (UCHAR)RAND();
}
/********************************************************************/
VOID BrokeChar(PC0C_IO_PORT pWriteIoPort, PC0C_IO_PORT pReadIoPort, PUCHAR pChar, PUCHAR pLsr)
{
  if (pWriteIoPort->brokeCharsProbability > (RAND()%C0C_PROBABILITY_ONE)) {
    int r = (int)(RAND()%(
                      + 1  /* start bit */
                      + 1  /* stop bit(s) */
                      + pWriteIoPort->lineControl.WordLength
                      + ((pWriteIoPort->lineControl.Parity != NO_PARITY) ? 1 : 0)
                      ));

    if (r-- == 0) {
      /* start bit error */

      pWriteIoPort->brokeChars = (short)(RAND()%512);  /* some of subsequent chars should be broken */
      *pChar = GarbageChar(pWriteIoPort, pReadIoPort, pLsr);
    }
    else
    if (r-- == 0) {
      /* stop bit error */

      pWriteIoPort->brokeChars = (short)(RAND()%512);  /* some of subsequent chars should be broken */
      FrameError(pReadIoPort, pLsr);
    }
    else
    if (r < pWriteIoPort->lineControl.WordLength) {
      /* data bit error */

      *pChar ^= (1 << r);

      if (pWriteIoPort->lineControl.Parity == ODD_PARITY || pWriteIoPort->lineControl.Parity == EVEN_PARITY)
        ParityError(pReadIoPort, pLsr);
    }
    else {
      /* parity bit error */

      ParityError(pReadIoPort, pLsr);
    }
  }
}
/********************************************************************/
SIZE_T GetBrokenChars(ULONG brokeCharsProbability, SIZE_T chars)
{
  SIZE_T brokeChars = 0;

  while (chars--) {
    if (brokeCharsProbability > (RAND()%C0C_PROBABILITY_ONE))
      brokeChars++;
  }

  return brokeChars;
}
/********************************************************************/


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/ioctl.c

/*
 * $Id: ioctl.c,v 1.43 2009/11/09 11:20:17 vfrolov Exp $
 *
 * Copyright (c) 2004-2009 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: ioctl.c,v $
 * Revision 1.43  2009/11/09 11:20:17  vfrolov
 * Added missing Information field setting (thanks Van Rillaer Filip)
 *
 * Revision 1.42  2009/05/20 13:45:35  vfrolov
 * Added tracing the resulting event mask on nonpending successful
 * completion of WAIT_ON_MASK
 *
 * Revision 1.41  2008/12/02 16:10:08  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.40  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.39  2008/09/12 10:07:50  vfrolov
 * Fixed LSR insertion
 *
 * Revision 1.38  2008/08/19 12:40:58  vfrolov
 * Replaces C0CE_INSERT_ENABLE_LSR_NBI (insertion on BREAK OFF)
 * by C0CE_INSERT_ENABLE_LSR_BI (insertion on BREAK change)
 *
 * Revision 1.37  2008/07/11 10:38:00  vfrolov
 * Added nonstandard ability to enable LSR insertion on BREAK OFF
 *
 * Revision 1.36  2008/06/10 11:32:35  vfrolov
 * Fixed break interrupt indicator for C0CE_INSERT_IOCTL_GET
 * Added parameter checking for IOCTL_SERIAL_SET_LINE_CONTROL
 *
 * Revision 1.35  2008/04/08 10:36:16  vfrolov
 * Implemented ability to set individual pins with extended
 * IOCTL_SERIAL_SET_MODEM_CONTROL and IOCTL_SERIAL_GET_MODEM_CONTROL
 *
 * Revision 1.34  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.33  2007/09/17 14:31:06  vfrolov
 * Implemented pseudo pin OPEN
 *
 * Revision 1.32  2007/07/09 11:15:42  vfrolov
 * Implemented IOCTL_SERIAL_SET_MODEM_CONTROL
 *
 * Revision 1.31  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.30  2007/06/01 08:36:26  vfrolov
 * Changed parameter type for SetWriteDelay()
 *
 * Revision 1.29  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.28  2007/01/15 16:07:12  vfrolov
 * Fixed non zero Information for IOCTL_SERIAL_PURGE and IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.27  2007/01/11 14:50:29  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.26  2006/08/23 13:16:50  vfrolov
 * Moved code for IOCTL_SERIAL_GET_PROPERTIES to commprop.c
 *
 * Revision 1.25  2006/07/17 09:58:21  vfrolov
 * Added #if DBG
 *
 * Revision 1.24  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.23  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.22  2006/05/19 15:02:03  vfrolov
 * Implemented IOCTL_SERIAL_GET_MODEM_CONTROL
 *
 * Revision 1.21  2006/05/18 09:38:10  vfrolov
 * Implemented SERIAL_TX_WAITING_XOFF_SENT
 *
 * Revision 1.20  2006/05/18 08:00:30  vfrolov
 * Implemented SERIAL_RX_WAITING_FOR_DSR
 *
 * Revision 1.19  2006/05/17 15:31:14  vfrolov
 * Implemented SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.18  2006/04/14 15:57:51  vfrolov
 * Fixed XON char sending delay after SERIAL_PURGE_RXCLEAR
 *   and IOCTL_SERIAL_SET_QUEUE_SIZE
 *
 * Revision 1.17  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.16  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.15  2005/12/28 10:01:59  vfrolov
 * Added stub for IOCTL_SERIAL_SET_XON
 *
 * Revision 1.14  2005/12/06 13:01:54  vfrolov
 * Implemented IOCTL_SERIAL_GET_DTRRTS
 *
 * Revision 1.13  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.12  2005/11/30 16:04:12  vfrolov
 * Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
 *
 * Revision 1.11  2005/11/29 16:16:46  vfrolov
 * Removed FdoPortCancelQueue()
 *
 * Revision 1.10  2005/11/29 12:33:21  vfrolov
 * Changed SetModemStatus() to ability set and clear bits simultaneously
 *
 * Revision 1.9  2005/11/28 12:57:16  vfrolov
 * Moved some C0C_BUFFER code to bufutils.c
 *
 * Revision 1.8  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.7  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.6  2005/07/14 12:29:23  vfrolov
 * Fixed BSOD on IRP_MJ_READ after IOCTL_SERIAL_SET_QUEUE_SIZE
 *
 * Revision 1.5  2005/05/19 08:23:41  vfrolov
 * Fixed data types
 *
 * Revision 1.4  2005/05/14 17:07:02  vfrolov
 * Implemented SERIAL_LSRMST_MST insertion
 *
 * Revision 1.3  2005/05/13 16:58:03  vfrolov
 * Implemented IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.2  2005/02/01 16:47:57  vfrolov
 * Implemented SERIAL_PURGE_RXCLEAR and IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "timeout.h"
#include "delay.h"
#include "bufutils.h"
#include "handflow.h"
#include "commprop.h"
#include "../include/cncext.h"

NTSTATUS FdoPortIoCtl(
    IN PC0C_FDOPORT_EXTENSION pDevExt,
    IN PIRP pIrp)
{
  NTSTATUS status;
  PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
  ULONG code = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
  KIRQL oldIrql;
  PC0C_IO_PORT pIoPortLocal;

  pIrp->IoStatus.Information = 0;
  pIoPortLocal = pDevExt->pIoPortLocal;

  if ((pIoPortLocal->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) &&
      pIoPortLocal->errors && code != IOCTL_SERIAL_GET_COMMSTATUS)
  {
    status = STATUS_CANCELLED;
  } else {
    status = STATUS_SUCCESS;

    switch (code) {
    case IOCTL_SERIAL_SET_RTS:
    case IOCTL_SERIAL_CLR_RTS:
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      switch (pIoPortLocal->handFlow.FlowReplace & SERIAL_RTS_MASK) {
        case SERIAL_RTS_HANDSHAKE:
        case SERIAL_TRANSMIT_TOGGLE:
          KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
          status = STATUS_INVALID_PARAMETER;
          break;
        default: {
          LIST_ENTRY queueToComplete;

          InitializeListHead(&queueToComplete);

          SetModemControl(
            pIoPortLocal,
            code == IOCTL_SERIAL_SET_RTS ? C0C_MCR_RTS : 0,
            C0C_MCR_RTS,
            &queueToComplete);

          if (pIoPortLocal->pIoPortRemote->tryWrite || pIoPortLocal->tryWrite) {
            ReadWrite(
                pIoPortLocal, FALSE,
                pIoPortLocal->pIoPortRemote, FALSE,
                &queueToComplete);
          }

          KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
          FdoPortCompleteQueue(&queueToComplete);
        }
      }
      break;
    case IOCTL_SERIAL_SET_DTR:
    case IOCTL_SERIAL_CLR_DTR:
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      switch (pIoPortLocal->handFlow.ControlHandShake & SERIAL_DTR_MASK) {
        case SERIAL_DTR_HANDSHAKE:
          KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
          status = STATUS_INVALID_PARAMETER;
          break;
        default: {
          LIST_ENTRY queueToComplete;

          InitializeListHead(&queueToComplete);

          SetModemControl(
            pIoPortLocal,
            code == IOCTL_SERIAL_SET_DTR ? C0C_MCR_DTR : 0,
            C0C_MCR_DTR,
            &queueToComplete);

          if (pIoPortLocal->pIoPortRemote->tryWrite || pIoPortLocal->tryWrite) {
            ReadWrite(
                pIoPortLocal, FALSE,
                pIoPortLocal->pIoPortRemote, FALSE,
                &queueToComplete);
          }

          KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
          FdoPortCompleteQueue(&queueToComplete);
        }
      }
      break;
    case IOCTL_SERIAL_SET_MODEM_CONTROL: {
      LIST_ENTRY queueToComplete;
      UCHAR mask;
      PUCHAR pSysBuf;
      ULONG InputBufferLength;

      InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

      if (InputBufferLength < sizeof(ULONG)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pSysBuf = (PUCHAR)pIrp->AssociatedIrp.SystemBuffer;

      if (InputBufferLength >= (sizeof(ULONG) + sizeof(ULONG) + C0CE_SIGNATURE_SIZE) &&
          RtlEqualMemory(pSysBuf + sizeof(ULONG) + sizeof(ULONG), C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE))
      {
        mask = C0C_MCR_MASK & (UCHAR)*((PULONG)pSysBuf + 1);
      } else {
        mask = C0C_MCR_MASK;
      }

      InitializeListHead(&queueToComplete);

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      SetModemControl(pIoPortLocal, (UCHAR)*(PULONG)pSysBuf, mask, &queueToComplete);

      if (pIoPortLocal->pIoPortRemote->tryWrite || pIoPortLocal->tryWrite) {
        ReadWrite(
            pIoPortLocal, FALSE,
            pIoPortLocal->pIoPortRemote, FALSE,
            &queueToComplete);
      }

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);
      break;
    }
    case IOCTL_SERIAL_GET_MODEM_CONTROL:
    case IOCTL_SERIAL_GET_DTRRTS: {
      ULONG modemControl;
      PUCHAR pSysBuf;
      ULONG OutputBufferLength;

      OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

      if (OutputBufferLength < sizeof(ULONG)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      modemControl = pIoPortLocal->modemControl;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);

      pSysBuf = (PUCHAR)pIrp->AssociatedIrp.SystemBuffer;

      if (code == IOCTL_SERIAL_GET_DTRRTS) {
        modemControl &= SERIAL_DTR_STATE | SERIAL_RTS_STATE;
        pIrp->IoStatus.Information = sizeof(ULONG);
      } else {
        ULONG InputBufferLength;

        InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

        if (OutputBufferLength >= (sizeof(ULONG) + C0CE_SIGNATURE_SIZE) &&
            InputBufferLength >= C0CE_SIGNATURE_SIZE &&
            RtlEqualMemory(pSysBuf, C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE))
        {
          RtlCopyMemory(pSysBuf + sizeof(PULONG), C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE);

          if (OutputBufferLength > (sizeof(ULONG) + C0CE_SIGNATURE_SIZE)) {
            RtlZeroMemory(pSysBuf + sizeof(ULONG) + C0CE_SIGNATURE_SIZE,
                          OutputBufferLength - (sizeof(ULONG) + C0CE_SIGNATURE_SIZE));
          }

          pIrp->IoStatus.Information = OutputBufferLength;
        } else {
          pIrp->IoStatus.Information = sizeof(ULONG);
        }

        modemControl &= C0C_MCR_MASK;
      }

      *(PULONG)pSysBuf = modemControl;

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    }
    case IOCTL_SERIAL_SET_XON: {
      LIST_ENTRY queueToComplete;

      InitializeListHead(&queueToComplete);

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      SetXonXoffHolding(pIoPortLocal, C0C_XCHAR_ON);

      if (pIoPortLocal->tryWrite) {
        ReadWrite(
            pIoPortLocal, FALSE,
            pIoPortLocal->pIoPortRemote, FALSE,
            &queueToComplete);
      }
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);
      break;
    }
    case IOCTL_SERIAL_SET_XOFF:
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      SetXonXoffHolding(pIoPortLocal, C0C_XCHAR_OFF);
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      break;
    case IOCTL_SERIAL_SET_BREAK_ON: {
      LIST_ENTRY queueToComplete;

      InitializeListHead(&queueToComplete);

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      SetBreakHolding(pIoPortLocal, TRUE, &queueToComplete);
      UpdateTransmitToggle(pIoPortLocal, &queueToComplete);

      ReadWrite(
          pIoPortLocal, FALSE,
          pIoPortLocal->pIoPortRemote, FALSE,
          &queueToComplete);

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);
      break;
    }
    case IOCTL_SERIAL_SET_BREAK_OFF:{
      LIST_ENTRY queueToComplete;

      InitializeListHead(&queueToComplete);

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      SetBreakHolding(pIoPortLocal, FALSE, &queueToComplete);
      UpdateTransmitToggle(pIoPortLocal, &queueToComplete);

      if (pIoPortLocal->tryWrite || pIoPortLocal->pIoPortRemote->tryWrite) {
        ReadWrite(
            pIoPortLocal, FALSE,
            pIoPortLocal->pIoPortRemote, FALSE,
            &queueToComplete);
      }
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);
      break;
    }
    case IOCTL_SERIAL_GET_MODEMSTATUS:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      *(PULONG)pIrp->AssociatedIrp.SystemBuffer = pIoPortLocal->modemStatus;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      pIrp->IoStatus.Information = sizeof(ULONG);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_SET_WAIT_MASK:
      status = FdoPortSetWaitMask(pIoPortLocal, pIrp, pIrpStack);
      break;
    case IOCTL_SERIAL_GET_WAIT_MASK:
      status = FdoPortGetWaitMask(pIoPortLocal, pIrp, pIrpStack);
      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_WAIT_ON_MASK:
      status = FdoPortWaitOnMask(pIoPortLocal, pIrp, pIrpStack);
#if ENABLE_TRACING
      if (status == STATUS_SUCCESS)
        TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
#endif /* ENABLE_TRACING */
      break;
    case IOCTL_SERIAL_IMMEDIATE_CHAR:
      status = FdoPortImmediateChar(pIoPortLocal, pIrp, pIrpStack);
      break;
    case IOCTL_SERIAL_XOFF_COUNTER:
      status = FdoPortXoffCounter(pIoPortLocal, pIrp, pIrpStack);
      break;
    case IOCTL_SERIAL_PURGE: {
      LIST_ENTRY queueToComplete;
      PULONG pSysBuf;

      if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pSysBuf = (PULONG)pIrp->AssociatedIrp.SystemBuffer;

      if (*pSysBuf & ~(
          SERIAL_PURGE_TXABORT |
          SERIAL_PURGE_RXABORT |
          SERIAL_PURGE_TXCLEAR |
          SERIAL_PURGE_RXCLEAR
          )) {
        status = STATUS_INVALID_PARAMETER;
        break;
      }

      InitializeListHead(&queueToComplete);
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      if (*pSysBuf & SERIAL_PURGE_RXABORT)
        CancelQueue(&pIoPortLocal->irpQueues[C0C_QUEUE_READ], &queueToComplete);

      if (*pSysBuf & SERIAL_PURGE_TXABORT)
        CancelQueue(&pIoPortLocal->irpQueues[C0C_QUEUE_WRITE], &queueToComplete);

      if (*pSysBuf & SERIAL_PURGE_RXCLEAR) {
        PurgeBuffer(&pIoPortLocal->readBuf);
        UpdateHandFlow(pIoPortLocal, TRUE, &queueToComplete);
        if (pIoPortLocal->tryWrite || pIoPortLocal->pIoPortRemote->tryWrite) {
          ReadWrite(
              pIoPortLocal, FALSE,
              pIoPortLocal->pIoPortRemote, FALSE,
              &queueToComplete);
        }
      }

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);

      break;
    }
    case IOCTL_SERIAL_GET_COMMSTATUS: {
      PSERIAL_STATUS pSysBuf;
      PIRP pIrpWrite;

      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_STATUS)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pSysBuf = (PSERIAL_STATUS)pIrp->AssociatedIrp.SystemBuffer;
      RtlZeroMemory(pSysBuf, sizeof(*pSysBuf));

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      pSysBuf->AmountInInQueue = (ULONG)C0C_BUFFER_BUSY(&pIoPortLocal->readBuf);

      pIrpWrite = pIoPortLocal->irpQueues[C0C_QUEUE_WRITE].pCurrent;

      if (pIrpWrite) {
        PIO_STACK_LOCATION pIrpStackWrite = IoGetCurrentIrpStackLocation(pIrpWrite);

        if (pIrpStackWrite->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
            pIrpStackWrite->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_IMMEDIATE_CHAR)
        {
          pSysBuf->WaitForImmediate = TRUE;
        }
      }

      pSysBuf->AmountInOutQueue = pIoPortLocal->amountInWriteQueue;
      pSysBuf->HoldReasons = pIoPortLocal->writeHolding;

      if ((pIoPortLocal->handFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY) &&
          (pIoPortLocal->modemStatus & C0C_MSB_DSR) == 0)
      {
        pSysBuf->HoldReasons |= SERIAL_RX_WAITING_FOR_DSR;
      }

      if (pIoPortLocal->writeHoldingRemote & SERIAL_TX_WAITING_FOR_XON)
        pSysBuf->HoldReasons |= SERIAL_TX_WAITING_XOFF_SENT;

      pSysBuf->Errors = pIoPortLocal->errors;
      pIoPortLocal->errors = 0;

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);

      pIrp->IoStatus.Information = sizeof(SERIAL_STATUS);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);

      break;
    }
    case IOCTL_SERIAL_SET_HANDFLOW: {
      LIST_ENTRY queueToComplete;
      PSERIAL_HANDFLOW pSysBuf;

      if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_HANDFLOW)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pSysBuf = (PSERIAL_HANDFLOW)pIrp->AssociatedIrp.SystemBuffer;

      if (pSysBuf->ControlHandShake & SERIAL_CONTROL_INVALID ||
          pSysBuf->FlowReplace & SERIAL_FLOW_INVALID ||
          (pSysBuf->ControlHandShake & SERIAL_DTR_MASK) == SERIAL_DTR_MASK ||
          pSysBuf->XonLimit < 0 ||
          pSysBuf->XoffLimit < 0)
      {
        status = STATUS_INVALID_PARAMETER;
        break;
      }

      InitializeListHead(&queueToComplete);
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      status = SetHandFlow(pIoPortLocal, pSysBuf, &queueToComplete);

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);
      break;
    }
    case IOCTL_SERIAL_GET_HANDFLOW:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_HANDFLOW)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      *(PSERIAL_HANDFLOW)pIrp->AssociatedIrp.SystemBuffer = pIoPortLocal->handFlow;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      pIrp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_SET_TIMEOUTS:
      status = FdoPortSetTimeouts(pIoPortLocal, pIrp, pIrpStack);
      break;
    case IOCTL_SERIAL_GET_TIMEOUTS:
      status = FdoPortGetTimeouts(pIoPortLocal, pIrp, pIrpStack);
      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_SET_CHARS: {
      PSERIAL_CHARS pSysBuf;

      if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_CHARS)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pSysBuf = (PSERIAL_CHARS)pIrp->AssociatedIrp.SystemBuffer;

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      if (pIoPortLocal->escapeChar &&
            ((pIoPortLocal->escapeChar == pSysBuf->XoffChar) ||
                (pIoPortLocal->escapeChar == pSysBuf->XonChar)))
      {
        status = STATUS_INVALID_PARAMETER;
      }

      if (status == STATUS_SUCCESS)
        pIoPortLocal->specialChars = *pSysBuf;

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      break;
    }
    case IOCTL_SERIAL_GET_CHARS:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_CHARS)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      *(PSERIAL_CHARS)pIrp->AssociatedIrp.SystemBuffer = pIoPortLocal->specialChars;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);

      pIrp->IoStatus.Information = sizeof(SERIAL_CHARS);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_LSRMST_INSERT: {
      ULONG Information;
      ULONG optsAndBits;
      UCHAR escapeChar;
      PUCHAR pSysBuf;
      ULONG InputBufferLength;
      BOOLEAN extended;

      InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;

      if (InputBufferLength < sizeof(UCHAR)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      Information = 0;
      pSysBuf = (PUCHAR)pIrp->AssociatedIrp.SystemBuffer;
      escapeChar = *pSysBuf;

      if (InputBufferLength >= (sizeof(UCHAR) + C0CE_SIGNATURE_SIZE + sizeof(ULONG)) &&
          RtlEqualMemory(pSysBuf + 1, C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE))
      {
        extended = TRUE;
        optsAndBits = *(ULONG *)(pSysBuf + 1 + C0CE_SIGNATURE_SIZE);

        #define C0CE_INSERT_OPTS ( \
            C0CE_INSERT_IOCTL_GET| \
            C0CE_INSERT_IOCTL_RXCLEAR)

        #define C0CE_INSERT_BITS ( \
            C0CE_INSERT_ENABLE_LSR| \
            C0CE_INSERT_ENABLE_MST| \
            C0CE_INSERT_ENABLE_RBR| \
            C0CE_INSERT_ENABLE_RLC| \
            C0CE_INSERT_ENABLE_LSR_BI)

        #define C0CE_INSERT_CAPS (C0CE_INSERT_OPTS|C0CE_INSERT_BITS)

        if (optsAndBits == C0CE_INSERT_IOCTL_CAPS) {
          optsAndBits = 0;

          Information += C0CE_SIGNATURE_SIZE + sizeof(ULONG);

          if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < Information) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
          }

          RtlCopyMemory(pSysBuf, C0CE_SIGNATURE, C0CE_SIGNATURE_SIZE);
          *(ULONG *)(pSysBuf + C0CE_SIGNATURE_SIZE) = C0CE_INSERT_CAPS;
        } else {
          if (optsAndBits & ~C0CE_INSERT_CAPS) {
            status = STATUS_INVALID_PARAMETER;
            break;
          }

          if (optsAndBits & C0CE_INSERT_IOCTL_GET) {
            if (optsAndBits & (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_LSR_BI))
              Information += sizeof(UCHAR)*2 + sizeof(UCHAR);
            if (optsAndBits & C0CE_INSERT_ENABLE_MST)
              Information += sizeof(UCHAR)*2 + sizeof(UCHAR);
            if (optsAndBits & C0CE_INSERT_ENABLE_RBR)
              Information += sizeof(UCHAR)*2 + sizeof(ULONG);
            if (optsAndBits & C0CE_INSERT_ENABLE_RLC)
              Information += sizeof(UCHAR)*2 + sizeof(UCHAR)*3;
          }

          if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < Information) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
          }
        }
      } else {
        extended = FALSE;
        optsAndBits = (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_MST);
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      if (escapeChar && ((escapeChar == pIoPortLocal->specialChars.XoffChar) ||
                         (escapeChar == pIoPortLocal->specialChars.XonChar) ||
                         (pIoPortLocal->handFlow.FlowReplace & SERIAL_ERROR_CHAR)))
      {
        status = STATUS_INVALID_PARAMETER;
        KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
        break;
      }

      pIoPortLocal->insertMask = optsAndBits & C0CE_INSERT_BITS;
      pIoPortLocal->escapeChar = escapeChar;

      if (extended) {
        LIST_ENTRY queueToComplete;
        PC0C_IO_PORT pIoPortRemote;

        InitializeListHead(&queueToComplete);
        pIoPortRemote = pIoPortLocal->pIoPortRemote;

        if (optsAndBits & C0CE_INSERT_IOCTL_GET) {
          if (optsAndBits & (C0CE_INSERT_ENABLE_LSR|C0CE_INSERT_ENABLE_LSR_BI)) {
            UCHAR lsr = 0;

            if (C0C_TX_BUFFER_THR_EMPTY(&pIoPortLocal->txBuf)) {
              lsr |= 0x20;  /* transmit holding register empty */

              if (C0C_TX_BUFFER_EMPTY(&pIoPortLocal->txBuf))
                lsr |= 0x40;  /* transmit holding register empty and line is idle */
            }

            if ((optsAndBits & C0CE_INSERT_ENABLE_LSR_BI) != 0 && pIoPortLocal->rcvdBreak)
              lsr |= 0x10;  /* break interrupt indicator */

            *pSysBuf++ = escapeChar;
            *pSysBuf++ = SERIAL_LSRMST_LSR_NODATA;
            *pSysBuf++ = lsr;
          }

          if (optsAndBits & C0CE_INSERT_ENABLE_MST) {
            *pSysBuf++ = escapeChar;
            *pSysBuf++ = SERIAL_LSRMST_MST;
            *pSysBuf++ = pIoPortLocal->modemStatus;
          }

          if (optsAndBits & C0CE_INSERT_ENABLE_RBR) {
            *pSysBuf++ = escapeChar;
            *pSysBuf++ = C0CE_INSERT_RBR;
            *(ULONG *)pSysBuf = pIoPortRemote->baudRate.BaudRate;
            pSysBuf += sizeof(ULONG);
          }

          if (optsAndBits & C0CE_INSERT_ENABLE_RLC) {
            *pSysBuf++ = escapeChar;
            *pSysBuf++ = C0CE_INSERT_RLC;
            *pSysBuf++ = pIoPortRemote->lineControl.WordLength;
            *pSysBuf++ = pIoPortRemote->lineControl.Parity;
            *pSysBuf++ = pIoPortRemote->lineControl.StopBits;
          }
        }

        pIrp->IoStatus.Information = Information;

        if (optsAndBits & C0CE_INSERT_IOCTL_RXCLEAR) {
          PurgeBuffer(&pIoPortLocal->readBuf);
          UpdateHandFlow(pIoPortLocal, TRUE, &queueToComplete);
          if (pIoPortLocal->tryWrite || pIoPortRemote->tryWrite) {
            ReadWrite(
                pIoPortLocal, FALSE,
                pIoPortRemote, FALSE,
                &queueToComplete);
          }
        }

        KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
        FdoPortCompleteQueue(&queueToComplete);

        TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
        break;
      }

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      break;
    }
    case IOCTL_SERIAL_SET_LINE_CONTROL: {
      PSERIAL_LINE_CONTROL pLineControl;

      if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_LINE_CONTROL)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pLineControl = (PSERIAL_LINE_CONTROL)pIrp->AssociatedIrp.SystemBuffer;

      switch (pLineControl->WordLength) {
        case 5:
        case 6:
        case 7:
        case 8:
          break;
        default:
          status = STATUS_INVALID_PARAMETER;
      }

      switch (pLineControl->Parity) {
        case NO_PARITY:
        case ODD_PARITY:
        case EVEN_PARITY:
        case MARK_PARITY:
        case SPACE_PARITY:
          break;
        default:
          status = STATUS_INVALID_PARAMETER;
      }

      switch (pLineControl->StopBits) {
        case STOP_BIT_1:
        case STOP_BITS_1_5:
        case STOP_BITS_2:
          break;
        default:
          status = STATUS_INVALID_PARAMETER;
      }

      if (status == STATUS_INVALID_PARAMETER)
        break;

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      if (pIoPortLocal->lineControl.StopBits != pLineControl->StopBits ||
          pIoPortLocal->lineControl.Parity != pLineControl->Parity ||
          pIoPortLocal->lineControl.WordLength != pLineControl->WordLength)
      {
        PC0C_IO_PORT pIoPortRemote;

        pIoPortLocal->lineControl = *pLineControl;
        SetWriteDelay(pIoPortLocal);

        pIoPortRemote = pIoPortLocal->pIoPortRemote;

        if (pIoPortRemote->escapeChar && (pIoPortRemote->insertMask & C0CE_INSERT_ENABLE_RLC)) {
          LIST_ENTRY queueToComplete;

          InitializeListHead(&queueToComplete);

          InsertRemoteLc(pIoPortRemote, &queueToComplete);

          if (pIoPortLocal->pIoPortRemote->tryWrite || pIoPortLocal->tryWrite) {
            ReadWrite(
                pIoPortLocal, FALSE,
                pIoPortLocal->pIoPortRemote, FALSE,
                &queueToComplete);
          }

          KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
          FdoPortCompleteQueue(&queueToComplete);
          break;
        }
      }
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      break;
    }
    case IOCTL_SERIAL_GET_LINE_CONTROL:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_LINE_CONTROL)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      *(PSERIAL_LINE_CONTROL)pIrp->AssociatedIrp.SystemBuffer = pIoPortLocal->lineControl;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      pIrp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_SET_BAUD_RATE: {
      PSERIAL_BAUD_RATE pBaudRate;

      if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_BAUD_RATE)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pBaudRate = (PSERIAL_BAUD_RATE)pIrp->AssociatedIrp.SystemBuffer;

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      if (pIoPortLocal->baudRate.BaudRate != pBaudRate->BaudRate) {
        PC0C_IO_PORT pIoPortRemote;

        pIoPortLocal->baudRate = *pBaudRate;
        SetWriteDelay(pIoPortLocal);

        pIoPortRemote = pIoPortLocal->pIoPortRemote;

        if (pIoPortRemote->escapeChar && (pIoPortRemote->insertMask & C0CE_INSERT_ENABLE_RBR)) {
          LIST_ENTRY queueToComplete;

          InitializeListHead(&queueToComplete);

          InsertRemoteBr(pIoPortRemote, &queueToComplete);

          if (pIoPortLocal->pIoPortRemote->tryWrite || pIoPortLocal->tryWrite) {
            ReadWrite(
                pIoPortLocal, FALSE,
                pIoPortLocal->pIoPortRemote, FALSE,
                &queueToComplete);
          }

          KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
          FdoPortCompleteQueue(&queueToComplete);
          break;
        }
      }
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      break;
    }
    case IOCTL_SERIAL_GET_BAUD_RATE:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIAL_BAUD_RATE)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      *(PSERIAL_BAUD_RATE)pIrp->AssociatedIrp.SystemBuffer = pIoPortLocal->baudRate;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      pIrp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_GET_PROPERTIES: {
      ULONG size;

      status = GetCommProp(pDevExt,
                           pIrp->AssociatedIrp.SystemBuffer,
                           pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
                           &size);

      if (status == STATUS_SUCCESS) {
        pIrp->IoStatus.Information = size;
        TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      }

      break;
    }
    case IOCTL_SERIAL_CONFIG_SIZE:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }
      pIrp->IoStatus.Information = sizeof(ULONG);
      *(PULONG)pIrp->AssociatedIrp.SystemBuffer = 0;
      break;
    case IOCTL_SERIAL_SET_QUEUE_SIZE: {
      PSERIAL_QUEUE_SIZE pSysBuf = (PSERIAL_QUEUE_SIZE)pIrp->AssociatedIrp.SystemBuffer;
      LIST_ENTRY queueToComplete;
      PC0C_BUFFER pReadBuf;
      PUCHAR pBase;

      if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_QUEUE_SIZE)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      pReadBuf = &pIoPortLocal->readBuf;

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      if (pSysBuf->InSize <= C0C_BUFFER_SIZE(pReadBuf)) {
        KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
        break;
      }
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);

      try {
        pBase = C0C_ALLOCATE_POOL_WITH_QUOTA(NonPagedPool, pSysBuf->InSize);
      } except (EXCEPTION_EXECUTE_HANDLER) {
        pBase = NULL;
        status = GetExceptionCode();
      }

      if (!pBase)
        break;

      InitializeListHead(&queueToComplete);
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);

      if (SetNewBufferBase(pReadBuf, pBase, pSysBuf->InSize)) {
        pIoPortLocal->handFlow.XoffLimit = pSysBuf->InSize >> 3;
        pIoPortLocal->handFlow.XonLimit = pSysBuf->InSize >> 1;
        SetLimit(pIoPortLocal);
        UpdateHandFlow(pIoPortLocal, TRUE, &queueToComplete);
        if (pIoPortLocal->tryWrite || pIoPortLocal->pIoPortRemote->tryWrite) {
          ReadWrite(
              pIoPortLocal, FALSE,
              pIoPortLocal->pIoPortRemote, FALSE,
              &queueToComplete);
        }
      }

      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      FdoPortCompleteQueue(&queueToComplete);
      break;
    }
    case IOCTL_SERIAL_GET_STATS:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(SERIALPERF_STATS)) {
        status = STATUS_BUFFER_TOO_SMALL;
        break;
      }

      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      *(PSERIALPERF_STATS)pIrp->AssociatedIrp.SystemBuffer = pIoPortLocal->perfStats;
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      pIrp->IoStatus.Information = sizeof(SERIALPERF_STATS);

      TraceIrp("FdoPortIoCtl", pIrp, &status, TRACE_FLAG_RESULTS);
      break;
    case IOCTL_SERIAL_CLEAR_STATS:
      KeAcquireSpinLock(pIoPortLocal->pIoLock, &oldIrql);
      RtlZeroMemory(&pIoPortLocal->perfStats, sizeof(pIoPortLocal->perfStats));
      KeReleaseSpinLock(pIoPortLocal->pIoLock, oldIrql);
      break;
    default:
      status = STATUS_INVALID_PARAMETER;
    }
  }

  if (status != STATUS_PENDING) {
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}

NTSTATUS c0cIoControl(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

#if ENABLE_TRACING
  ULONG code = IoGetCurrentIrpStackLocation(pIrp)->Parameters.DeviceIoControl.IoControlCode;
#endif /* ENABLE_TRACING */

  TraceIrp("c0cIoControl", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    status = FdoPortIoCtl((PC0C_FDOPORT_EXTENSION)pDevExt, pIrp);
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

#if ENABLE_TRACING
  if (status != STATUS_SUCCESS)
    TraceCode(pDevExt, "IOCTL_", codeNameTableIoctl, code, &status);
#endif /* ENABLE_TRACING */

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/trace.h

/*
 * $Id: trace.h,v 1.14 2009/05/22 14:25:39 vfrolov Exp $
 *
 * Copyright (c) 2004-2009 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: trace.h,v $
 * Revision 1.14  2009/05/22 14:25:39  vfrolov
 * Optimized for trace disabled mode
 *
 * Revision 1.13  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.12  2008/05/04 09:51:45  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.11  2007/02/21 16:52:34  vfrolov
 * Added tracing of IRP_MJ_POWER with more details
 *
 * Revision 1.10  2006/08/23 12:56:20  vfrolov
 * Added codeNameTableWmi
 *
 * Revision 1.9  2006/05/19 15:02:03  vfrolov
 * Implemented IOCTL_SERIAL_GET_MODEM_CONTROL
 *
 * Revision 1.8  2006/01/10 09:32:20  vfrolov
 * Added codeNameTableHoldReasons[]
 *
 * Revision 1.7  2005/12/06 13:01:54  vfrolov
 * Implemented IOCTL_SERIAL_GET_DTRRTS
 *
 * Revision 1.6  2005/09/28 10:06:42  vfrolov
 * Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION
 *
 * Revision 1.5  2005/09/13 08:55:41  vfrolov
 * Disabled modem status tracing by default
 *
 * Revision 1.4  2005/09/06 06:49:39  vfrolov
 * Added codeNameTableErrors[]
 *
 * Revision 1.3  2005/08/25 07:48:39  vfrolov
 * Changed type of code names from wchar to char
 * Fixed HandFlow tracing
 *
 * Revision 1.2  2005/07/14 12:18:59  vfrolov
 * Defined HALT_UNLESS
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#ifndef _TRACE_H_
#define _TRACE_H_

#if ENABLE_TRACING

#define TRACE_FLAG_PARAMS         0x0001
#define TRACE_FLAG_RESULTS        0x0002

typedef struct _CODE2NAME {
  ULONG code;
  PCHAR name;
} CODE2NAME, *PCODE2NAME;

typedef struct _FIELD2NAME {
  ULONG code;
  ULONG mask;
  PCHAR name;
} FIELD2NAME, *PFIELD2NAME;

extern struct _TRACE_DATA *pTraceData;
#define TRACE_FILE_OK (pTraceData != NULL)

VOID TraceOpen(
    IN PDRIVER_OBJECT _pDrvObj,
    IN PUNICODE_STRING pRegistryPath);

VOID TraceClose();

VOID InternalTrace0(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PWCHAR pStr);

VOID InternalTrace00(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PWCHAR pStr1,
    IN PWCHAR pStr2);

VOID InternalTraceCode(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PCHAR pHead,
    IN PCODE2NAME pTable,
    IN ULONG code,
    IN PNTSTATUS pStatus);

VOID InternalTraceMask(
    IN PC0C_COMMON_EXTENSION pDevExt,
    IN PCHAR pHead,
    IN PCODE2NAME pTable,
    IN ULONG mask);

VOID InternalTraceModemStatus(IN PC0C_IO_PORT pIoPort);

VOID InternalTraceIrp(
    IN PCHAR pHead,
    IN PIRP pIrp,
    IN PNTSTATUS pStatus,
    IN ULONG flags);

#define Trace0(a1, a2)                 if (TRACE_FILE_OK) InternalTrace0(a1, a2); else
#define Trace00(a1, a2, a3)            if (TRACE_FILE_OK) InternalTrace00(a1, a2, a3); else
#define TraceCode(a1, a2, a3, a4, a5)  if (TRACE_FILE_OK) InternalTraceCode(a1, a2, a3, a4, a5); else
#define TraceMask(a1, a2, a3, a4)      if (TRACE_FILE_OK) InternalTraceMask(a1, a2, a3, a4); else
#define TraceModemStatus(a1)           if (TRACE_FILE_OK) InternalTraceModemStatus(a1); else
#define TraceIrp(a1, a2, a3, a4)       if (TRACE_FILE_OK) InternalTraceIrp(a1, a2, a3, a4); else

CODE2NAME codeNameTableWaitMask[];
CODE2NAME codeNameTablePurgeMask[];
CODE2NAME codeNameTableIoctl[];
CODE2NAME codeNameTablePnp[];
CODE2NAME codeNameTablePower[];
CODE2NAME codeNameTablePowerType[];
CODE2NAME codeNameTableSystemPowerState[];
CODE2NAME codeNameTableDevicePowerState[];
CODE2NAME codeNameTablePowerAction[];
CODE2NAME codeNameTableWmi[];
CODE2NAME codeNameTableDoType[];
CODE2NAME codeNameTableModemStatus[];
CODE2NAME codeNameTableModemControl[];
CODE2NAME codeNameTableStatus[];
CODE2NAME codeNameTableIrpMj[];
CODE2NAME codeNameTableRelations[];
CODE2NAME codeNameTableBusQuery[];
CODE2NAME codeNameTableDeviceText[];
CODE2NAME codeNameTableErrors[];
CODE2NAME codeNameTableHoldReasons[];
CODE2NAME codeNameTableFileInformationClass[];
CODE2NAME codeNameTableShowPort[];

FIELD2NAME codeNameTableControlHandShake[];
FIELD2NAME codeNameTableFlowReplace[];

#else /* ENABLE_TRACING */

#define TraceOpen(a1, a2)
#define TraceClose()
#define Trace0(a1, a2)
#define Trace00(a1, a2, a3)
#define TraceCode(a1, a2, a3, a4, a5)
#define TraceMask(a1, a2, a3, a4)
#define TraceModemStatus(a1)
#define TraceIrp(a1, a2, a3, a4)

#endif /* ENABLE_TRACING */

#endif /* _TRACE_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/com0com.rc

/*
 * $Id: com0com.rc,v 1.8 2006/01/10 09:24:31 vfrolov Exp $
 *
 * Copyright (c) 2004-2006 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: com0com.rc,v $
 * Revision 1.8  2006/01/10 09:24:31  vfrolov
 * Utilized C0C_COPYRIGHT_YEARS
 *
 * Revision 1.7  2005/09/05 16:05:03  vfrolov
 * Moved version info to version.h
 *
 * Revision 1.2  2005/02/01 09:09:28  vfrolov
 * Added version info
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include <windows.h>
#include <ntverp.h>
#include "c0clog.rc"
#include "version.h"

#define VER_VERSION             C0C_V1,C0C_V2,C0C_V3,C0C_V4
#define VER_VERSION_STR         C0C_VERSION_STR

#define VER_PODUCT_NAME_STR     "Null-modem emulator"

#if DBG
#define VER_DEBUG_STR           " (debug version)"
#else
#define VER_DEBUG_STR           ""
#endif

VS_VERSION_INFO VERSIONINFO
  FILEVERSION     VER_VERSION
  PRODUCTVERSION  VER_VERSION
  FILEFLAGSMASK   VER_FILEFLAGSMASK
  FILEFLAGS       VER_FILEFLAGS
  FILEOS          VER_FILEOS
  FILETYPE        VFT_DRV
  FILESUBTYPE     VFT2_DRV_COMM
{
  BLOCK "StringFileInfo" {
    BLOCK "040904B0" {
      VALUE "CompanyName",      "Vyacheslav Frolov\0"
      VALUE "FileDescription",  VER_PODUCT_NAME_STR VER_DEBUG_STR
      VALUE "FileVersion",      VER_VERSION_STR
      VALUE "InternalName",     "com0com\0"
      VALUE "LegalCopyright",   "Copyright (c) " C0C_COPYRIGHT_YEARS " Vyacheslav Frolov\0"
      VALUE "OriginalFilename", "com0com.sys\0"
      VALUE "ProductName",      VER_PODUCT_NAME_STR
      VALUE "ProductVersion",   VER_VERSION_STR
    }
  }

  BLOCK "VarFileInfo" {
    VALUE "Translation", 0x409, 0x4B0
  }
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/adddev.c

/*
 * $Id: adddev.c,v 1.40 2011/12/15 06:17:12 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: adddev.c,v $
 * Revision 1.40  2011/12/15 06:17:12  vfrolov
 * Removed usage undocumented PDRIVER_OBJECT->Type
 *
 * Revision 1.39  2011/12/06 16:03:22  vfrolov
 * Added cleaning high data bits for less then 8 bit data
 * Added AllDataBits option to force 8 bit data
 *
 * Revision 1.38  2010/08/09 06:02:40  vfrolov
 * Eliminated accessing undocumented structure members
 *
 * Revision 1.37  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.36  2008/12/02 16:10:08  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.35  2008/09/17 07:58:32  vfrolov
 * Added AddRTTO and AddRITO parameters
 *
 * Revision 1.34  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.33  2008/05/04 09:51:44  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.32  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.31  2007/10/19 16:03:41  vfrolov
 * Added default values
 *
 * Revision 1.30  2007/09/26 10:12:13  vfrolov
 * Added checks of DeviceExtension for zero
 *
 * Revision 1.29  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.28  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.27  2007/06/05 12:15:08  vfrolov
 * Fixed memory leak
 *
 * Revision 1.26  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.25  2007/06/01 08:36:26  vfrolov
 * Changed parameter type for SetWriteDelay()
 *
 * Revision 1.24  2007/01/11 14:50:28  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.23  2006/11/23 11:10:10  vfrolov
 * Strict usage fixed port numbers
 *
 * Revision 1.22  2006/11/03 13:13:26  vfrolov
 * CopyStrW() now gets size in characters (not in bytes)
 *
 * Revision 1.21  2006/11/02 16:04:50  vfrolov
 * Added using fixed port numbers
 *
 * Revision 1.20  2006/10/16 08:30:45  vfrolov
 * Added the device interface registration
 *
 * Revision 1.19  2006/10/13 10:22:22  vfrolov
 * Changed name of device object (for WMI)
 *
 * Revision 1.18  2006/10/10 15:18:15  vfrolov
 * Added PortName value setting for WMI
 *
 * Revision 1.17  2006/08/23 13:48:12  vfrolov
 * Implemented WMI functionality
 *
 * Revision 1.16  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.15  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.14  2006/03/29 09:39:28  vfrolov
 * Fixed possible usage uninitialized portName
 *
 * Revision 1.13  2006/03/27 09:38:23  vfrolov
 * Utilized StrAppendDeviceProperty()
 *
 * Revision 1.12  2006/02/26 08:35:55  vfrolov
 * Added check for start/stop queue matching
 *
 * Revision 1.11  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.10  2005/09/27 16:41:01  vfrolov
 * Fixed DeviceType
 *
 * Revision 1.9  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.8  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.7  2005/08/16 16:36:33  vfrolov
 * Hidden timeout functions
 *
 * Revision 1.6  2005/07/14 13:51:08  vfrolov
 * Replaced ASSERT by HALT_UNLESS
 *
 * Revision 1.5  2005/07/13 16:12:36  vfrolov
 * Added c0cGlobal struct for global driver's data
 *
 * Revision 1.4  2005/06/28 12:17:12  vfrolov
 * Added pBusExt to C0C_PDOPORT_EXTENSION
 *
 * Revision 1.3  2005/05/20 12:06:05  vfrolov
 * Improved port numbering
 *
 * Revision 1.2  2005/05/12 07:41:27  vfrolov
 * Added ability to change the port names
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include <initguid.h>
#include <ntddser.h>
#include "timeout.h"
#include "delay.h"
#include "bufutils.h"
#include "strutils.h"
#include "showport.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 6

/********************************************************************/
NTSTATUS InitCommonExt(
    PC0C_COMMON_EXTENSION pDevExt,
    IN PDEVICE_OBJECT pDevObj,
    short doType,
    PWCHAR pPortName)
{
  pDevExt->pDevObj = pDevObj;
  pDevExt->doType = doType;
  return CopyStrW(pDevExt->portName, sizeof(pDevExt->portName)/sizeof(pDevExt->portName[0]), pPortName);
}
/********************************************************************/
VOID RemoveFdoPort(IN PC0C_FDOPORT_EXTENSION pDevExt)
{
  if (pDevExt->pIoPortLocal) {
    FreeTimeouts(pDevExt->pIoPortLocal);
    FreeWriteDelay(pDevExt->pIoPortLocal);
    pDevExt->pIoPortLocal->plugInMode = FALSE;
    pDevExt->pIoPortLocal->exclusiveMode = FALSE;
    pDevExt->pIoPortLocal->pDevExt = NULL;
    FreeTxBuffer(&pDevExt->pIoPortLocal->txBuf);
    pDevExt->pIoPortLocal->brokeChars = 0;  /* reset on idle */
  }

  if (!HidePort(pDevExt))
    SysLogDev(pDevExt->pDevObj, STATUS_UNSUCCESSFUL, L"RemoveFdoPort HidePort FAIL");

  if (pDevExt->symbolicLinkName.Buffer)
    RtlFreeUnicodeString(&pDevExt->symbolicLinkName);

  StrFree(&pDevExt->ntDeviceName);
  StrFree(&pDevExt->win32DeviceName);

  if (pDevExt->pLowDevObj)
    IoDetachDevice(pDevExt->pLowDevObj);

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemoveFdoPort");

  IoDeleteDevice(pDevExt->pDevObj);
}

NTSTATUS AddFdoPort(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
{
  NTSTATUS status;
  UNICODE_STRING portName;
  PDEVICE_OBJECT pNewDevObj;
  PC0C_FDOPORT_EXTENSION pDevExt;
  PC0C_PDOPORT_EXTENSION pPhDevExt;
  ULONG emuBR, emuOverrun, plugInMode, exclusiveMode, hiddenMode, allDataBits;
  ULONG brokeCharsProbability;
  ULONG addRTTO, addRITO;
  ULONG pinCTS, pinDSR, pinDCD, pinRI;
  UNICODE_STRING ntDeviceName;
  PWCHAR pPhPortName;

  status = STATUS_SUCCESS;
  pDevExt = NULL;
  RtlInitUnicodeString(&portName, NULL);
  RtlInitUnicodeString(&ntDeviceName, NULL);

  StrAppendDeviceProperty(&status, &ntDeviceName, pPhDevObj, DevicePropertyPhysicalDeviceObjectName);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoGetDeviceProperty FAIL");
    goto clean;
  }

  pPhDevExt = (PC0C_PDOPORT_EXTENSION)pPhDevObj->DeviceExtension;

  if (!pPhDevExt || pPhDevExt->doType != C0C_DOTYPE_PP) {
    status = STATUS_UNSUCCESSFUL;
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL. Type  of PDO is not PP");
    goto clean;
  }

  Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"AddFdoPort for ", ntDeviceName.Buffer);

  pPhPortName = pPhDevExt->portName;

  if (!*pPhPortName) {
    status = STATUS_UNSUCCESSFUL;
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL. The PDO has invalid port name");
    goto clean;
  }

  {
    UNICODE_STRING portRegistryPath;

    RtlInitUnicodeString(&portRegistryPath, NULL);
    StrAppendPortParametersRegistryPath(&status, &portRegistryPath, pPhPortName);

    if (!NT_SUCCESS(status)) {
    }
    else
    if (pPhDevExt->pIoPortLocal->isComClass) {
      HANDLE hKey;

      status = IoOpenDeviceRegistryKey(pPhDevObj,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_READ,
                                       &hKey);

      if (NT_SUCCESS(status)) {
        UNICODE_STRING keyName;
        PKEY_VALUE_FULL_INFORMATION pInfo;
        ULONG len;

        RtlInitUnicodeString(&keyName, L"PortName");

        len = sizeof(*pInfo) + sizeof(L"PortName") + (C0C_PORT_NAME_LEN + 1) * sizeof(WCHAR);

        pInfo = C0C_ALLOCATE_POOL(PagedPool, len);

        if (pInfo) {
          status = ZwQueryValueKey(hKey, &keyName, KeyValueFullInformation, pInfo, len, &len);

          if (NT_SUCCESS(status) && pInfo->DataLength <= ((C0C_PORT_NAME_LEN + 1) * sizeof(WCHAR))) {
            StrAppendStr(
                &status,
                &portName,
                (PWCHAR)(((PUCHAR)pInfo) + pInfo->DataOffset),
                (USHORT)(pInfo->DataLength - sizeof(WCHAR)));
          }

          C0C_FREE_POOL(pInfo);
        }

        ZwClose(hKey);
      }

      if (!portName.Length) {
        Trace0((PC0C_COMMON_EXTENSION)pPhDevExt, L"WARNING: Can't get PortName from COM class device node");
        status = STATUS_SUCCESS;
        StrAppendStr0(&status, &portName, pPhPortName);
      } else {
        Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"PortName set to ", portName.Buffer);
      }
    }
    else {
      StrAppendParameterPortName(&status, &portName, portRegistryPath.Buffer);

      if (NT_SUCCESS(status) && portName.Length) {
        Trace00((PC0C_COMMON_EXTENSION)pPhDevExt, L"PortName set to ", portName.Buffer);
      } else {
        status = STATUS_SUCCESS;
        StrAppendStr0(&status, &portName, pPhPortName);
      }
    }

    emuBR = C0C_DEFAULT_EMUBR;
    emuOverrun = C0C_DEFAULT_EMUOVERRUN;
    plugInMode = C0C_DEFAULT_PLUGINMODE;
    exclusiveMode = C0C_DEFAULT_EXCLUSIVEMODE;
    hiddenMode = C0C_DEFAULT_HIDDENMODE;
    allDataBits = C0C_DEFAULT_ALLDATABITS;
    pinCTS = C0C_DEFAULT_PIN_CTS;
    pinDSR = C0C_DEFAULT_PIN_DSR;
    pinDCD = C0C_DEFAULT_PIN_DCD;
    pinRI = C0C_DEFAULT_PIN_RI;
    brokeCharsProbability = C0C_DEFAULT_EMUNOISE;
    addRTTO = C0C_DEFAULT_ADDRTTO;
    addRITO = C0C_DEFAULT_ADDRITO;

    if (NT_SUCCESS(status)) {
      RTL_QUERY_REGISTRY_TABLE queryTable[14];
      int i;

      RtlZeroMemory(queryTable, sizeof(queryTable));

      for (i = 0 ; i < (sizeof(queryTable)/sizeof(queryTable[0]) - 1) ; i++) {
        queryTable[i].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[i].DefaultType   = REG_DWORD;
        queryTable[i].DefaultLength = sizeof(ULONG);
      }

      i = 0;
      queryTable[i].Name          = L"EmuBR";
      queryTable[i].EntryContext  = &emuBR;
      queryTable[i].DefaultData   = &emuBR;

      i++;
      queryTable[i].Name          = L"EmuOverrun";
      queryTable[i].EntryContext  = &emuOverrun;
      queryTable[i].DefaultData   = &emuOverrun;

      i++;
      queryTable[i].Name          = L"PlugInMode";
      queryTable[i].EntryContext  = &plugInMode;
      queryTable[i].DefaultData   = &plugInMode;

      i++;
      queryTable[i].Name          = L"ExclusiveMode";
      queryTable[i].EntryContext  = &exclusiveMode;
      queryTable[i].DefaultData   = &exclusiveMode;

      i++;
      queryTable[i].Name          = L"HiddenMode";
      queryTable[i].EntryContext  = &hiddenMode;
      queryTable[i].DefaultData   = &hiddenMode;

      i++;
      queryTable[i].Name          = L"AllDataBits";
      queryTable[i].EntryContext  = &allDataBits;
      queryTable[i].DefaultData   = &allDataBits;

      i++;
      queryTable[i].Name          = L"cts";
      queryTable[i].EntryContext  = &pinCTS;
      queryTable[i].DefaultData   = &pinCTS;

      i++;
      queryTable[i].Name          = L"dsr";
      queryTable[i].EntryContext  = &pinDSR;
      queryTable[i].DefaultData   = &pinDSR;

      i++;
      queryTable[i].Name          = L"dcd";
      queryTable[i].EntryContext  = &pinDCD;
      queryTable[i].DefaultData   = &pinDCD;

      i++;
      queryTable[i].Name          = L"ri";
      queryTable[i].EntryContext  = &pinRI;
      queryTable[i].DefaultData   = &pinRI;

      i++;
      queryTable[i].Name          = L"EmuNoise";
      queryTable[i].EntryContext  = &brokeCharsProbability;
      queryTable[i].DefaultData   = &brokeCharsProbability;

      i++;
      queryTable[i].Name          = L"AddRTTO";
      queryTable[i].EntryContext  = &addRTTO;
      queryTable[i].DefaultData   = &addRTTO;

      i++;
      queryTable[i].Name          = L"AddRITO";
      queryTable[i].EntryContext  = &addRITO;
      queryTable[i].DefaultData   = &addRITO;

      RtlQueryRegistryValues(
          RTL_REGISTRY_ABSOLUTE,
          portRegistryPath.Buffer,
          queryTable,
          NULL,
          NULL);
    }

    StrFree(&portRegistryPath);
  }

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL");
    goto clean;
  }

  status = IoCreateDevice(pDrvObj,
                          sizeof(*pDevExt),
                          NULL,
                          FILE_DEVICE_SERIAL_PORT,
                          FILE_DEVICE_SECURE_OPEN,
                          TRUE,
                          &pNewDevObj);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoCreateDevice FAIL");
    goto clean;
  }

  HALT_UNLESS(pNewDevObj);
  pDevExt = pNewDevObj->DeviceExtension;
  HALT_UNLESS(pDevExt);
  RtlZeroMemory(pDevExt, sizeof(*pDevExt));
  pDevExt->pIoPortLocal = pPhDevExt->pIoPortLocal;
  status = InitCommonExt((PC0C_COMMON_EXTENSION)pDevExt, pNewDevObj, C0C_DOTYPE_FP, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort FAIL");
    goto clean;
  }

  pDevExt->pIoPortLocal->pDevExt = pDevExt;

  if (emuBR) {
    if (NT_SUCCESS(AllocWriteDelay(pDevExt->pIoPortLocal)))
      Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled baudrate emulation");
    else
      SysLogDev(pPhDevObj, status, L"AddFdoPort AllocWriteDelay FAIL");
  } else {
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled baudrate emulation");
  }

  if (emuOverrun) {
    pDevExt->pIoPortLocal->emuOverrun = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled overrun emulation");
  } else {
    pDevExt->pIoPortLocal->emuOverrun = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled overrun emulation");
  }

  if (plugInMode) {
    pDevExt->pIoPortLocal->plugInMode = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled plug-in mode");
  } else {
    pDevExt->pIoPortLocal->plugInMode = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled plug-in mode");
  }

  if (exclusiveMode) {
    pDevExt->pIoPortLocal->exclusiveMode = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled exclusive mode");
  } else {
    pDevExt->pIoPortLocal->exclusiveMode = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled exclusive mode");
  }

  if (allDataBits) {
    pDevExt->pIoPortLocal->allDataBits = TRUE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled all data bits");
  } else {
    pDevExt->pIoPortLocal->allDataBits = FALSE;
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled all data bits");
  }

  SetHiddenMode(pDevExt, hiddenMode);

  pDevExt->pIoPortLocal->addRTTO = addRTTO;

#if ENABLE_TRACING
  if (addRTTO)
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled ReadTotalTimeoutConstant increase");
#endif /* ENABLE_TRACING */

  pDevExt->pIoPortLocal->addRITO = addRITO;

#if ENABLE_TRACING
  if (addRITO)
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled ReadIntervalTimeout increase");
#endif /* ENABLE_TRACING */

  AllocTimeouts(pDevExt->pIoPortLocal);

  RtlZeroMemory(&pDevExt->pIoPortLocal->specialChars, sizeof(pDevExt->pIoPortLocal->specialChars));
  pDevExt->pIoPortLocal->specialChars.XonChar      = 0x11;
  pDevExt->pIoPortLocal->specialChars.XoffChar     = 0x13;

  RtlZeroMemory(&pDevExt->pIoPortLocal->handFlow, sizeof(pDevExt->pIoPortLocal->handFlow));
  pDevExt->pIoPortLocal->handFlow.ControlHandShake = SERIAL_DTR_CONTROL;
  pDevExt->pIoPortLocal->handFlow.FlowReplace      = SERIAL_RTS_CONTROL;

  pDevExt->pIoPortLocal->lineControl.WordLength    = 7;
  pDevExt->pIoPortLocal->lineControl.Parity        = EVEN_PARITY;
  pDevExt->pIoPortLocal->lineControl.StopBits      = STOP_BIT_1;
  pDevExt->pIoPortLocal->baudRate.BaudRate         = 1200;

  SetWriteDelay(pDevExt->pIoPortLocal);

  SetTxBuffer(&pDevExt->pIoPortLocal->txBuf, 1, TRUE);

  pDevExt->pIoPortLocal->modemControl |= C0C_MCR_OUT2;

  PinMap(pDevExt->pIoPortLocal, pinCTS, pinDSR, pinDCD, pinRI);

  pDevExt->pIoPortLocal->brokeCharsProbability = brokeCharsProbability;

#if ENABLE_TRACING
  if (brokeCharsProbability)
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Enabled noise emulation");
  else
    Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"Disabled noise emulation");
#endif /* ENABLE_TRACING */

  pDevExt->pLowDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, pPhDevObj);

  if (!pDevExt->pLowDevObj) {
    status = STATUS_NO_SUCH_DEVICE;
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoAttachDeviceToDeviceStack FAIL");
    goto clean;
  }

  pNewDevObj->Flags &= ~DO_DEVICE_INITIALIZING;
  pNewDevObj->Flags |= DO_BUFFERED_IO;

  /* Create symbolic links to device */

  RtlInitUnicodeString(&pDevExt->ntDeviceName, NULL);
  StrAppendStr0(&status, &pDevExt->ntDeviceName, ntDeviceName.Buffer);

  RtlInitUnicodeString(&pDevExt->win32DeviceName, NULL);
  StrAppendStr0(&status, &pDevExt->win32DeviceName, C0C_PREF_WIN32_DEVICE_NAME);
  StrAppendStr0(&status, &pDevExt->win32DeviceName, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    StrFree(&pDevExt->win32DeviceName);
    StrFree(&pDevExt->ntDeviceName);

    SysLogDev(pPhDevObj, status, L"AddFdoPort StrAppendStr0 FAIL");
  }

  status = IoRegisterDeviceInterface(pPhDevObj,
                                     (LPGUID)&GUID_CLASS_COMPORT,
                                     NULL,
                                     &pDevExt->symbolicLinkName);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pPhDevObj, status, L"AddFdoPort IoRegisterDeviceInterface FAIL");
    pDevExt->symbolicLinkName.Buffer = NULL;
  }

  if (!pDevExt->pIoPortLocal->plugInMode || pDevExt->pIoPortLocal->pIoPortRemote->isOpen) {
    if (!ShowPort(pDevExt))
      SysLogDev(pDevExt->pDevObj, STATUS_UNSUCCESSFUL, L"AddFdoPort ShowPort FAIL");
  } else {
    HidePortName(pDevExt);
  }

  status = STATUS_SUCCESS;

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"AddFdoPort OK");

clean:

  if (!NT_SUCCESS(status) && pDevExt)
    RemoveFdoPort(pDevExt);

  StrFree(&ntDeviceName);
  StrFree(&portName);

  return status;
}
/********************************************************************/
VOID RemovePdoPort(IN PC0C_PDOPORT_EXTENSION pDevExt)
{
  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemovePdoPort");

  IoDeleteDevice(pDevExt->pDevObj);
}

NTSTATUS AddPdoPort(
    IN PDRIVER_OBJECT pDrvObj,
    IN ULONG num,
    IN BOOLEAN isA,
    IN PC0C_FDOBUS_EXTENSION pBusExt,
    IN PC0C_IO_PORT pIoPortLocal,
    OUT PC0C_PDOPORT_EXTENSION *ppDevExt)
{
  NTSTATUS status;
  UNICODE_STRING portName;
  PDEVICE_OBJECT pNewDevObj;
  UNICODE_STRING ntDeviceName;
  PC0C_PDOPORT_EXTENSION pDevExt = NULL;

  status = STATUS_SUCCESS;

  RtlInitUnicodeString(&portName, NULL);
  StrAppendStr0(&status, &portName, isA ? C0C_PREF_PORT_NAME_A : C0C_PREF_PORT_NAME_B);
  StrAppendNum(&status, &portName, num, 10);

  RtlInitUnicodeString(&ntDeviceName, NULL);
  StrAppendStr0(&status, &ntDeviceName, isA ? C0C_PREF_DEVICE_NAME_A : C0C_PREF_DEVICE_NAME_B);
  StrAppendNum(&status, &ntDeviceName, num, 10);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pBusExt->pDevObj, status, L"AddPdoPort FAIL");
    goto clean;
  }

  status = IoCreateDevice(pDrvObj,
                          sizeof(*pDevExt),
                          &ntDeviceName,
                          FILE_DEVICE_SERIAL_PORT,
                          FILE_DEVICE_SECURE_OPEN,
                          TRUE,
                          &pNewDevObj);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pBusExt->pDevObj, status, L"AddPdoPort IoCreateDevice FAIL");
    goto clean;
  }

  HALT_UNLESS(pNewDevObj);
  pIoPortLocal->pPhDevObj = pNewDevObj;
  pDevExt = (pNewDevObj)->DeviceExtension;
  HALT_UNLESS(pDevExt);
  RtlZeroMemory(pDevExt, sizeof(*pDevExt));
  status = InitCommonExt((PC0C_COMMON_EXTENSION)pDevExt, pNewDevObj, C0C_DOTYPE_PP, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    SysLogDev(pBusExt->pDevObj, status, L"AddPdoPort FAIL");
    goto clean;
  }

  pDevExt->pBusExt = pBusExt;
  pDevExt->pIoPortLocal = pIoPortLocal;

  Trace00((PC0C_COMMON_EXTENSION)pDevExt, L"AddPdoPort OK - ", ntDeviceName.Buffer);

clean:

  if (!NT_SUCCESS(status) && pDevExt) {
    RemovePdoPort(pDevExt);
    pDevExt = NULL;
  }

  StrFree(&ntDeviceName);
  StrFree(&portName);

  *ppDevExt = pDevExt;

  return status;
}
/********************************************************************/
ULONG ListFdoBusGetFreeNum()
{
  ULONG numNext;
  KIRQL oldIrql;
  PLIST_ENTRY Flink;

  numNext = 0;

  KeAcquireSpinLock(&c0cGlobal.listFdoBusLock, &oldIrql);

  for (Flink = c0cGlobal.listFdoBus.Flink ;; Flink = Flink->Flink) {
    ULONG num;

    if (Flink == &c0cGlobal.listFdoBus)
      break;

    num = CONTAINING_RECORD(Flink, C0C_FDOBUS_EXTENSION, listEntry)->portNum;

    if (numNext < num)
      break;

    numNext = num + 1;
  }

  KeReleaseSpinLock(&c0cGlobal.listFdoBusLock, oldIrql);

  return numNext;
}

VOID ListFdoBusInsert(PC0C_FDOBUS_EXTENSION pDevExt)
{
  KIRQL oldIrql;
  PLIST_ENTRY Flink;

  KeAcquireSpinLock(&c0cGlobal.listFdoBusLock, &oldIrql);

  for (Flink = c0cGlobal.listFdoBus.Flink ;; Flink = Flink->Flink) {
    if (Flink == &c0cGlobal.listFdoBus ||
        pDevExt->portNum <= CONTAINING_RECORD(Flink, C0C_FDOBUS_EXTENSION, listEntry)->portNum)
    {
      InsertHeadList(Flink, &pDevExt->listEntry);
      KeReleaseSpinLock(&c0cGlobal.listFdoBusLock, oldIrql);
      return;
    }
  }
}

VOID ListFdoBusRemove(PC0C_FDOBUS_EXTENSION pDevExt)
{
  KIRQL oldIrql;

  KeAcquireSpinLock(&c0cGlobal.listFdoBusLock, &oldIrql);

  RemoveEntryList(&pDevExt->listEntry);

  KeReleaseSpinLock(&c0cGlobal.listFdoBusLock, oldIrql);
}

VOID RemoveFdoBus(IN PC0C_FDOBUS_EXTENSION pDevExt)
{
  int i;

  for (i = 0 ; i < 2 ; i++) {
    if (pDevExt->childs[i].pDevExt)
      RemovePdoPort(pDevExt->childs[i].pDevExt);
  }

  if (pDevExt->pLowDevObj)
    IoDetachDevice(pDevExt->pLowDevObj);

  ListFdoBusRemove(pDevExt);

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"RemoveFdoBus");

  IoDeleteDevice(pDevExt->pDevObj);
}

ULONG GetPortNum(IN PDEVICE_OBJECT pPhDevObj)
{
  ULONG num;
  HANDLE hKey;
  NTSTATUS status;

  status = IoOpenDeviceRegistryKey(pPhDevObj,
                                   PLUGPLAY_REGKEY_DEVICE,
                                   STANDARD_RIGHTS_READ,
                                   &hKey);

  if (NT_SUCCESS(status)) {
    UNICODE_STRING keyName;
    PKEY_VALUE_PARTIAL_INFORMATION pInfo;
    ULONG len;

    RtlInitUnicodeString(&keyName, C0C_REGSTR_VAL_PORT_NUM);

    len = sizeof(*pInfo) + sizeof(ULONG);

    num = (ULONG)-1;

    pInfo = C0C_ALLOCATE_POOL(PagedPool, len);

    if (pInfo) {
      status = ZwQueryValueKey(hKey, &keyName, KeyValuePartialInformation, pInfo, len, &len);

      if (NT_SUCCESS(status) && pInfo->DataLength == sizeof(ULONG))
        num = *(PULONG)pInfo->Data;

      C0C_FREE_POOL(pInfo);
    }

    if (num == (ULONG)-1) {
      num = ListFdoBusGetFreeNum();

      status = ZwSetValueKey(hKey, &keyName, 0, REG_DWORD, &num, sizeof(num));

      if (!NT_SUCCESS(status))
        SysLogDev(pPhDevObj, status, L"ZwSetValueKey(PortName) FAIL");
    }

    ZwClose(hKey);
  } else {
    SysLogDev(pPhDevObj, status, L"GetPortNum IoOpenDeviceRegistryKey(PLUGPLAY_REGKEY_DEVICE) FAIL");

    num = ListFdoBusGetFreeNum();
  }

  return num;
}

NTSTATUS AddFdoBus(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
{
  NTSTATUS status = STATUS_SUCCESS;
  UNICODE_STRING portName;
  UNICODE_STRING ntDeviceName;
  PDEVICE_OBJECT pNewDevObj;
  PC0C_FDOBUS_EXTENSION pDevExt = NULL;
  ULONG num;
  int i;

  num = GetPortNum(pPhDevObj);

  RtlInitUnicodeString(&portName, NULL);
  StrAppendStr0(&status, &portName, C0C_PREF_BUS_NAME);
  StrAppendNum(&status, &portName, num, 10);

  RtlInitUnicodeString(&ntDeviceName, NULL);
  StrAppendStr0(&status, &ntDeviceName, C0C_PREF_NT_DEVICE_NAME);
  StrAppendStr(&status, &ntDeviceName, portName.Buffer, portName.Length);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"AddFdoBus FAIL");
    goto clean;
  }

  status = IoCreateDevice(pDrvObj,
                          sizeof(*pDevExt),
                          &ntDeviceName,
                          FILE_DEVICE_BUS_EXTENDER,
                          0,
                          TRUE,
                          &pNewDevObj);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"AddFdoBus IoCreateDevice FAIL");
    goto clean;
  }

  HALT_UNLESS(pNewDevObj);
  pDevExt = pNewDevObj->DeviceExtension;
  HALT_UNLESS(pDevExt);
  RtlZeroMemory(pDevExt, sizeof(*pDevExt));
  pDevExt->portNum = num;
  ListFdoBusInsert(pDevExt);
  status = InitCommonExt((PC0C_COMMON_EXTENSION)pDevExt, pNewDevObj, C0C_DOTYPE_FB, portName.Buffer);

  if (!NT_SUCCESS(status)) {
    SysLogDrv(pDrvObj, status, L"AddFdoBus InitCommonExt FAIL");
    goto clean;
  }

  pDevExt->pLowDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, pPhDevObj);

  if (!pDevExt->pLowDevObj) {
    status = STATUS_NO_SUCH_DEVICE;
    SysLogDev(pNewDevObj, status, L"AddFdoBus IoAttachDeviceToDeviceStack FAIL");
    goto clean;
  }

  pNewDevObj->Flags &= ~DO_DEVICE_INITIALIZING;
  KeInitializeSpinLock(&pDevExt->ioLock);

  for (i = 0 ; i < 2 ; i++) {
    PC0C_IO_PORT pIoPort;
    int j;

    pIoPort = &pDevExt->childs[i].ioPort;

    pIoPort->pIoLock = &pDevExt->ioLock;

    for (j = 0 ; j < C0C_QUEUE_SIZE ; j++) {
      InitializeListHead(&pIoPort->irpQueues[j].queue);
      pIoPort->irpQueues[j].pCurrent = NULL;
#if DBG
      pIoPort->irpQueues[j].started = FALSE;
#endif /* DBG */
    }

    pIoPort->pIoPortRemote = &pDevExt->childs[(i + 1) % 2].ioPort;

    status = AddPdoPort(pDrvObj,
                        num,
                        (BOOLEAN)(i ? FALSE : TRUE),
                        pDevExt,
                        pIoPort,
                        &pDevExt->childs[i].pDevExt);

    if (!NT_SUCCESS(status)) {
      SysLogDev(pNewDevObj, status, L"AddFdoBus AddPdoPort FAIL");
      pDevExt->childs[i].pDevExt = NULL;
      goto clean;
    }
  }

  Trace0((PC0C_COMMON_EXTENSION)pDevExt, L"AddFdoBus OK");

clean:

  if (!NT_SUCCESS(status) && pDevExt)
    RemoveFdoBus(pDevExt);

  StrFree(&ntDeviceName);
  StrFree(&portName);

  return status;
}
/********************************************************************/
NTSTATUS c0cAddDevice(IN PDRIVER_OBJECT pDrvObj, IN PDEVICE_OBJECT pPhDevObj)
{
  NTSTATUS status;
  UNICODE_STRING property;

  status = STATUS_SUCCESS;
  RtlInitUnicodeString(&property, NULL);

  StrAppendDeviceProperty(&status, &property, pPhDevObj, DevicePropertyHardwareID);

  if (NT_SUCCESS(status))
    Trace00(NULL, L"c0cAddDevice for ", property.Buffer);
  else {
    SysLogDrv(pDrvObj, status, L"c0cAddDevice IoGetDeviceProperty FAIL");
    return status;
  }

  if (!_wcsicmp(C0C_PORT_DEVICE_ID, property.Buffer)) {
    StrFree(&property);
    status = AddFdoPort(pDrvObj, pPhDevObj);
  }
  else
  if (!_wcsicmp(C0C_BUS_DEVICE_ID, property.Buffer)) {
    StrFree(&property);
    status = AddFdoBus(pDrvObj, pPhDevObj);
  }
  else {
    StrFree(&property);
    status = STATUS_UNSUCCESSFUL;
    SysLogDrv(pDrvObj, status, L"c0cAddDevice unknown HardwareID");
  }

  return status;
}
/********************************************************************/


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/strutils.c

/*
 * $Id: strutils.c,v 1.6 2010/05/27 11:06:23 vfrolov Exp $
 *
 * Copyright (c) 2004-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: strutils.c,v $
 * Revision 1.6  2010/05/27 11:06:23  vfrolov
 * Added StrAppendPortParametersRegistryPath() and StrAppendParameterPortName()
 *
 * Revision 1.5  2009/09/21 08:26:12  vfrolov
 * Fixed checking for overflow
 *
 * Revision 1.4  2007/01/11 14:50:29  vfrolov
 * Pool functions replaced by
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.3  2006/11/03 13:13:26  vfrolov
 * CopyStrW() now gets size in characters (not in bytes)
 *
 * Revision 1.2  2006/03/27 09:37:28  vfrolov
 * Added StrAppendDeviceProperty()
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"
#include "strutils.h"

NTSTATUS CopyStrW(OUT PWCHAR pDestStr, IN LONG size, IN PWCHAR pStr)
{
  NTSTATUS status;
  LONG len;
  PWCHAR pStrTmp;

  pStrTmp = pStr;

  while (*(pStrTmp++))
    ;

  len = (LONG)(pStrTmp - pStr);

  if (len > size) {
    len = size;
    status = STATUS_BUFFER_TOO_SMALL;
  } else {
    status = STATUS_SUCCESS;
  }

  if (len > 0) {
    RtlCopyMemory(pDestStr, pStr, len * sizeof(WCHAR));
    pDestStr[len - 1] = 0;
  }

  return status;
}

NTSTATUS DupStrW(OUT PWCHAR *ppDestStr, IN PWCHAR pStr, IN BOOLEAN multiStr)
{
  PWCHAR pStrTmp = pStr;
  ULONG len;

  if (multiStr) {
    do {
      while (*(pStrTmp++))
        ;
    } while (*(pStrTmp++));
  }
  else {
    while (*(pStrTmp++))
      ;
  }

  len = (ULONG)(pStrTmp - pStr) * sizeof(WCHAR);
  pStrTmp = (PWCHAR)C0C_ALLOCATE_POOL(PagedPool, len);

  if (!pStrTmp)
    return STATUS_INSUFFICIENT_RESOURCES;

  RtlCopyMemory(pStrTmp, pStr, len);
  *ppDestStr = pStrTmp;

  return STATUS_SUCCESS;
}

VOID StrFree(IN OUT PUNICODE_STRING  pDest)
{
  if (pDest->Buffer)
    C0C_FREE_POOL(pDest->Buffer);
  RtlZeroMemory(pDest, sizeof(*pDest));
}

BOOLEAN StrFreeBad(NTSTATUS status, IN OUT PUNICODE_STRING  pDest)
{
  if (!NT_SUCCESS(status)) {
    StrFree(pDest);
    return TRUE;
  }
  return FALSE;
}

VOID StrAppendStr(
    PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING  pDest,
    IN PWCHAR pSrc,
    IN USHORT lenSrc)
{
  UNICODE_STRING old;
  NTSTATUS status;
  SIZE_T newLength;

  status = *pStatus;

  if (!NT_SUCCESS(status) || !pSrc || !lenSrc)
    return;

  old = *pDest;

  RtlZeroMemory(pDest, sizeof(*pDest));

  newLength = (SIZE_T)old.Length + (SIZE_T)lenSrc;

  if ((USHORT)newLength == newLength) {  /* checking for overflow */
    pDest->MaximumLength = (USHORT)newLength;
    pDest->Buffer = C0C_ALLOCATE_POOL(PagedPool, pDest->MaximumLength + sizeof(WCHAR));
  }

  if (pDest->Buffer) {
    RtlZeroMemory(pDest->Buffer, pDest->MaximumLength + sizeof(WCHAR));
    status = RtlAppendUnicodeStringToString(pDest, &old);
    if (NT_SUCCESS(status)) {
      PWCHAR pSrc0;

      pSrc0 = C0C_ALLOCATE_POOL(PagedPool, lenSrc + sizeof(WCHAR));

      if (pSrc0) {
        RtlZeroMemory(pSrc0, lenSrc + sizeof(WCHAR));
        RtlCopyMemory(pSrc0, pSrc, lenSrc);

        status = RtlAppendUnicodeToString(pDest, pSrc0);

        C0C_FREE_POOL(pSrc0);
      } else
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
  } else
    status = STATUS_INSUFFICIENT_RESOURCES;

  StrFreeBad(status, pDest);

  if (old.Buffer)
    C0C_FREE_POOL(old.Buffer);

  *pStatus = status;
}

VOID StrAppendStr0(PNTSTATUS pStatus, IN OUT PUNICODE_STRING  pDest, IN PWCHAR pSrc)
{
  StrAppendStr(pStatus, pDest, pSrc, (USHORT)(wcslen(pSrc) * sizeof(WCHAR)));
}

VOID StrAppendNum(
    PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN ULONG num,
    IN ULONG base)
{
  UNICODE_STRING numStr;
  WCHAR numStrBuf[20];

  if (!NT_SUCCESS(*pStatus))
    return;

  RtlInitUnicodeString(&numStr, NULL);
  numStr.MaximumLength = sizeof(numStrBuf);
  numStr.Buffer = numStrBuf;
  *pStatus = RtlIntegerToUnicodeString(num, base, &numStr);

  if (StrFreeBad(*pStatus, pDest))
    return;

  StrAppendStr(pStatus, pDest, numStr.Buffer, numStr.Length);
}

VOID StrAppendDeviceProperty(
    IN OUT PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN PDEVICE_OBJECT pDevObj,
    IN DEVICE_REGISTRY_PROPERTY deviceProperty)
{
  NTSTATUS status;
  ULONG len;

  status = *pStatus;

  if (!NT_SUCCESS(status))
    return;

  status = IoGetDeviceProperty(pDevObj,
                               deviceProperty,
                               0,
                               NULL,
                               &len);

  if (status == STATUS_BUFFER_TOO_SMALL && len) {
    PWCHAR pStrTmp;

    pStrTmp = (PWCHAR)C0C_ALLOCATE_POOL(PagedPool, len);

    if (pStrTmp) {
      status = IoGetDeviceProperty(pDevObj,
                                   deviceProperty,
                                   len,
                                   pStrTmp,
                                   &len);

      if (NT_SUCCESS(status))
        StrAppendStr0(&status, pDest, pStrTmp);

      C0C_FREE_POOL(pStrTmp);
    } else {
      status = STATUS_INSUFFICIENT_RESOURCES;
    }
  }

  StrFreeBad(status, pDest);

  *pStatus = status;
}

VOID StrAppendPortParametersRegistryPath(
    IN OUT PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN PWCHAR pPhPortName)
{
  StrAppendStr(pStatus, pDest, c0cGlobal.registryPath.Buffer, c0cGlobal.registryPath.Length);
  StrAppendStr0(pStatus, pDest, L"\\Parameters\\");
  StrAppendStr0(pStatus, pDest, pPhPortName);
}

VOID StrAppendParameterPortName(
    IN OUT PNTSTATUS pStatus,
    IN OUT PUNICODE_STRING pDest,
    IN PWCHAR pPortParametersRegistryPath)
{
  NTSTATUS status;
  WCHAR portNameBuf[C0C_PORT_NAME_LEN + 1];
  UNICODE_STRING portNameTmp;
  RTL_QUERY_REGISTRY_TABLE queryTable[2];

  status = *pStatus;

  if (!NT_SUCCESS(status))
    return;

  RtlZeroMemory(queryTable, sizeof(queryTable));

  portNameTmp.Length = 0;
  portNameTmp.MaximumLength = sizeof(portNameBuf);
  portNameTmp.Buffer = portNameBuf;

  queryTable[0].Flags        = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
  queryTable[0].Name         = L"PortName";
  queryTable[0].EntryContext = &portNameTmp;

  status = RtlQueryRegistryValues(
      RTL_REGISTRY_ABSOLUTE,
      pPortParametersRegistryPath,
      queryTable,
      NULL,
      NULL);

  StrAppendStr(&status, pDest, portNameTmp.Buffer, portNameTmp.Length);

  StrFreeBad(status, pDest);

  *pStatus = status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/rand.h

/*
 * $Id: rand.h,v 1.1 2008/06/26 13:37:10 vfrolov Exp $
 *
 * Copyright (c) 2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: rand.h,v $
 * Revision 1.1  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 */

#ifndef _C0C_RAND_H_
#define _C0C_RAND_H_

ULONG RAND();

#endif /* _C0C_RAND_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/sources

TARGETNAME=com0com
TARGETPATH=..
TARGETTYPE=DRIVER


MSC_WARNING_LEVEL=/W4

SOURCES= \
        initunlo.c \
        adddev.c \
        showport.c \
        openclos.c \
        pnp.c \
        power.c \
        ioctl.c \
        wmi.c \
        commprop.c \
        read.c \
        write.c \
        wait.c \
        fileinfo.c \
        io.c \
        pinouts.c \
        handflow.c \
        startirp.c \
        timeout.c \
        delay.c \
        bufutils.c \
        strutils.c \
        noise.c \
        rand.c \
        syslog.c \
        trace.c \
        tracetbl.c \
        c0clog.mc \
        com0com.rc \

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/fileinfo.c

/*
 * $Id: fileinfo.c,v 1.4 2009/09/21 08:41:33 vfrolov Exp $
 *
 * Copyright (c) 2005-2009 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: fileinfo.c,v $
 * Revision 1.4  2009/09/21 08:41:33  vfrolov
 * Added missing Information = 0
 * (Thanks Kirill Bagrinovsky)
 *
 * Revision 1.3  2007/11/09 15:51:18  vfrolov
 * Added OutputBufferLength check
 *
 * Revision 1.2  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.1  2005/09/28 10:06:42  vfrolov
 * Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION
 *
 */

#include "precomp.h"

/*
 * FILE_ID used by HALT_UNLESS to put it on BSOD
 */
#define FILE_ID 0xA

NTSTATUS FdoPortQueryInformation(PC0C_IO_PORT pIoPortLocal, IN PIRP pIrp)
{
  NTSTATUS status;

  pIrp->IoStatus.Information = 0;

  if ((pIoPortLocal->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pIoPortLocal->errors) {
    status = STATUS_CANCELLED;
  } else {
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpStack->Parameters.QueryFile.FileInformationClass) {
    case FileStandardInformation:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(FILE_STANDARD_INFORMATION)) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }
      RtlZeroMemory(pIrp->AssociatedIrp.SystemBuffer, sizeof(FILE_STANDARD_INFORMATION));
      pIrp->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
      status = STATUS_SUCCESS;
      break;
    case FilePositionInformation:
      if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(FILE_POSITION_INFORMATION)) {
         status = STATUS_BUFFER_TOO_SMALL;
         break;
      }
      RtlZeroMemory(pIrp->AssociatedIrp.SystemBuffer, sizeof(FILE_POSITION_INFORMATION));
      pIrp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
      status = STATUS_SUCCESS;
      break;
    default:
      status = STATUS_INVALID_PARAMETER;
    }
  }

  TraceIrp("FdoPortQueryInformation", pIrp, &status, TRACE_FLAG_PARAMS);

  pIrp->IoStatus.Status = status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}

NTSTATUS FdoPortSetInformation(PC0C_IO_PORT pIoPortLocal, IN PIRP pIrp)
{
  NTSTATUS status;

  if ((pIoPortLocal->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pIoPortLocal->errors) {
    status = STATUS_CANCELLED;
  } else {
    PIO_STACK_LOCATION pIrpStack;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    switch (pIrpStack->Parameters.QueryFile.FileInformationClass) {
    case FileEndOfFileInformation:
    case FileAllocationInformation:
      status = STATUS_SUCCESS;
      break;
    default:
      status = STATUS_INVALID_PARAMETER;
    }
  }

  TraceIrp("FdoPortSetInformation", pIrp, &status, TRACE_FLAG_PARAMS);

  pIrp->IoStatus.Information = 0;
  pIrp->IoStatus.Status = status;
  IoCompleteRequest(pIrp, IO_NO_INCREMENT);

  return status;
}

NTSTATUS c0cFileInformation(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;
  ULONG code = IoGetCurrentIrpStackLocation(pIrp)->MajorFunction;

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    if (code == IRP_MJ_QUERY_INFORMATION)
      status = FdoPortQueryInformation(((PC0C_FDOPORT_EXTENSION)pDevExt)->pIoPortLocal, pIrp);
    else
      status = FdoPortSetInformation(((PC0C_FDOPORT_EXTENSION)pDevExt)->pIoPortLocal, pIrp);
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    TraceCode(pDevExt, "IRP_MJ_", codeNameTableIrpMj, code, &status);
  }

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/delay.h

/*
 * $Id: delay.h,v 1.6 2008/03/14 15:28:39 vfrolov Exp $
 *
 * Copyright (c) 2005-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: delay.h,v $
 * Revision 1.6  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.5  2007/06/09 08:49:47  vfrolov
 * Improved baudrate emulation
 *
 * Revision 1.4  2007/06/01 08:36:26  vfrolov
 * Changed parameter type for SetWriteDelay()
 *
 * Revision 1.3  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.2  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.1  2005/08/23 15:30:22  vfrolov
 * Initial revision
 *
 *
 */

#ifndef _C0C_DELAY_H_
#define _C0C_DELAY_H_

typedef struct _C0C_DELAY_PARAMS {
  ULONG                   decibits_per_frame;
  ULONG                   baudRate;
} C0C_DELAY_PARAMS, *PC0C_DELAY_PARAMS;

typedef struct _C0C_ADAPTIVE_DELAY {
  KTIMER                  timer;
  KDPC                    timerDpc;

  C0C_DELAY_PARAMS        params;

  ULONGLONG               startTime;
  ULONGLONG               sentFrames;
  short                   idleCount;
  BOOLEAN                 started;
} C0C_ADAPTIVE_DELAY, *PC0C_ADAPTIVE_DELAY;

NTSTATUS AllocWriteDelay(PC0C_IO_PORT pIoPort);
VOID FreeWriteDelay(PC0C_IO_PORT pIoPort);
SIZE_T GetWriteLimit(PC0C_ADAPTIVE_DELAY pWriteDelay);
VOID SetWriteDelay(PC0C_IO_PORT pIoPort);
VOID StartWriteDelayTimer(PC0C_ADAPTIVE_DELAY pWriteDelay);
VOID StopWriteDelayTimer(PC0C_ADAPTIVE_DELAY pWriteDelay);

#endif /* _C0C_DELAY_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/c0clog.mc

;#ifndef _C0C_LOG_
;#define _C0C_LOG_

MessageIdTypedef=NTSTATUS

SeverityNames=(Success=0x0:STATUS_SEVERITY_SUCCESS
               Informational=0x1:STATUS_SEVERITY_INFORMATIONAL
               Warning=0x2:STATUS_SEVERITY_WARNING
               Error=0x3:STATUS_SEVERITY_ERROR
              )

FacilityNames=(System=0x0
               RpcRuntime=0x2:FACILITY_RPC_RUNTIME
               RpcStubs=0x3:FACILITY_RPC_STUBS
               Io=0x4:FACILITY_IO_ERROR_CODE
               com0com=0x6:FACILITY_SERIAL_ERROR_CODE
              )


MessageId=0x0001 Facility=com0com Severity=Informational SymbolicName=COM0COM_LOG
Language=English
%1: %2.
.

MessageId=0x0002 Facility=com0com Severity=Informational SymbolicName=COM0COM_LOG_DRV
Language=English
%2.
.

;#endif /* _C0C_LOG_ */



# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/handflow.h

/*
 * $Id: handflow.h,v 1.5 2008/07/11 10:38:00 vfrolov Exp $
 *
 * Copyright (c) 2005-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: handflow.h,v $
 * Revision 1.5  2008/07/11 10:38:00  vfrolov
 * Added nonstandard ability to enable LSR insertion on BREAK OFF
 *
 * Revision 1.4  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.3  2006/05/17 15:31:14  vfrolov
 * Implemented SERIAL_TRANSMIT_TOGGLE
 *
 * Revision 1.2  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.1  2006/01/10 10:12:05  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_FLOW_H_
#define _C0C_FLOW_H_

NTSTATUS SetHandFlow(
    PC0C_IO_PORT pIoPort,
    PSERIAL_HANDFLOW pHandFlow,
    PLIST_ENTRY pQueueToComplete);

VOID UpdateHandFlow(
    PC0C_IO_PORT pIoPort,
    BOOLEAN freed,
    PLIST_ENTRY pQueueToComplete);

VOID UpdateTransmitToggle(
    PC0C_IO_PORT pIoPort,
    PLIST_ENTRY pQueueToComplete);

VOID SetLimit(PC0C_IO_PORT pIoPort);
VOID SetModemStatusHolding(PC0C_IO_PORT pIoPort);
VOID SetXonXoffHolding(PC0C_IO_PORT pIoPort, short xonXoff);
VOID SetBreakHolding(PC0C_IO_PORT pIoPort, BOOLEAN on, PLIST_ENTRY pQueueToComplete);

#endif /* _C0C_FLOW_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/wait.c

/*
 * $Id: wait.c,v 1.3 2008/03/31 12:02:06 vfrolov Exp $
 *
 * Copyright (c) 2004-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: wait.c,v $
 * Revision 1.3  2008/03/31 12:02:06  vfrolov
 * Fixed cleaning of already occured events on wait mask setting
 *
 * Revision 1.2  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 *
 */

#include "precomp.h"

NTSTATUS StartIrpWaitOnMask(
    IN PC0C_IO_PORT pIoPort,
    IN PLIST_ENTRY pQueueToComplete)
{
  UNREFERENCED_PARAMETER(pQueueToComplete);

  if (!pIoPort->waitMask)
    return STATUS_INVALID_PARAMETER;

  if (pIoPort->eventMask) {
    PIRP pIrp;

    pIrp = pIoPort->irpQueues[C0C_QUEUE_WAIT].pCurrent;

    *((PULONG)pIrp->AssociatedIrp.SystemBuffer) = pIoPort->eventMask;
    pIoPort->eventMask = 0;
    pIrp->IoStatus.Information = sizeof(ULONG);
    return STATUS_SUCCESS;
  }

  return STATUS_PENDING;
}

NTSTATUS FdoPortWaitOnMask(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack)
{
  if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
    return STATUS_BUFFER_TOO_SMALL;

  return FdoPortStartIrp(pIoPort, pIrp, C0C_QUEUE_WAIT, StartIrpWaitOnMask);
}

NTSTATUS FdoPortSetWaitMask(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack)
{
  LIST_ENTRY queueToComplete;
  KIRQL oldIrql;
  PULONG pSysBuf;

  if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
    return STATUS_BUFFER_TOO_SMALL;

  pSysBuf = (PULONG)pIrp->AssociatedIrp.SystemBuffer;

  if (*pSysBuf & ~(
      SERIAL_EV_RXCHAR   |
      SERIAL_EV_RXFLAG   |
      SERIAL_EV_TXEMPTY  |
      SERIAL_EV_CTS      |
      SERIAL_EV_DSR      |
      SERIAL_EV_RLSD     |
      SERIAL_EV_BREAK    |
      SERIAL_EV_ERR      |
      SERIAL_EV_RING     |
      SERIAL_EV_PERR     |
      SERIAL_EV_RX80FULL |
      SERIAL_EV_EVENT1   |
      SERIAL_EV_EVENT2
      ))
    return STATUS_INVALID_PARAMETER;

  InitializeListHead(&queueToComplete);

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);
  FdoPortIo(
      C0C_IO_TYPE_WAIT_COMPLETE,
      &pIoPort->eventMask,
      pIoPort,
      &pIoPort->irpQueues[C0C_QUEUE_WAIT],
      &queueToComplete);

  pIoPort->waitMask = *pSysBuf;
  pIoPort->eventMask &= pIoPort->waitMask;

  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);
  FdoPortCompleteQueue(&queueToComplete);

  return STATUS_SUCCESS;
}

NTSTATUS FdoPortGetWaitMask(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack)
{
  KIRQL oldIrql;
  PULONG pSysBuf;

  if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
    return STATUS_BUFFER_TOO_SMALL;

  pSysBuf = (PULONG)pIrp->AssociatedIrp.SystemBuffer;

  KeAcquireSpinLock(pIoPort->pIoLock, &oldIrql);
  *pSysBuf = pIoPort->waitMask;
  KeReleaseSpinLock(pIoPort->pIoLock, oldIrql);

  pIrp->IoStatus.Information = sizeof(ULONG);

  return STATUS_SUCCESS;
}

VOID WaitComplete(
    IN PC0C_IO_PORT pIoPort,
    PLIST_ENTRY pQueueToComplete)
{
  if (pIoPort->eventMask) {
    FdoPortIo(
        C0C_IO_TYPE_WAIT_COMPLETE,
        &pIoPort->eventMask,
        pIoPort,
        &pIoPort->irpQueues[C0C_QUEUE_WAIT],
        pQueueToComplete);
  }
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/timeout.h

/*
 * $Id: timeout.h,v 1.7 2008/03/14 15:28:39 vfrolov Exp $
 *
 * Copyright (c) 2004-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: timeout.h,v $
 * Revision 1.7  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.6  2007/06/04 15:24:33  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.5  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.4  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.3  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.2  2005/08/16 16:36:33  vfrolov
 * Hidden timeout functions
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 *
 */

#ifndef _C0C_TIMEOUT_H_
#define _C0C_TIMEOUT_H_

VOID AllocTimeouts(PC0C_IO_PORT pIoPort);
VOID FreeTimeouts(PC0C_IO_PORT pIoPort);

VOID SetIntervalTimeout(PC0C_IO_PORT pIoPort);

VOID SetCloseTimeout(PC0C_IO_PORT pIoPort);

VOID SetXoffCounterTimeout(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp);

NTSTATUS SetIrpTimeout(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp);

NTSTATUS FdoPortSetTimeouts(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp,
    PIO_STACK_LOCATION pIrpStack);

NTSTATUS FdoPortGetTimeouts(
    PC0C_IO_PORT pIoPort,
    PIRP pIrp,
    PIO_STACK_LOCATION pIrpStack);

#endif /* _C0C_TIMEOUT_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/write.c

/*
 * $Id: write.c,v 1.10 2008/12/02 16:10:09 vfrolov Exp $
 *
 * Copyright (c) 2004-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: write.c,v $
 * Revision 1.10  2008/12/02 16:10:09  vfrolov
 * Separated tracing and debuging
 *
 * Revision 1.9  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.8  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.7  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.6  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.5  2005/12/05 10:54:56  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.4  2005/09/13 14:56:16  vfrolov
 * Implemented IRP_MJ_FLUSH_BUFFERS
 *
 * Revision 1.3  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.2  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#include "precomp.h"

NTSTATUS StartIrpWrite(
    IN PC0C_IO_PORT pIoPort,
    IN PLIST_ENTRY pQueueToComplete)
{
  return ReadWrite(
      pIoPort->pIoPortRemote, FALSE,
      pIoPort, TRUE,
      pQueueToComplete);
}

NTSTATUS FdoPortImmediateChar(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack)
{
  if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR))
    return STATUS_BUFFER_TOO_SMALL;

  return FdoPortStartIrp(pIoPort, pIrp, C0C_QUEUE_WRITE, StartIrpWrite);
}

NTSTATUS FdoPortXoffCounter(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack)
{
  PSERIAL_XOFF_COUNTER pXoffCounter;

  if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SERIAL_XOFF_COUNTER))
    return STATUS_BUFFER_TOO_SMALL;

  pXoffCounter = (PSERIAL_XOFF_COUNTER)pIrp->AssociatedIrp.SystemBuffer;

  if (pXoffCounter->Counter <= 0)
    return STATUS_INVALID_PARAMETER;

  return FdoPortStartIrp(pIoPort, pIrp, C0C_QUEUE_WRITE, StartIrpWrite);
}

NTSTATUS FdoPortWrite(IN PC0C_IO_PORT pIoPort, IN PIRP pIrp)
{
  NTSTATUS status;

  pIrp->IoStatus.Information = 0;

  if ((pIoPort->handFlow.ControlHandShake & SERIAL_ERROR_ABORT) && pIoPort->errors) {
    status = STATUS_CANCELLED;
  } else {
    if (IoGetCurrentIrpStackLocation(pIrp)->MajorFunction == IRP_MJ_FLUSH_BUFFERS ||
                         IoGetCurrentIrpStackLocation(pIrp)->Parameters.Write.Length)
      status = FdoPortStartIrp(pIoPort, pIrp, C0C_QUEUE_WRITE, StartIrpWrite);
    else
      status = STATUS_SUCCESS;
  }

  if (status != STATUS_PENDING) {
    TraceIrp("FdoPortWrite", pIrp, &status, TRACE_FLAG_RESULTS);
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  return status;
}

NTSTATUS c0cWrite(IN PDEVICE_OBJECT pDevObj, IN PIRP pIrp)
{
  NTSTATUS status;
  PC0C_COMMON_EXTENSION pDevExt = pDevObj->DeviceExtension;

#if ENABLE_TRACING
  ULONG code = IoGetCurrentIrpStackLocation(pIrp)->MajorFunction;
#endif /* ENABLE_TRACING */

  TraceIrp("c0cWrite", pIrp, NULL, TRACE_FLAG_PARAMS);

  switch (pDevExt->doType) {
  case C0C_DOTYPE_FP:
    status = FdoPortWrite(((PC0C_FDOPORT_EXTENSION)pDevExt)->pIoPortLocal, pIrp);
    break;
  default:
    status = STATUS_INVALID_DEVICE_REQUEST;
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
  }

  if (!NT_SUCCESS(status))
    TraceCode(pDevExt, "IRP_MJ_", codeNameTableIrpMj, code, &status);

  return status;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/bufutils.h

/*
 * $Id: bufutils.h,v 1.9 2010/08/04 10:38:55 vfrolov Exp $
 *
 * Copyright (c) 2005-2010 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: bufutils.h,v $
 * Revision 1.9  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.8  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.7  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.6  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.5  2006/05/17 15:28:03  vfrolov
 * Implemented SERIAL_DSR_SENSITIVITY
 *
 * Revision 1.4  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.3  2005/11/28 12:57:16  vfrolov
 * Moved some C0C_BUFFER code to bufutils.c
 *
 * Revision 1.2  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.1  2005/08/25 15:38:17  vfrolov
 * Some code moved from io.c to bufutils.c
 *
 */

#ifndef _C0C_BUFUTILS_H_
#define _C0C_BUFUTILS_H_

typedef struct _C0C_FLOW_FILTER {
  PC0C_IO_PORT pIoPort;

  USHORT events;
  UCHAR flags;

  UCHAR lastXonXoff;
  SIZE_T rxCount;
} C0C_FLOW_FILTER, *PC0C_FLOW_FILTER;


NTSTATUS MoveRawData(PC0C_RAW_DATA pDstRawData, PC0C_RAW_DATA pSrcRawData);
VOID FlowFilterInit(PC0C_IO_PORT pIoPort, PC0C_FLOW_FILTER pFlowFilter);
VOID CopyCharsWithEscape(
    PC0C_BUFFER pBuf,
    PC0C_FLOW_FILTER pFlowFilter,
    PUCHAR pReadBuf, SIZE_T readLength,
    PUCHAR pWriteBuf, SIZE_T writeLength,
    PSIZE_T pReadDone,
    PSIZE_T pWriteDone);
SIZE_T ReadFromBuffer(PC0C_BUFFER pBuf, PVOID pRead, SIZE_T readLength);
SIZE_T WriteToBuffer(
    PC0C_BUFFER pBuf,
    PVOID pWrite,
    SIZE_T writeLength,
    PC0C_FLOW_FILTER pFlowFilter,
    PSIZE_T pOverrun);
VOID WriteMandatoryToBuffer(PC0C_BUFFER pBuf, UCHAR mandatoryChar);
NTSTATUS WriteRawDataToBuffer(PC0C_RAW_DATA pRawData, PC0C_BUFFER pBuf);
SIZE_T WriteRawData(PC0C_RAW_DATA pRawData, PNTSTATUS pStatus, PVOID pReadBuf, SIZE_T readLength);
BOOLEAN SetNewBufferBase(PC0C_BUFFER pBuf, PUCHAR pBase, SIZE_T size);
VOID PurgeBuffer(PC0C_BUFFER pBuf);
VOID InitBuffer(PC0C_BUFFER pBuf, __drv_aliasesMem PUCHAR pBase, SIZE_T size);
VOID FreeBuffer(PC0C_BUFFER pBuf);
VOID SetBufferLimit(PC0C_BUFFER pBuf, SIZE_T limit);
SIZE_T ReadFromTxBuffer(
    PC0C_BUFFER pBuf,
    PC0C_FLOW_FILTER pFlowFilter,
    PVOID pRead, SIZE_T readLength,
    PC0C_TX_BUFFER pTxBuf, SIZE_T txLimit,
    PSIZE_T pWriteDone);
SIZE_T WriteToTxBuffer(
    PC0C_TX_BUFFER pTxBuf,
    PVOID pWrite,
    SIZE_T writeLength);
SIZE_T MoveFromTxBuffer(
    PC0C_BUFFER pBuf,
    PC0C_TX_BUFFER pTxBuf,
    SIZE_T txLimit,
    PC0C_FLOW_FILTER pFlowFilter,
    PSIZE_T pOverrun);
VOID SetTxBuffer(PC0C_TX_BUFFER pTxBuf, SIZE_T size, BOOLEAN cleanFifo);
VOID FreeTxBuffer(PC0C_TX_BUFFER pTxBuf);

#endif /* _C0C_BUFUTILS_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/.cvsignore

*.log
MSG00001.bin
c0clog.h
c0clog.rc
obj
objchk*
objfre*


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/syslog.c

/*
 * $Id: syslog.c,v 1.2 2011/12/15 06:17:12 vfrolov Exp $
 *
 * Copyright (c) 2004-2011 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: syslog.c,v $
 * Revision 1.2  2011/12/15 06:17:12  vfrolov
 * Removed usage undocumented PDRIVER_OBJECT->Type
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 *
 */

#include "precomp.h"
#include "syslog.h"
#include "c0clog.h"

VOID SysLog(
    IN PVOID pIoObject,
    IN NTSTATUS status,
    IN PWCHAR pStr,
    IN NTSTATUS msgId)
{
  PIO_ERROR_LOG_PACKET pErrorLogEntry;
  PUCHAR pInsert;
  SIZE_T lenStr = wcslen(pStr) * sizeof(WCHAR);
  SIZE_T lenInsert = lenStr + sizeof(WCHAR);
  SIZE_T entrySize = sizeof(IO_ERROR_LOG_PACKET) + lenInsert;

  if (entrySize > ERROR_LOG_MAXIMUM_SIZE) {
    lenStr = ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET);
    lenStr = (lenStr / sizeof(WCHAR)) * sizeof(WCHAR) - sizeof(WCHAR);
    lenInsert = lenStr + sizeof(WCHAR);
    entrySize = sizeof(IO_ERROR_LOG_PACKET) + lenInsert;
  }

  if ((pErrorLogEntry = IoAllocateErrorLogEntry(pIoObject, (UCHAR)entrySize)) == NULL)
    return;

  pInsert = (PUCHAR)&pErrorLogEntry->DumpData[0];
  RtlZeroMemory(pInsert, lenInsert);

  pErrorLogEntry->ErrorCode = msgId;

  pErrorLogEntry->SequenceNumber = 0;
  pErrorLogEntry->MajorFunctionCode = 0;
  pErrorLogEntry->RetryCount = 0;
  pErrorLogEntry->UniqueErrorValue = 0;
  pErrorLogEntry->FinalStatus = status;
  pErrorLogEntry->DumpDataSize = 0;

  pErrorLogEntry->NumberOfStrings = 1;
  pErrorLogEntry->StringOffset = (USHORT)(pInsert - (PUCHAR)pErrorLogEntry);
  RtlCopyMemory(pInsert, pStr, lenStr);

  IoWriteErrorLogEntry(pErrorLogEntry);
}

VOID SysLogDrv(
    IN PDRIVER_OBJECT pDrvObj,
    IN NTSTATUS status,
    IN PWCHAR pStr)
{
  SysLog(pDrvObj, status, pStr, COM0COM_LOG_DRV);
}

VOID SysLogDev(
    IN PDEVICE_OBJECT pDevObj,
    IN NTSTATUS status,
    IN PWCHAR pStr)
{
  SysLog(pDevObj, status, pStr, COM0COM_LOG);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/com0com.h

/*
 * $Id: com0com.h,v 1.53 2012/02/03 17:14:24 vfrolov Exp $
 *
 * Copyright (c) 2004-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: com0com.h,v $
 * Revision 1.53  2012/02/03 17:14:24  vfrolov
 * Optimized GetIrpState()
 *
 * Revision 1.52  2011/12/06 16:03:22  vfrolov
 * Added cleaning high data bits for less then 8 bit data
 * Added AllDataBits option to force 8 bit data
 *
 * Revision 1.51  2010/08/09 06:02:40  vfrolov
 * Eliminated accessing undocumented structure members
 *
 * Revision 1.50  2010/08/04 10:38:55  vfrolov
 * Minimized PREfast noise
 *
 * Revision 1.49  2010/06/01 06:14:10  vfrolov
 * Improved driver updating
 *
 * Revision 1.48  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.47  2008/10/30 07:54:37  vfrolov
 * Improved BREAK emulation
 *
 * Revision 1.46  2008/09/17 07:58:32  vfrolov
 * Added AddRTTO and AddRITO parameters
 *
 * Revision 1.45  2008/07/11 10:38:00  vfrolov
 * Added nonstandard ability to enable LSR insertion on BREAK OFF
 *
 * Revision 1.44  2008/06/26 13:37:10  vfrolov
 * Implemented noise emulation
 *
 * Revision 1.43  2008/05/04 09:51:45  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.42  2008/04/08 10:27:44  vfrolov
 * Fixed C0C_MCR_MASK
 *
 * Revision 1.41  2008/04/08 06:47:37  vfrolov
 * Added pin OUT2
 *
 * Revision 1.40  2008/03/14 15:28:39  vfrolov
 * Implemented ability to get paired port settings with
 * extended IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.39  2007/11/23 08:30:50  vfrolov
 * Increased size of TX buffer to typical default for Windows
 *
 * Revision 1.38  2007/09/17 14:31:06  vfrolov
 * Implemented pseudo pin OPEN
 *
 * Revision 1.37  2007/07/20 08:00:22  vfrolov
 * Implemented TX buffer
 *
 * Revision 1.36  2007/07/03 14:35:17  vfrolov
 * Implemented pinout customization
 *
 * Revision 1.35  2007/06/04 15:24:32  vfrolov
 * Fixed open reject just after close in exclusiveMode
 *
 * Revision 1.34  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 * Revision 1.33  2007/02/20 12:05:11  vfrolov
 * Implemented IOCTL_SERIAL_XOFF_COUNTER
 * Fixed cancel and timeout routines
 *
 * Revision 1.32  2007/01/11 14:44:52  vfrolov
 * Defined
 *   C0C_TAG
 *   C0C_ALLOCATE_POOL()
 *   C0C_ALLOCATE_POOL_WITH_QUOTA()
 *   C0C_FREE_POOL()
 *
 * Revision 1.31  2006/11/03 13:07:58  vfrolov
 * Moved C0C_PORT_NAME_LEN from sys/com0com.h to include/com0com.h
 *
 * Revision 1.30  2006/10/16 08:30:45  vfrolov
 * Added the device interface registration
 *
 * Revision 1.29  2006/10/13 10:15:02  vfrolov
 * Some defines moved to ../include/com0com.h
 * Changed defines of C0C_DOTYPE_* to more unique values
 *
 * Revision 1.28  2006/08/23 13:48:12  vfrolov
 * Implemented WMI functionality
 *
 * Revision 1.27  2006/06/23 11:44:52  vfrolov
 * Mass replacement pDevExt by pIoPort
 *
 * Revision 1.26  2006/06/21 16:23:57  vfrolov
 * Fixed possible BSOD after one port of pair removal
 *
 * Revision 1.25  2006/04/05 07:22:15  vfrolov
 * Replaced flipXoffLimit flag by writeHoldingRemote to correct handFlow changing
 *
 * Revision 1.24  2006/02/26 08:35:55  vfrolov
 * Added check for start/stop queue matching
 *
 * Revision 1.23  2006/02/17 07:55:13  vfrolov
 * Implemented IOCTL_SERIAL_SET_BREAK_ON and IOCTL_SERIAL_SET_BREAK_OFF
 *
 * Revision 1.22  2006/01/10 10:17:23  vfrolov
 * Implemented flow control and handshaking
 * Implemented IOCTL_SERIAL_SET_XON and IOCTL_SERIAL_SET_XOFF
 * Added setting of HoldReasons, WaitForImmediate and AmountInOutQueue
 *   fields of SERIAL_STATUS for IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.21  2005/12/06 13:04:32  vfrolov
 * Fixed data types
 *
 * Revision 1.20  2005/12/05 10:54:55  vfrolov
 * Implemented IOCTL_SERIAL_IMMEDIATE_CHAR
 *
 * Revision 1.19  2005/11/30 16:04:11  vfrolov
 * Implemented IOCTL_SERIAL_GET_STATS and IOCTL_SERIAL_CLEAR_STATS
 *
 * Revision 1.18  2005/11/29 16:16:46  vfrolov
 * Removed FdoPortCancelQueue()
 *
 * Revision 1.17  2005/11/29 12:33:21  vfrolov
 * Changed SetModemStatus() to ability set and clear bits simultaneously
 *
 * Revision 1.16  2005/11/29 08:35:14  vfrolov
 * Implemented SERIAL_EV_RX80FULL
 *
 * Revision 1.15  2005/11/28 12:57:16  vfrolov
 * Moved some C0C_BUFFER code to bufutils.c
 *
 * Revision 1.14  2005/09/28 10:06:42  vfrolov
 * Implemented IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION
 *
 * Revision 1.13  2005/09/13 14:56:16  vfrolov
 * Implemented IRP_MJ_FLUSH_BUFFERS
 *
 * Revision 1.12  2005/09/06 07:23:44  vfrolov
 * Implemented overrun emulation
 *
 * Revision 1.11  2005/08/23 15:49:21  vfrolov
 * Implemented baudrate emulation
 *
 * Revision 1.10  2005/07/13 16:12:36  vfrolov
 * Added c0cGlobal struct for global driver's data
 *
 * Revision 1.9  2005/06/28 12:17:12  vfrolov
 * Added pBusExt to C0C_PDOPORT_EXTENSION
 *
 * Revision 1.8  2005/05/20 12:06:05  vfrolov
 * Improved port numbering
 *
 * Revision 1.7  2005/05/19 08:23:40  vfrolov
 * Fixed data types
 *
 * Revision 1.6  2005/05/14 17:07:02  vfrolov
 * Implemented SERIAL_LSRMST_MST insertion
 *
 * Revision 1.5  2005/05/13 16:58:03  vfrolov
 * Implemented IOCTL_SERIAL_LSRMST_INSERT
 *
 * Revision 1.4  2005/05/12 07:41:27  vfrolov
 * Added ability to change the port names
 *
 * Revision 1.3  2005/02/01 16:47:57  vfrolov
 * Implemented SERIAL_PURGE_RXCLEAR and IOCTL_SERIAL_GET_COMMSTATUS
 *
 * Revision 1.2  2005/02/01 08:37:55  vfrolov
 * Changed SetModemStatus() to set multiple bits
 *
 * Revision 1.1  2005/01/26 12:18:54  vfrolov
 * Initial revision
 *
 */

#ifndef _C0C_COM0COM_H_
#define _C0C_COM0COM_H_

#define TEXT_PREF L
#include "../include/com0com.h"

#define C0C_SERIAL_DEVICEMAP        L"SERIALCOMM"
#define C0C_PREF_WIN32_DEVICE_NAME  L"\\DosDevices\\"

#define C0C_PORT_HARDWARE_IDS_CNCCLASS C0C_PORT_DEVICE_ID L"\0" C0C_PORT_HW_ID_CNCCLASS L"\0"
#define C0C_PORT_HARDWARE_IDS_COMCLASS C0C_PORT_DEVICE_ID L"\0" C0C_PORT_HW_ID_COMCLASS L"\0"

#define C0C_DOTYPE_FB     ((unsigned)0xC0C1)
#define C0C_DOTYPE_PP     ((unsigned)0xC0C2)
#define C0C_DOTYPE_FP     ((unsigned)0xC0C3)

#define COMMON_EXTENSION                \
  unsigned short          doType;       \
  PDEVICE_OBJECT          pDevObj;      \
  WCHAR                   portName[C0C_PORT_NAME_LEN + 1]; \

#define FDO_EXTENSION                   \
  COMMON_EXTENSION                      \
  PDEVICE_OBJECT          pLowDevObj;   \

#define C0C_XCHAR_ON      1
#define C0C_XCHAR_OFF     2

typedef struct _C0C_COMMON_EXTENSION {
  COMMON_EXTENSION
} C0C_COMMON_EXTENSION, *PC0C_COMMON_EXTENSION;

typedef struct _C0C_COMMON_FDO_EXTENSION {
  FDO_EXTENSION
} C0C_COMMON_FDO_EXTENSION, *PC0C_COMMON_FDO_EXTENSION;

typedef struct _C0C_IRP_QUEUE {
  PIRP                    pCurrent;
  LIST_ENTRY              queue;
#if DBG
  BOOLEAN                 started;
#endif /* DBG */
} C0C_IRP_QUEUE, *PC0C_IRP_QUEUE;

typedef struct _C0C_RAW_DATA {
  UCHAR                   size;
  UCHAR                   data[3 + sizeof(ULONG)];
} C0C_RAW_DATA, *PC0C_RAW_DATA;

typedef struct _C0C_BUFFER {
  PUCHAR                  pBase;
  PUCHAR                  pBusy;
  PUCHAR                  pFree;
  PUCHAR                  pEnd;
  SIZE_T                  busy;
  SIZE_T                  limit;
  SIZE_T                  size80;
  C0C_RAW_DATA            insertData;
} C0C_BUFFER, *PC0C_BUFFER;

#define C0C_BUFFER_BUSY(pBuf) \
  ((SIZE_T)((pBuf)->busy + (pBuf)->insertData.size))

#define C0C_BUFFER_SIZE(pBuf) \
  ((SIZE_T)((pBuf)->pEnd - (pBuf)->pBase))

typedef struct _C0C_TX_BUFFER {
  PUCHAR                  pBase;
  PUCHAR                  pBusy;
  PUCHAR                  pFree;
  PUCHAR                  pEnd;
  SIZE_T                  busy;
  UCHAR                   leastBuf[14 + 1];  /* transmitter holding and shift registers */
} C0C_TX_BUFFER, *PC0C_TX_BUFFER;

#define C0C_TX_BUFFER_EMPTY(pTxBuf) \
  (!(pTxBuf)->busy)

#define C0C_TX_BUFFER_THR_EMPTY(pTxBuf) \
  ((pTxBuf)->busy <= 1)

#define C0C_TX_BUFFER_SIZE(pTxBuf) \
  ((SIZE_T)((pTxBuf)->pEnd - (pTxBuf)->pBase))

struct _C0C_FDOPORT_EXTENSION;
struct _C0C_ADAPTIVE_DELAY;

typedef struct _C0C_PIN_OUTS {
  struct {
    UCHAR positive;
    UCHAR negative;
  } remote, local;
} C0C_PIN_OUTS, *PC0C_PIN_OUTS;

typedef struct _C0C_IO_PORT {

  struct _C0C_FDOPORT_EXTENSION *pDevExt;

  PDEVICE_OBJECT          pPhDevObj;
  struct _C0C_IO_PORT     *pIoPortRemote;
  PKSPIN_LOCK             pIoLock;

  #define C0C_QUEUE_READ  0
  #define C0C_QUEUE_WRITE 1
  #define C0C_QUEUE_WAIT  2
  #define C0C_QUEUE_CLOSE 3

  #define C0C_QUEUE_SIZE  4

  C0C_IRP_QUEUE           irpQueues[C0C_QUEUE_SIZE];

  KTIMER                  timerReadTotal;
  KDPC                    timerReadTotalDpc;
  ULONG                   addRTTO;

  KTIMER                  timerReadInterval;
  KDPC                    timerReadIntervalDpc;
  LARGE_INTEGER           timeoutInterval;
  ULONG                   addRITO;

  KTIMER                  timerWriteTotal;
  KDPC                    timerWriteTotalDpc;

  KTIMER                  timerClose;
  KDPC                    timerCloseDpc;

  SERIAL_BAUD_RATE        baudRate;
  SERIAL_LINE_CONTROL     lineControl;
  SERIAL_TIMEOUTS         timeouts;

  struct _C0C_ADAPTIVE_DELAY *pWriteDelay;

  #define C0C_PIN_OUTS_RTS  0
  #define C0C_PIN_OUTS_DTR  1
  #define C0C_PIN_OUTS_OUT1 2
  #define C0C_PIN_OUTS_OUT2 3
  #define C0C_PIN_OUTS_OPEN 4

  C0C_PIN_OUTS            pinOuts[5];

  SERIAL_HANDFLOW         handFlow;
  SERIAL_CHARS            specialChars;

  LONG                    xoffCounter;
  ULONG                   errors;
  ULONG                   amountInWriteQueue;
  ULONG                   waitMask;
  ULONG                   eventMask;
  ULONG                   insertMask;
  UCHAR                   escapeChar;
  SERIALPERF_STATS        perfStats;

  #define C0C_MSB_CTS     0x10
  #define C0C_MSB_DSR     0x20
  #define C0C_MSB_RING    0x40
  #define C0C_MSB_RLSD    0x80

  UCHAR                   modemStatus;

  #define C0C_MCR_DTR     0x01
  #define C0C_MCR_RTS     0x02
  #define C0C_MCR_OUT1    0x04
  #define C0C_MCR_OUT2    0x08
  #define C0C_MCR_LOOP    0x10
  #define C0C_MCR_OPEN    0x80
  #define C0C_MCR_MASK    ((UCHAR)~(C0C_MCR_OPEN))

  UCHAR                   modemControl;

  C0C_BUFFER              readBuf;
  C0C_TX_BUFFER           txBuf;

  ULONG                   brokeCharsProbability;
  short                   brokeChars;  /* number of subsequent chars that should be broken */
  SIZE_T                  brokeIdleChars;

  short                   sendXonXoff;
  ULONG                   writeHolding;
  ULONG                   writeHoldingRemote;
  BOOLEAN                 sendBreak;
  BOOLEAN                 rcvdBreak;
  BOOLEAN                 tryWrite;

  BOOLEAN                 isOpen;
  BOOLEAN                 emuOverrun;
  BOOLEAN                 plugInMode;
  BOOLEAN                 exclusiveMode;
  BOOLEAN                 allDataBits;
  BOOLEAN                 isComClass;
} C0C_IO_PORT, *PC0C_IO_PORT;

#define FDO_PORT_TO_IO_PORT(pDevObj) \
    (((PC0C_FDOPORT_EXTENSION)((pDevObj)->DeviceExtension))->pIoPortLocal)

typedef struct _C0C_PDOPORT_EXTENSION {
  COMMON_EXTENSION

  struct _C0C_FDOBUS_EXTENSION *pBusExt;

  PC0C_IO_PORT            pIoPortLocal;
} C0C_PDOPORT_EXTENSION, *PC0C_PDOPORT_EXTENSION;

typedef struct _C0C_FDOPORT_EXTENSION {
  FDO_EXTENSION

  PC0C_IO_PORT            pIoPortLocal;

  UNICODE_STRING          ntDeviceName;
  UNICODE_STRING          win32DeviceName;
  UNICODE_STRING          symbolicLinkName;

  #define C0C_SHOW_PORTNAME   0x01
  #define C0C_SHOW_SYMLINK    0x02
  #define C0C_SHOW_DEVICEMAP  0x04
  #define C0C_SHOW_INTERFACE  0x08
  #define C0C_SHOW_WMIREG     0x10

  UCHAR                   hide;

  #define C0C_SHOW_SHOWN      0x80

  UCHAR                   shown;

  LONG                    openCount;

} C0C_FDOPORT_EXTENSION, *PC0C_FDOPORT_EXTENSION;

typedef struct _C0C_CHILD {
  PC0C_PDOPORT_EXTENSION  pDevExt;
  C0C_IO_PORT             ioPort;
} C0C_CHILD, *PC0C_CHILD;

typedef struct _C0C_FDOBUS_EXTENSION {
  FDO_EXTENSION

  LIST_ENTRY              listEntry;
  KSPIN_LOCK              ioLock;
  C0C_CHILD               childs[2];
  ULONG                   portNum;
} C0C_FDOBUS_EXTENSION, *PC0C_FDOBUS_EXTENSION;

typedef struct _C0C_GLOBAL {
  LIST_ENTRY listFdoBus;
  KSPIN_LOCK listFdoBusLock;
  PDRIVER_OBJECT pDrvObj;
  UNICODE_STRING registryPath;
} C0C_GLOBAL;

extern C0C_GLOBAL c0cGlobal;

DRIVER_UNLOAD c0cUnload;
DRIVER_ADD_DEVICE c0cAddDevice;

__drv_dispatchType(IRP_MJ_CREATE)                  DRIVER_DISPATCH c0cOpen;
__drv_dispatchType(IRP_MJ_CLOSE)                   DRIVER_DISPATCH c0cClose;
__drv_dispatchType(IRP_MJ_CLEANUP)                 DRIVER_DISPATCH c0cCleanup;
__drv_dispatchType(IRP_MJ_FLUSH_BUFFERS)
__drv_dispatchType(IRP_MJ_WRITE)                   DRIVER_DISPATCH c0cWrite;
__drv_dispatchType(IRP_MJ_READ)                    DRIVER_DISPATCH c0cRead;
__drv_dispatchType(IRP_MJ_DEVICE_CONTROL)          DRIVER_DISPATCH c0cIoControl;
__drv_dispatchType(IRP_MJ_INTERNAL_DEVICE_CONTROL) DRIVER_DISPATCH c0cInternalIoControl;
__drv_dispatchType(IRP_MJ_QUERY_INFORMATION)
__drv_dispatchType(IRP_MJ_SET_INFORMATION)         DRIVER_DISPATCH c0cFileInformation;
__drv_dispatchType(IRP_MJ_SYSTEM_CONTROL)          DRIVER_DISPATCH c0cSystemControlDispatch;
__drv_dispatchType(IRP_MJ_PNP)                     DRIVER_DISPATCH c0cPnpDispatch;
__drv_dispatchType(IRP_MJ_POWER)                   DRIVER_DISPATCH c0cPowerDispatch;

VOID RemoveFdoPort(IN PC0C_FDOPORT_EXTENSION pDevExt);
VOID RemoveFdoBus(IN PC0C_FDOBUS_EXTENSION pDevExt);

typedef NTSTATUS (*PC0C_FDOPORT_START_ROUTINE)(
    IN PC0C_IO_PORT pIoPort,
    IN PLIST_ENTRY pQueueToComplete);

VOID ShiftQueue(PC0C_IRP_QUEUE pQueue);

NTSTATUS FdoPortStartIrp(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN UCHAR iQueue,
    IN PC0C_FDOPORT_START_ROUTINE pStartRoutine);

VOID CompleteIrp(PIRP pIrp, NTSTATUS status, PLIST_ENTRY pQueueToComplete);
VOID CancelQueue(PC0C_IRP_QUEUE pQueue, PLIST_ENTRY pQueueToComplete);
VOID FdoPortCancelQueues(IN PC0C_IO_PORT pIoPort);
VOID FdoPortCompleteQueue(IN PLIST_ENTRY pQueueToComplete);

NTSTATUS FdoPortImmediateChar(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack);

NTSTATUS FdoPortXoffCounter(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack);

NTSTATUS FdoPortWaitOnMask(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack);

NTSTATUS FdoPortSetWaitMask(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack);

NTSTATUS FdoPortGetWaitMask(
    IN PC0C_IO_PORT pIoPort,
    IN PIRP pIrp,
    IN PIO_STACK_LOCATION pIrpStack);

VOID WaitComplete(
    IN PC0C_IO_PORT pIoPort,
    PLIST_ENTRY pQueueToComplete);

typedef struct _C0C_IRP_STATE {

#define C0C_IRP_FLAG_IN_QUEUE          0x01
#define C0C_IRP_FLAG_IS_CURRENT        0x02
#define C0C_IRP_FLAG_WAIT_ONE          0x04
#define C0C_IRP_FLAG_INTERVAL_TIMEOUT  0x08
#define C0C_IRP_FLAG_EXPIRED           0x10

  UCHAR                   flags;
  UCHAR                   iQueue;
} C0C_IRP_STATE, *PC0C_IRP_STATE;

#define GetIrpState(pIrp)                ((PC0C_IRP_STATE)&(pIrp)->Tail.Overlay.DriverContext[0])

ULONG GetWriteLength(IN PIRP pIrp);

#define C0C_IO_TYPE_CLOSE_COMPLETE     2
#define C0C_IO_TYPE_WAIT_COMPLETE      3
#define C0C_IO_TYPE_INSERT             4

NTSTATUS FdoPortIo(
    short ioType,
    PVOID pParam,
    PC0C_IO_PORT pIoPort,
    PC0C_IRP_QUEUE pQueue,
    PLIST_ENTRY pQueueToComplete);

NTSTATUS ReadWrite(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN startRead,
    PC0C_IO_PORT pIoPortWrite,
    BOOLEAN startWrite,
    PLIST_ENTRY pQueueToComplete);

VOID SetModemStatus(
    IN PC0C_IO_PORT pIoPort,
    IN UCHAR bits,
    IN UCHAR mask,
    PLIST_ENTRY pQueueToComplete);

VOID SetModemControl(
    IN PC0C_IO_PORT pIoPort,
    IN UCHAR bits,
    IN UCHAR mask,
    PLIST_ENTRY pQueueToComplete);

VOID PinMap(
    IN PC0C_IO_PORT pIoPort,
    IN ULONG pinCTS,
    IN ULONG pinDSR,
    IN ULONG pinDCD,
    IN ULONG pinRI);

VOID InsertLsrMst(
    PC0C_IO_PORT pIoPortRead,
    BOOLEAN isMST,
    UCHAR value,
    PLIST_ENTRY pQueueToComplete);

VOID InsertRemoteBr(
    PC0C_IO_PORT pIoPortRead,
    PLIST_ENTRY pQueueToComplete);

VOID InsertRemoteLc(
    PC0C_IO_PORT pIoPortRead,
    PLIST_ENTRY pQueueToComplete);

#define C0C_TAG 'c0c'
#define C0C_ALLOCATE_POOL(PoolType, NumberOfBytes) \
    ExAllocatePoolWithTag(PoolType, NumberOfBytes, C0C_TAG)
#define C0C_ALLOCATE_POOL_WITH_QUOTA(PoolType, NumberOfBytes) \
    ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, C0C_TAG)
#define C0C_FREE_POOL(P) \
    ExFreePool(P) /*ExFreePoolWithTag(P, C0C_TAG)*/

#endif /* _C0C_COM0COM_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/sys/showport.h

/*
 * $Id: showport.h,v 1.2 2008/05/04 09:51:45 vfrolov Exp $
 *
 * Copyright (c) 2007-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: showport.h,v $
 * Revision 1.2  2008/05/04 09:51:45  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.1  2007/06/01 16:22:40  vfrolov
 * Implemented plug-in and exclusive modes
 *
 */

#ifndef _C0C_SHOWPORT_H_
#define _C0C_SHOWPORT_H_

BOOLEAN HidePortName(IN PC0C_FDOPORT_EXTENSION pDevExt);
BOOLEAN HidePort(IN PC0C_FDOPORT_EXTENSION pDevExt);
BOOLEAN ShowPort(IN PC0C_FDOPORT_EXTENSION pDevExt);
VOID SetHiddenMode(IN PC0C_FDOPORT_EXTENSION pDevExt, ULONG hiddenMode);

#endif /* _C0C_SHOWPORT_H_ */


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/portprms.h

/*
 * $Id: portprms.h,v 1.2 2009/01/12 13:04:07 vfrolov Exp $
 *
 * Copyright (c) 2007-2009 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: portprms.h,v $
 * Revision 1.2  2009/01/12 13:04:07  vfrolov
 * Added red painting InUse portnames
 *
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 */

#pragma once

namespace SetupApp {
  using namespace System;
  using namespace System::Collections::Generic;

  ref class PortParams : public Dictionary<String ^, String ^> {
    public:
      PortParams() {}
      PortParams(String ^str);
  };

  ref class PortPair {
    public:
      PortPair() { ports = gcnew array<PortParams ^>{gcnew PortParams, gcnew PortParams}; }

      PortParams ^operator [](int i) { return ports[i]; }
      void Set(int i, PortParams ^port) { ports[i] = port; }
      bool IsEmpty() { return ports[0]->Count == 0 && ports[1]->Count == 0; }

    private:
      array<PortParams ^> ^ports;
  };

  ref class PortPairs : public Dictionary<String ^, PortPair ^> {
    public:
      PortPairs(System::Windows::Forms::Control ^_parent) : parent(_parent) {}
      void Init();
      String ^AddPair();
      void RemovePair(String ^keyPair);
      void ChangePair(String ^keyPair, PortPair ^pairChanges);
      bool IsValidName(String ^name);

    private:
      String ^ParseLine(String ^line);
      void LoadBusyNames();

      array<String ^> ^busyNames;
      System::Windows::Forms::Control ^parent;
  };
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/stdafx.h

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
#pragma once

// TODO: reference additional headers your program requires here


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/pinmap.cpp

/*
 * $Id: pinmap.cpp,v 1.3 2008/07/10 11:18:27 vfrolov Exp $
 *
 * Copyright (c) 2007-2008 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: pinmap.cpp,v $
 * Revision 1.3  2008/07/10 11:18:27  vfrolov
 * Added noise representation
 *
 * Revision 1.2  2008/04/08 06:52:12  vfrolov
 * Added pin OUT2
 *
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 */

#include "stdafx.h"
#include "portprms.h"
#include "pinmap.h"

namespace SetupApp {
  using namespace System;

  ref class PinSource {
    public:

      PinSource(String ^_source, bool _invert) : source(_source), invert(_invert) {}
      PinSource(PinSource ^pin) : source(pin->source), invert(pin->invert) {}
      void Invert() { invert = !invert; }
      bool IsEqual(PinSource ^pin) {
        return source == pin->source && invert == pin->invert;
      }

      String ^source;
      bool invert;
  };

  ref class Pin {
    public:

      Pin(int c, int l, bool _isFixed, int ic)
        : C(c),
          L(l),
          IC(ic),
          isFixed(_isFixed),
          isNoise(false),
          source(nullptr) {}

      void Link(PinSource ^_source) { source = gcnew PinSource(_source); }
      bool IsSource() { return source == nullptr; }
      void Invert() {
        if (source != nullptr)
          source->Invert();
      }

      int C;
      int L;
      int IC;
      bool isFixed;
      bool isNoise;

      PinSource ^source;
  };
}

using namespace SetupApp;
using namespace System;
using namespace System::Drawing;
using namespace System::Windows::Forms;
using namespace System::Collections::Generic;

#define NUM_LINES          11
#define NUM_MIDDLE_SRCS    1
#define MAX_DIFF           7

#define UL                 0
#define DL                 (NUM_LINES - 1)

#define NUM_COLUMS         ((MAX_DIFF + 1)*2 + NUM_MIDDLE_SRCS)
#define LC                 0
#define RC                 (NUM_COLUMS - 1)
#define MC                 (NUM_COLUMS/2)

#define PIN_SIZE           9
#define INVERT_SIZE        14

PinMap::PinMap()
{
  MouseInit();

  pinsOrg = gcnew Dictionary<String ^, PinSource ^>;
  pins = gcnew Dictionary<String ^, Pin ^>;

  int C, L, IC;

  C = LC;
  L = UL;
  IC = 0;
  pins["RX(A)"]   = gcnew Pin(C, L++, true,  0);
  pins["TX(A)"]   = gcnew Pin(C, L++, true,  0);
  pins["DTR(A)"]  = gcnew Pin(C, L++, false, IC++);
  pins["DSR(A)"]  = gcnew Pin(C, L++, false, 0);
  pins["DCD(A)"]  = gcnew Pin(C, L++, false, 0);
  pins["RTS(A)"]  = gcnew Pin(C, L++, false, IC++);
  pins["CTS(A)"]  = gcnew Pin(C, L++, false, 0);
  pins["RI(A)"]   = gcnew Pin(C, L++, false, 0);
  pins["OUT1(A)"] = gcnew Pin(C, L++, false, IC++);
  pins["OUT2(A)"] = gcnew Pin(C, L++, false, IC++);
  pins["OPEN(A)"] = gcnew Pin(C, L++, false, IC++);

  C = RC;
  L = UL;
  IC = 0;
  pins["RX(B)"]   = gcnew Pin(C, L++, true,  0);
  pins["TX(B)"]   = gcnew Pin(C, L++, true,  0);
  pins["DTR(B)"]  = gcnew Pin(C, L++, false, IC++);
  pins["DSR(B)"]  = gcnew Pin(C, L++, false, 0);
  pins["DCD(B)"]  = gcnew Pin(C, L++, false, 0);
  pins["RTS(B)"]  = gcnew Pin(C, L++, false, IC++);
  pins["CTS(B)"]  = gcnew Pin(C, L++, false, 0);
  pins["RI(B)"]   = gcnew Pin(C, L++, false, 0);
  pins["OUT1(B)"] = gcnew Pin(C, L++, false, IC++);
  pins["OUT2(B)"] = gcnew Pin(C, L++, false, IC++);
  pins["OPEN(B)"] = gcnew Pin(C, L++, false, IC++);

  pins["ON"]      = gcnew Pin(MC, DL, false, 0);

  pins["RX(A)"]  -> Link(gcnew PinSource("TX(B)",  false));
  pins["RX(B)"]  -> Link(gcnew PinSource("TX(A)",  false));

  Init(nullptr);
}

void PinMap::Link(String ^pinName, String ^source, bool invert)
{
  pinsOrg[pinName] = gcnew PinSource(source, invert);
  pins[pinName] -> Link(pinsOrg[pinName]);
}

void PinMap::Init(PortPair ^pair)
{
  MouseInit();

  for (int i = 0 ; i < 2 ; i++) {
    String ^tx = (i == 0) ? "TX(A)" : "TX(B)";

    if (pins->ContainsKey(tx)) {
      if (pair != nullptr &&
          pair[i] != nullptr &&
          pair[i]->ContainsKey("emunoise") &&
          pair[i]["emunoise"]->IndexOfAny((gcnew String("123456789"))->ToCharArray()) != -1)
      {
        pins[tx]->isNoise = true;
      } else {
        pins[tx]->isNoise = false;
      }
    }
  }

  array<String ^> ^dstPins = {"DSR", "DCD", "CTS", "RI"};

  for each (String ^dst in dstPins) {
    for (int i = 0 ; i < 2 ; i++) {
      if (pair == nullptr ||
          pair[i] == nullptr ||
          !pair[i]->ContainsKey(dst->ToLower()))
      {
        Link(String::Format("{0}{1}", dst, (i == 0) ? "(A)" : "(B)"), "", false);
        continue;
      }

      String ^src = pair[i][dst->ToLower()];

      bool invert = false;

      if (src->StartsWith("!")) {
        invert = true;
        src = src->Substring(1);
      }

      String ^srcSuffix = "";

      if (src->StartsWith("L")) {
        srcSuffix = (i == 0) ? "(A)" : "(B)";
        src = src->Substring(1);
      }
      else
      if (src->StartsWith("R")) {
        srcSuffix = (i == 1) ? "(A)" : "(B)";
        src = src->Substring(1);
      }

      Link(String::Format("{0}{1}", dst, (i == 0) ? "(A)" : "(B)"),
           String::Format("{0}{1}", src, srcSuffix), invert);
    }
  }
}

void PinMap::GetChanges(PortPair ^pair)
{
  for each (KeyValuePair<String ^, Pin ^> kvp in pins) {
    Pin ^pin = kvp.Value;

    if (!pin->isFixed && !pin->IsSource() &&
        (!pinsOrg->ContainsKey(kvp.Key) || !pin->source->IsEqual(pinsOrg[kvp.Key])))
    {
      array<Char> ^separator = {'('};

      array<String ^> ^fields;

      fields = kvp.Key->Split(separator);

      if (fields->Length != 2)
        continue;

      String ^dst = fields[0];
      int iDst;

      if (fields[1]->StartsWith("A"))
        iDst = 0;
      else
      if (fields[1]->StartsWith("B"))
        iDst = 1;
      else
        continue;

      String ^src = pin->source->invert ? "!" : "";

      fields = pin->source->source->Split(separator);

      if (fields->Length > 1) {
        if (fields[1]->StartsWith("A")) {
          src += (iDst == 0) ? "l" : "r";
        }
        else
        if (fields[1]->StartsWith("B")) {
          src += (iDst == 1) ? "l" : "r";
        }
      }

      src += fields[0];

      pair[iDst][dst->ToLower()] = src->ToUpper();
    }
  }
}

void PinMap::Paint(PaintEventArgs ^e, Control ^control)
{
  Pen ^pOrg = gcnew Pen(Color::Black, 1);
  pOrg->EndCap = Drawing2D::LineCap::ArrowAnchor;

  Pen ^pNew = gcnew Pen(Color::Blue, 1);
  pNew->EndCap = Drawing2D::LineCap::ArrowAnchor;

  Pen ^p = pOrg;

  SolidBrush ^b = gcnew SolidBrush(Color::Black);
  SolidBrush ^bS = gcnew SolidBrush(Color::Red);
  SolidBrush ^bD = gcnew SolidBrush(Color::Green);

  int width = control->ClientSize.Width;
  int height = control->ClientSize.Height;

  int stepC = width/NUM_COLUMS;
  int stepL = height/NUM_LINES;
  int xCorrection = (width - NUM_COLUMS*stepC)/2;
  int yCorrection = (height - NUM_LINES*stepL)/2;

  for each (KeyValuePair<String ^, Pin ^> kvp in pins) {
    Pin ^pin = kvp.Value;
    int x, y;

    x = xCorrection + stepC/2 + pin->C * stepC;
    y = yCorrection + stepL/2 + pin->L * stepL;

    int pinSize = PIN_SIZE;

    if (!pin->isFixed &&
        (!pins->ContainsKey(selected) || pins[selected]->IsSource() != pin->IsSource()) &&
        me.X > x - stepC && me.X < x + stepC &&
        me.Y > y - stepL/2 && me.Y < y + stepL/2)
    {
      if (down) {
        mb.X = x;
        mb.Y = y;
        selected = kvp.Key;
      } else {
        pinSize += 4;
      }

      if (doubleClick)
        pin->Invert();

      if (up && pins->ContainsKey(selected)) {
        String ^src, ^dst;

        if (pin->IsSource()) {
          src = kvp.Key;
          dst = selected;
        } else {
          src = selected;
          dst = kvp.Key;
        }

        if (pinsOrg[dst]->source == src)
          pins[dst]->Link(pinsOrg[dst]);
        else
          pins[dst]->Link(gcnew PinSource(src, false));
      }
    }

    Brush ^bE = b;

    if (!pin->isFixed) {
      if (pin->IsSource())
        bE = bS;
      else
        bE = bD;
    }

    e->Graphics->FillEllipse(bE, x - pinSize/2, y - pinSize/2, pinSize, pinSize);

    if (pin->C == LC) {
      if (pin->IsSource())
        e->Graphics->DrawLine(p, 0, y, x - PIN_SIZE/2, y);
      else
        e->Graphics->DrawLine(p, x - PIN_SIZE/2, y, 0, y);
    }
    else
    if (pin->C == RC) {
      if (pin->IsSource())
        e->Graphics->DrawLine(p, width, y, x + PIN_SIZE/2, y);
      else
        e->Graphics->DrawLine(p, x + PIN_SIZE/2, y, width, y);
    }
    else
    if (pin->L == UL) {
      if (pin->IsSource())
        e->Graphics->DrawLine(p, x, 0, x, y - PIN_SIZE/2);
      else
        e->Graphics->DrawLine(p, x, y - PIN_SIZE/2, x, 0);
    }
    else
    if (pin->L == DL) {
      if (pin->IsSource())
        e->Graphics->DrawLine(p, x, height, x, y + PIN_SIZE/2);
      else
        e->Graphics->DrawLine(p, x, y + PIN_SIZE/2, x, height);
    }
  }

  for each (KeyValuePair<String ^, Pin ^> kvp in pins) {
    Pin ^pin = kvp.Value;

    if (!pin->source)
      continue;

    String ^source = pin->source->source;

    if (pins->ContainsKey(source)) {
      Pin ^pinS = pins[source];

      int xS = xCorrection + stepC/2 + pinS->C * stepC;
      int yS = yCorrection + stepL/2 + pinS->L * stepL;

      array<Point> ^line = gcnew array<Point>(4);

      if (pinS->C == LC) {
        line[0].X = xS + PIN_SIZE/2;
        line[0].Y = yS;
      }
      else
      if (pinS->C == RC) {
        line[0].X = xS - PIN_SIZE/2;
        line[0].Y = yS;
      }
      else
      if (pinS->L == UL) {
        line[0].X = xS;
        line[0].Y = yS + PIN_SIZE/2;
      }
      else
      if (pinS->L == DL) {
        line[0].X = xS;
        line[0].Y = yS - PIN_SIZE/2;
      }
      else {
        line[0].X = xS;
        line[0].Y = yS;
      }

      int xD = xCorrection + stepC/2 + pin->C * stepC;
      int yD = yCorrection + stepL/2 + pin->L * stepL;

      Pen ^pCur = (pin->isFixed || pin->source->IsEqual(pinsOrg[kvp.Key])) ? pOrg : pNew;

      if (pin->C == LC) {
        line[3].X = xD + PIN_SIZE/2;
        line[3].Y = yD;

        if (pin->source->invert) {
          line[3].X += INVERT_SIZE/2;

          array<Point> ^poly = {
            Point(line[3].X, line[3].Y - INVERT_SIZE/2),
            Point(line[3].X, line[3].Y + INVERT_SIZE/2),
            Point(line[3].X - INVERT_SIZE/2, line[3].Y),
          };

          e->Graphics->DrawPolygon(pCur, poly);
        }
      }
      else
      if (pin->C == RC) {
        line[3].X = xD - PIN_SIZE/2;
        line[3].Y = yD;

        if (pin->source->invert) {
          line[3].X -= INVERT_SIZE/2;

          array<Point> ^poly = {
            Point(line[3].X, line[3].Y - INVERT_SIZE/2),
            Point(line[3].X, line[3].Y + INVERT_SIZE/2),
            Point(line[3].X + INVERT_SIZE/2, line[3].Y),
          };

          e->Graphics->DrawPolygon(pCur, poly);
        }
      }
      else
      if (pin->L == UL) {
        line[3].X = xD;
        line[3].Y = yD + PIN_SIZE/2;

        if (pin->source->invert) {
          line[3].Y += INVERT_SIZE/2;

          array<Point> ^poly = {
            Point(line[3].X - INVERT_SIZE/2, line[3].Y),
            Point(line[3].X + INVERT_SIZE/2, line[3].Y),
            Point(line[3].X, line[3].Y - INVERT_SIZE/2),
          };

          e->Graphics->DrawPolygon(pCur, poly);
        }
      }
      else
      if (pin->L == DL) {
        line[3].X = xD;
        line[3].Y = yD - PIN_SIZE/2;

        if (pin->source->invert) {
          line[3].Y -= INVERT_SIZE/2;

          array<Point> ^poly = {
            Point(line[3].X - INVERT_SIZE/2, line[3].Y),
            Point(line[3].X + INVERT_SIZE/2, line[3].Y),
            Point(line[3].X, line[3].Y + INVERT_SIZE/2),
          };

          e->Graphics->DrawPolygon(pCur, poly);
        }
      }
      else {
        line[3].X = xD;
        line[3].Y = yD;
      }

      line[1].Y = line[0].Y;
      line[2].Y = line[3].Y;

      int diffX = (pin->L - pinS->L) * stepC;
      if (diffX < 0)
        diffX = -diffX;

      if (pinS->C != pin->C) {
        if (pinS->C == LC) {
          line[1].X = xCorrection + (NUM_COLUMS*stepC)/2 - stepC/2;
          line[2].X = line[1].X + diffX;
        }
        else
        if (pinS->C == RC) {
          line[1].X = xCorrection + (NUM_COLUMS*stepC)/2 + stepC/2;
          line[2].X = line[1].X - diffX;
        }
        else {
          line[1].X = line[0].X;
          line[1].Y = line[2].Y;
          line[2].X = line[3].X;
        }
      } else {
        if (pinS->C == LC) {
          line[1].X = line[0].X + (stepC + pinS->IC * stepC);
          line[2].X = line[1].X;
        }
        else
        if (pinS->C == RC) {
          line[1].X = xS - (stepC + pinS->IC * stepC);
          line[2].X = line[1].X;
        }
        else {
          line[1].X = line[0].X;
          line[2].X = line[3].X;
        }
      }

      e->Graphics->DrawLines(pCur, line);

      if (pinS->isNoise) {
        Pen ^pNoise = gcnew Pen(pCur->Color, 3);

        pNoise->EndCap = pCur->EndCap;
        pNoise->DashStyle = Drawing2D::DashStyle::Dot;

        e->Graphics->DrawLines(pNoise, line);
      }
    }
  }

  down = false;
  doubleClick = false;

  if (up) {
    selected = "";
    up = false;
  }

  if (pins->ContainsKey(selected)) {
    p->EndCap = Drawing2D::LineCap::NoAnchor;
    e->Graphics->DrawLine(p, mb.X, mb.Y, me.X, me.Y);
  }
}

void PinMap::MouseInit()
{
  mb = me = Point(0, 0);
  selected = "";
  down = up = doubleClick = false;
}

void PinMap::MouseDown(MouseEventArgs ^e)
{
  down = true;
  me = Point(e->X, e->Y);
}

void PinMap::MouseMove(MouseEventArgs ^e)
{
  me = Point(e->X, e->Y);
}

void PinMap::MouseUp(MouseEventArgs ^e)
{
  up = true;
  me = Point(e->X, e->Y);
}

void PinMap::MouseDoubleClick(MouseEventArgs ^e)
{
  MouseInit();
  doubleClick = true;
  me = Point(e->X, e->Y);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/app.rc

// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon placed first or with lowest ID value becomes application icon

LANGUAGE 25, 1
#pragma code_page(1251)
1           ICON         "com0com.ico"

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE  
BEGIN
    "resource.h\0"
    "\0"
END

2 TEXTINCLUDE  
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE  
BEGIN
    "\0"
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/Form1.resx

<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="PortNameB.Location" type="System.Drawing.Point, System.Drawing">
    <value>361, 12</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="PortNameB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="PortNameB.Size" type="System.Drawing.Size, System.Drawing">
    <value>76, 20</value>
  </data>
  <assembly alias="mscorlib" name="mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="PortNameB.TabIndex" type="System.Int32, mscorlib">
    <value>20</value>
  </data>
  <data name="PortNameB.TextAlign" type="System.Windows.Forms.HorizontalAlignment, System.Windows.Forms">
    <value>Right</value>
  </data>
  <metadata name="toolTip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <data name="PortNameB.ToolTip" xml:space="preserve">
    <value>Port name.
The name is red if it's already in use by other device.
Enter '-' to reset the name to the default.</value>
  </data>
  <data name="&gt;&gt;PortNameB.Name" xml:space="preserve">
    <value>PortNameB</value>
  </data>
  <data name="&gt;&gt;PortNameB.Type" xml:space="preserve">
    <value>System.Windows.Forms.TextBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;PortNameB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;PortNameB.ZOrder" xml:space="preserve">
    <value>39</value>
  </data>
  <data name="PortNameA.Location" type="System.Drawing.Point, System.Drawing">
    <value>175, 12</value>
  </data>
  <data name="PortNameA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="PortNameA.Size" type="System.Drawing.Size, System.Drawing">
    <value>76, 20</value>
  </data>
  <data name="PortNameA.TabIndex" type="System.Int32, mscorlib">
    <value>19</value>
  </data>
  <data name="PortNameA.ToolTip" xml:space="preserve">
    <value>Port name.
The name is red if it's already in use by other device.
Enter '-' to reset the name to the default.</value>
  </data>
  <data name="&gt;&gt;PortNameA.Name" xml:space="preserve">
    <value>PortNameA</value>
  </data>
  <data name="&gt;&gt;PortNameA.Type" xml:space="preserve">
    <value>System.Windows.Forms.TextBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;PortNameA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;PortNameA.ZOrder" xml:space="preserve">
    <value>40</value>
  </data>
  <data name="UsePortsClassB.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="UsePortsClassB.Location" type="System.Drawing.Point, System.Drawing">
    <value>308, 31</value>
  </data>
  <data name="UsePortsClassB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="UsePortsClassB.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="UsePortsClassB.TabIndex" type="System.Int32, mscorlib">
    <value>58</value>
  </data>
  <data name="UsePortsClassB.Text" xml:space="preserve">
    <value>use Ports class</value>
  </data>
  <data name="UsePortsClassB.ToolTip" xml:space="preserve">
    <value>Allow Ports class installer to set
the real port name. The Ports
class installer selects the COM
port number and sets the real
port name to COM&lt;n&gt;, where
&lt;n&gt; is the selected port number.
Thereafter you will be able to
change port number.</value>
  </data>
  <data name="&gt;&gt;UsePortsClassB.Name" xml:space="preserve">
    <value>UsePortsClassB</value>
  </data>
  <data name="&gt;&gt;UsePortsClassB.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;UsePortsClassB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;UsePortsClassB.ZOrder" xml:space="preserve">
    <value>1</value>
  </data>
  <data name="UsePortsClassA.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="UsePortsClassA.Location" type="System.Drawing.Point, System.Drawing">
    <value>169, 31</value>
  </data>
  <data name="UsePortsClassA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="UsePortsClassA.RightToLeft" type="System.Windows.Forms.RightToLeft, System.Windows.Forms">
    <value>Yes</value>
  </data>
  <data name="UsePortsClassA.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="UsePortsClassA.TabIndex" type="System.Int32, mscorlib">
    <value>59</value>
  </data>
  <data name="UsePortsClassA.Text" xml:space="preserve">
    <value>use Ports class</value>
  </data>
  <data name="UsePortsClassA.ToolTip" xml:space="preserve">
    <value>Allow Ports class installer to set
the real port name. The Ports
class installer selects the COM
port number and sets the real
port name to COM&lt;n&gt;, where
&lt;n&gt; is the selected port number.
Thereafter you will be able to
change port number.</value>
  </data>
  <data name="&gt;&gt;UsePortsClassA.Name" xml:space="preserve">
    <value>UsePortsClassA</value>
  </data>
  <data name="&gt;&gt;UsePortsClassA.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;UsePortsClassA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;UsePortsClassA.ZOrder" xml:space="preserve">
    <value>0</value>
  </data>
  <data name="pinNameON.Font" type="System.Drawing.Font, System.Drawing">
    <value>Courier New, 10.2pt</value>
  </data>
  <data name="pinNameON.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameON.Location" type="System.Drawing.Point, System.Drawing">
    <value>212, 312</value>
  </data>
  <data name="pinNameON.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameON.Size" type="System.Drawing.Size, System.Drawing">
    <value>188, 16</value>
  </data>
  <data name="pinNameON.TabIndex" type="System.Int32, mscorlib">
    <value>18</value>
  </data>
  <data name="pinNameON.Text" xml:space="preserve">
    <value>ON</value>
  </data>
  <data name="pinNameON.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>TopCenter</value>
  </data>
  <data name="pinNameON.ToolTip" xml:space="preserve">
    <value>ON - logical ON.</value>
  </data>
  <data name="&gt;&gt;pinNameON.Name" xml:space="preserve">
    <value>pinNameON</value>
  </data>
  <data name="&gt;&gt;pinNameON.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameON.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameON.ZOrder" xml:space="preserve">
    <value>41</value>
  </data>
  <data name="picturePinMap.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="picturePinMap.Location" type="System.Drawing.Point, System.Drawing">
    <value>212, 133</value>
  </data>
  <data name="picturePinMap.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="picturePinMap.Size" type="System.Drawing.Size, System.Drawing">
    <value>188, 179</value>
  </data>
  <data name="picturePinMap.TabIndex" type="System.Int32, mscorlib">
    <value>15</value>
  </data>
  <data name="picturePinMap.ToolTip" xml:space="preserve">
    <value>One green pin can be wired to one red pin.
One red pin can be wired to multiple green pins.
Double click a green pin to add/remove inverter.</value>
  </data>
  <data name="&gt;&gt;picturePinMap.Name" xml:space="preserve">
    <value>picturePinMap</value>
  </data>
  <data name="&gt;&gt;picturePinMap.Type" xml:space="preserve">
    <value>System.Windows.Forms.PictureBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;picturePinMap.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;picturePinMap.ZOrder" xml:space="preserve">
    <value>42</value>
  </data>
  <data name="EmuBrB.Location" type="System.Drawing.Point, System.Drawing">
    <value>308, 47</value>
  </data>
  <data name="EmuBrB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="EmuBrB.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="EmuBrB.TabIndex" type="System.Int32, mscorlib">
    <value>28</value>
  </data>
  <data name="EmuBrB.Text" xml:space="preserve">
    <value>emulate baud rate</value>
  </data>
  <data name="EmuBrB.ToolTip" xml:space="preserve">
    <value>Enable/disable baud rate emulation
in the direction to the paired port.</value>
  </data>
  <data name="&gt;&gt;EmuBrB.Name" xml:space="preserve">
    <value>EmuBrB</value>
  </data>
  <data name="&gt;&gt;EmuBrB.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;EmuBrB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;EmuBrB.ZOrder" xml:space="preserve">
    <value>33</value>
  </data>
  <data name="EmuOverrunB.Location" type="System.Drawing.Point, System.Drawing">
    <value>308, 63</value>
  </data>
  <data name="EmuOverrunB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="EmuOverrunB.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="EmuOverrunB.TabIndex" type="System.Int32, mscorlib">
    <value>29</value>
  </data>
  <data name="EmuOverrunB.Text" xml:space="preserve">
    <value>enable buffer overrun</value>
  </data>
  <data name="EmuOverrunB.ToolTip" xml:space="preserve">
    <value>Enable/disable receive buffer overrun.</value>
  </data>
  <data name="&gt;&gt;EmuOverrunB.Name" xml:space="preserve">
    <value>EmuOverrunB</value>
  </data>
  <data name="&gt;&gt;EmuOverrunB.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;EmuOverrunB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;EmuOverrunB.ZOrder" xml:space="preserve">
    <value>32</value>
  </data>
  <data name="PlugInModeB.Location" type="System.Drawing.Point, System.Drawing">
    <value>308, 79</value>
  </data>
  <data name="PlugInModeB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="PlugInModeB.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="PlugInModeB.TabIndex" type="System.Int32, mscorlib">
    <value>30</value>
  </data>
  <data name="PlugInModeB.Text" xml:space="preserve">
    <value>enable plug-in mode</value>
  </data>
  <data name="PlugInModeB.ToolTip" xml:space="preserve">
    <value>Enable/disable plug-in mode.
The plug-in mode port is hidden and can't
be open if the paired port is not open.</value>
  </data>
  <data name="&gt;&gt;PlugInModeB.Name" xml:space="preserve">
    <value>PlugInModeB</value>
  </data>
  <data name="&gt;&gt;PlugInModeB.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;PlugInModeB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;PlugInModeB.ZOrder" xml:space="preserve">
    <value>31</value>
  </data>
  <data name="ExclusiveModeB.Location" type="System.Drawing.Point, System.Drawing">
    <value>308, 94</value>
  </data>
  <data name="ExclusiveModeB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="ExclusiveModeB.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="ExclusiveModeB.TabIndex" type="System.Int32, mscorlib">
    <value>31</value>
  </data>
  <data name="ExclusiveModeB.Text" xml:space="preserve">
    <value>enable exclusive mode</value>
  </data>
  <data name="ExclusiveModeB.ToolTip" xml:space="preserve">
    <value>Enable/disable exclusive mode.
The exclusive mode port is hidden if it is open.</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeB.Name" xml:space="preserve">
    <value>ExclusiveModeB</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeB.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeB.ZOrder" xml:space="preserve">
    <value>30</value>
  </data>
  <data name="ExclusiveModeA.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="ExclusiveModeA.Location" type="System.Drawing.Point, System.Drawing">
    <value>169, 94</value>
  </data>
  <data name="ExclusiveModeA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="ExclusiveModeA.RightToLeft" type="System.Windows.Forms.RightToLeft, System.Windows.Forms">
    <value>Yes</value>
  </data>
  <data name="ExclusiveModeA.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="ExclusiveModeA.TabIndex" type="System.Int32, mscorlib">
    <value>35</value>
  </data>
  <data name="ExclusiveModeA.Text" xml:space="preserve">
    <value>enable exclusive mode</value>
  </data>
  <data name="ExclusiveModeA.ToolTip" xml:space="preserve">
    <value>Enable/disable exclusive mode.
The exclusive mode port is hidden if it is open.</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeA.Name" xml:space="preserve">
    <value>ExclusiveModeA</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeA.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;ExclusiveModeA.ZOrder" xml:space="preserve">
    <value>26</value>
  </data>
  <data name="PlugInModeA.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="PlugInModeA.Location" type="System.Drawing.Point, System.Drawing">
    <value>169, 79</value>
  </data>
  <data name="PlugInModeA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="PlugInModeA.RightToLeft" type="System.Windows.Forms.RightToLeft, System.Windows.Forms">
    <value>Yes</value>
  </data>
  <data name="PlugInModeA.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="PlugInModeA.TabIndex" type="System.Int32, mscorlib">
    <value>34</value>
  </data>
  <data name="PlugInModeA.Text" xml:space="preserve">
    <value>enable plug-in mode</value>
  </data>
  <data name="PlugInModeA.ToolTip" xml:space="preserve">
    <value>Enable/disable plug-in mode.
The plug-in mode port is hidden and can't
be open if the paired port is not open.</value>
  </data>
  <data name="&gt;&gt;PlugInModeA.Name" xml:space="preserve">
    <value>PlugInModeA</value>
  </data>
  <data name="&gt;&gt;PlugInModeA.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;PlugInModeA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;PlugInModeA.ZOrder" xml:space="preserve">
    <value>27</value>
  </data>
  <data name="EmuOverrunA.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="EmuOverrunA.Location" type="System.Drawing.Point, System.Drawing">
    <value>169, 63</value>
  </data>
  <data name="EmuOverrunA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="EmuOverrunA.RightToLeft" type="System.Windows.Forms.RightToLeft, System.Windows.Forms">
    <value>Yes</value>
  </data>
  <data name="EmuOverrunA.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="EmuOverrunA.TabIndex" type="System.Int32, mscorlib">
    <value>33</value>
  </data>
  <data name="EmuOverrunA.Text" xml:space="preserve">
    <value>enable buffer overrun</value>
  </data>
  <data name="EmuOverrunA.ToolTip" xml:space="preserve">
    <value>Enable/disable receive buffer overrun.</value>
  </data>
  <data name="&gt;&gt;EmuOverrunA.Name" xml:space="preserve">
    <value>EmuOverrunA</value>
  </data>
  <data name="&gt;&gt;EmuOverrunA.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;EmuOverrunA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;EmuOverrunA.ZOrder" xml:space="preserve">
    <value>28</value>
  </data>
  <data name="EmuBrA.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="EmuBrA.Location" type="System.Drawing.Point, System.Drawing">
    <value>169, 47</value>
  </data>
  <data name="EmuBrA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="EmuBrA.RightToLeft" type="System.Windows.Forms.RightToLeft, System.Windows.Forms">
    <value>Yes</value>
  </data>
  <data name="EmuBrA.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="EmuBrA.TabIndex" type="System.Int32, mscorlib">
    <value>32</value>
  </data>
  <data name="EmuBrA.Text" xml:space="preserve">
    <value>emulate baud rate</value>
  </data>
  <data name="EmuBrA.ToolTip" xml:space="preserve">
    <value>Enable/disable baud rate emulation
in the direction to the paired port.</value>
  </data>
  <data name="&gt;&gt;EmuBrA.Name" xml:space="preserve">
    <value>EmuBrA</value>
  </data>
  <data name="&gt;&gt;EmuBrA.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;EmuBrA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;EmuBrA.ZOrder" xml:space="preserve">
    <value>29</value>
  </data>
  <data name="HiddenModeA.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="HiddenModeA.Location" type="System.Drawing.Point, System.Drawing">
    <value>169, 110</value>
  </data>
  <data name="HiddenModeA.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="HiddenModeA.RightToLeft" type="System.Windows.Forms.RightToLeft, System.Windows.Forms">
    <value>Yes</value>
  </data>
  <data name="HiddenModeA.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="HiddenModeA.TabIndex" type="System.Int32, mscorlib">
    <value>57</value>
  </data>
  <data name="HiddenModeA.Text" xml:space="preserve">
    <value>enable hidden mode</value>
  </data>
  <data name="HiddenModeA.ToolTip" xml:space="preserve">
    <value>Enable/disable hidden mode.
The hidden mode port is hidden as
it is possible for port enumerators.</value>
  </data>
  <data name="&gt;&gt;HiddenModeA.Name" xml:space="preserve">
    <value>HiddenModeA</value>
  </data>
  <data name="&gt;&gt;HiddenModeA.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;HiddenModeA.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;HiddenModeA.ZOrder" xml:space="preserve">
    <value>2</value>
  </data>
  <data name="HiddenModeB.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="HiddenModeB.Location" type="System.Drawing.Point, System.Drawing">
    <value>308, 110</value>
  </data>
  <data name="HiddenModeB.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="HiddenModeB.Size" type="System.Drawing.Size, System.Drawing">
    <value>135, 17</value>
  </data>
  <data name="HiddenModeB.TabIndex" type="System.Int32, mscorlib">
    <value>56</value>
  </data>
  <data name="HiddenModeB.Text" xml:space="preserve">
    <value>enable hidden mode</value>
  </data>
  <data name="HiddenModeB.ToolTip" xml:space="preserve">
    <value>Enable/disable hidden mode.
The hidden mode port is hidden as
it is possible for port enumerators.</value>
  </data>
  <data name="&gt;&gt;HiddenModeB.Name" xml:space="preserve">
    <value>HiddenModeB</value>
  </data>
  <data name="&gt;&gt;HiddenModeB.Type" xml:space="preserve">
    <value>System.Windows.Forms.CheckBox, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;HiddenModeB.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;HiddenModeB.ZOrder" xml:space="preserve">
    <value>3</value>
  </data>
  <data name="pinNameA_RX.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_RX.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 133</value>
  </data>
  <data name="pinNameA_RX.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_RX.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_RX.TabIndex" type="System.Int32, mscorlib">
    <value>36</value>
  </data>
  <data name="pinNameA_RX.Text" xml:space="preserve">
    <value>RX</value>
  </data>
  <data name="pinNameA_RX.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_RX.ToolTip" xml:space="preserve">
    <value>RX - receive data.</value>
  </data>
  <data name="&gt;&gt;pinNameA_RX.Name" xml:space="preserve">
    <value>pinNameA_RX</value>
  </data>
  <data name="&gt;&gt;pinNameA_RX.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_RX.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_RX.ZOrder" xml:space="preserve">
    <value>25</value>
  </data>
  <data name="pinNameA_DTR.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_DTR.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 165</value>
  </data>
  <data name="pinNameA_DTR.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_DTR.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_DTR.TabIndex" type="System.Int32, mscorlib">
    <value>37</value>
  </data>
  <data name="pinNameA_DTR.Text" xml:space="preserve">
    <value>DTR</value>
  </data>
  <data name="pinNameA_DTR.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_DTR.ToolTip" xml:space="preserve">
    <value>DTR - data terminal ready.</value>
  </data>
  <data name="&gt;&gt;pinNameA_DTR.Name" xml:space="preserve">
    <value>pinNameA_DTR</value>
  </data>
  <data name="&gt;&gt;pinNameA_DTR.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_DTR.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_DTR.ZOrder" xml:space="preserve">
    <value>24</value>
  </data>
  <data name="pinNameA_TX.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_TX.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 149</value>
  </data>
  <data name="pinNameA_TX.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_TX.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_TX.TabIndex" type="System.Int32, mscorlib">
    <value>38</value>
  </data>
  <data name="pinNameA_TX.Text" xml:space="preserve">
    <value>TX</value>
  </data>
  <data name="pinNameA_TX.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_TX.ToolTip" xml:space="preserve">
    <value>TX - transmit data.</value>
  </data>
  <data name="&gt;&gt;pinNameA_TX.Name" xml:space="preserve">
    <value>pinNameA_TX</value>
  </data>
  <data name="&gt;&gt;pinNameA_TX.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_TX.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_TX.ZOrder" xml:space="preserve">
    <value>23</value>
  </data>
  <data name="pinNameA_DSR.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_DSR.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 182</value>
  </data>
  <data name="pinNameA_DSR.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_DSR.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_DSR.TabIndex" type="System.Int32, mscorlib">
    <value>39</value>
  </data>
  <data name="pinNameA_DSR.Text" xml:space="preserve">
    <value>DSR</value>
  </data>
  <data name="pinNameA_DSR.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_DSR.ToolTip" xml:space="preserve">
    <value>DSR - data set ready.</value>
  </data>
  <data name="&gt;&gt;pinNameA_DSR.Name" xml:space="preserve">
    <value>pinNameA_DSR</value>
  </data>
  <data name="&gt;&gt;pinNameA_DSR.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_DSR.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_DSR.ZOrder" xml:space="preserve">
    <value>22</value>
  </data>
  <data name="pinNameA_DCD.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_DCD.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 198</value>
  </data>
  <data name="pinNameA_DCD.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_DCD.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_DCD.TabIndex" type="System.Int32, mscorlib">
    <value>40</value>
  </data>
  <data name="pinNameA_DCD.Text" xml:space="preserve">
    <value>DCD</value>
  </data>
  <data name="pinNameA_DCD.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_DCD.ToolTip" xml:space="preserve">
    <value>DCD - data carrier detect.</value>
  </data>
  <data name="&gt;&gt;pinNameA_DCD.Name" xml:space="preserve">
    <value>pinNameA_DCD</value>
  </data>
  <data name="&gt;&gt;pinNameA_DCD.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_DCD.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_DCD.ZOrder" xml:space="preserve">
    <value>21</value>
  </data>
  <data name="pinNameA_RTS.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_RTS.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 214</value>
  </data>
  <data name="pinNameA_RTS.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_RTS.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_RTS.TabIndex" type="System.Int32, mscorlib">
    <value>41</value>
  </data>
  <data name="pinNameA_RTS.Text" xml:space="preserve">
    <value>RTS</value>
  </data>
  <data name="pinNameA_RTS.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_RTS.ToolTip" xml:space="preserve">
    <value>RTS - request to send.</value>
  </data>
  <data name="&gt;&gt;pinNameA_RTS.Name" xml:space="preserve">
    <value>pinNameA_RTS</value>
  </data>
  <data name="&gt;&gt;pinNameA_RTS.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_RTS.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_RTS.ZOrder" xml:space="preserve">
    <value>20</value>
  </data>
  <data name="pinNameA_CTS.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_CTS.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 230</value>
  </data>
  <data name="pinNameA_CTS.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_CTS.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_CTS.TabIndex" type="System.Int32, mscorlib">
    <value>42</value>
  </data>
  <data name="pinNameA_CTS.Text" xml:space="preserve">
    <value>CTS</value>
  </data>
  <data name="pinNameA_CTS.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_CTS.ToolTip" xml:space="preserve">
    <value>CTS - clear to send.</value>
  </data>
  <data name="&gt;&gt;pinNameA_CTS.Name" xml:space="preserve">
    <value>pinNameA_CTS</value>
  </data>
  <data name="&gt;&gt;pinNameA_CTS.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_CTS.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_CTS.ZOrder" xml:space="preserve">
    <value>19</value>
  </data>
  <data name="pinNameA_RI.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_RI.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 247</value>
  </data>
  <data name="pinNameA_RI.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_RI.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_RI.TabIndex" type="System.Int32, mscorlib">
    <value>43</value>
  </data>
  <data name="pinNameA_RI.Text" xml:space="preserve">
    <value>RI</value>
  </data>
  <data name="pinNameA_RI.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_RI.ToolTip" xml:space="preserve">
    <value>RI - ring indicator.</value>
  </data>
  <data name="&gt;&gt;pinNameA_RI.Name" xml:space="preserve">
    <value>pinNameA_RI</value>
  </data>
  <data name="&gt;&gt;pinNameA_RI.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_RI.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_RI.ZOrder" xml:space="preserve">
    <value>18</value>
  </data>
  <data name="pinNameA_OUT1.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_OUT1.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 263</value>
  </data>
  <data name="pinNameA_OUT1.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_OUT1.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_OUT1.TabIndex" type="System.Int32, mscorlib">
    <value>44</value>
  </data>
  <data name="pinNameA_OUT1.Text" xml:space="preserve">
    <value>OUT1</value>
  </data>
  <data name="pinNameA_OUT1.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_OUT1.ToolTip" xml:space="preserve">
    <value>OUT1 - auxiliary output 1.</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT1.Name" xml:space="preserve">
    <value>pinNameA_OUT1</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT1.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT1.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT1.ZOrder" xml:space="preserve">
    <value>16</value>
  </data>
  <data name="pinNameA_OUT2.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_OUT2.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 279</value>
  </data>
  <data name="pinNameA_OUT2.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_OUT2.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_OUT2.TabIndex" type="System.Int32, mscorlib">
    <value>44</value>
  </data>
  <data name="pinNameA_OUT2.Text" xml:space="preserve">
    <value>OUT2</value>
  </data>
  <data name="pinNameA_OUT2.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_OUT2.ToolTip" xml:space="preserve">
    <value>OUT2 - auxiliary output 2.</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT2.Name" xml:space="preserve">
    <value>pinNameA_OUT2</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT2.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT2.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_OUT2.ZOrder" xml:space="preserve">
    <value>17</value>
  </data>
  <data name="pinNameA_OPEN.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameA_OPEN.Location" type="System.Drawing.Point, System.Drawing">
    <value>174, 295</value>
  </data>
  <data name="pinNameA_OPEN.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameA_OPEN.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameA_OPEN.TabIndex" type="System.Int32, mscorlib">
    <value>45</value>
  </data>
  <data name="pinNameA_OPEN.Text" xml:space="preserve">
    <value>OPEN</value>
  </data>
  <data name="pinNameA_OPEN.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleRight</value>
  </data>
  <data name="pinNameA_OPEN.ToolTip" xml:space="preserve">
    <value>OPEN - logical ON if the port is open.</value>
  </data>
  <data name="&gt;&gt;pinNameA_OPEN.Name" xml:space="preserve">
    <value>pinNameA_OPEN</value>
  </data>
  <data name="&gt;&gt;pinNameA_OPEN.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameA_OPEN.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameA_OPEN.ZOrder" xml:space="preserve">
    <value>15</value>
  </data>
  <data name="pinNameB_OPEN.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_OPEN.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 295</value>
  </data>
  <data name="pinNameB_OPEN.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_OPEN.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_OPEN.TabIndex" type="System.Int32, mscorlib">
    <value>55</value>
  </data>
  <data name="pinNameB_OPEN.Text" xml:space="preserve">
    <value>OPEN</value>
  </data>
  <data name="pinNameB_OPEN.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_OPEN.ToolTip" xml:space="preserve">
    <value>OPEN - logical ON if the port is open.</value>
  </data>
  <data name="&gt;&gt;pinNameB_OPEN.Name" xml:space="preserve">
    <value>pinNameB_OPEN</value>
  </data>
  <data name="&gt;&gt;pinNameB_OPEN.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_OPEN.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_OPEN.ZOrder" xml:space="preserve">
    <value>4</value>
  </data>
  <data name="pinNameB_OUT1.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_OUT1.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 263</value>
  </data>
  <data name="pinNameB_OUT1.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_OUT1.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_OUT1.TabIndex" type="System.Int32, mscorlib">
    <value>54</value>
  </data>
  <data name="pinNameB_OUT1.Text" xml:space="preserve">
    <value>OUT1</value>
  </data>
  <data name="pinNameB_OUT1.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_OUT1.ToolTip" xml:space="preserve">
    <value>OUT1 - auxiliary output 1.</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT1.Name" xml:space="preserve">
    <value>pinNameB_OUT1</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT1.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT1.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT1.ZOrder" xml:space="preserve">
    <value>5</value>
  </data>
  <data name="pinNameB_OUT2.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_OUT2.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 279</value>
  </data>
  <data name="pinNameB_OUT2.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_OUT2.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_OUT2.TabIndex" type="System.Int32, mscorlib">
    <value>54</value>
  </data>
  <data name="pinNameB_OUT2.Text" xml:space="preserve">
    <value>OUT2</value>
  </data>
  <data name="pinNameB_OUT2.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_OUT2.ToolTip" xml:space="preserve">
    <value>OUT2 - auxiliary output 2.</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT2.Name" xml:space="preserve">
    <value>pinNameB_OUT2</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT2.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT2.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_OUT2.ZOrder" xml:space="preserve">
    <value>6</value>
  </data>
  <data name="pinNameB_RI.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_RI.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 247</value>
  </data>
  <data name="pinNameB_RI.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_RI.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_RI.TabIndex" type="System.Int32, mscorlib">
    <value>53</value>
  </data>
  <data name="pinNameB_RI.Text" xml:space="preserve">
    <value>RI</value>
  </data>
  <data name="pinNameB_RI.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_RI.ToolTip" xml:space="preserve">
    <value>RI - ring indicator.</value>
  </data>
  <data name="&gt;&gt;pinNameB_RI.Name" xml:space="preserve">
    <value>pinNameB_RI</value>
  </data>
  <data name="&gt;&gt;pinNameB_RI.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_RI.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_RI.ZOrder" xml:space="preserve">
    <value>7</value>
  </data>
  <data name="pinNameB_CTS.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_CTS.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 230</value>
  </data>
  <data name="pinNameB_CTS.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_CTS.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_CTS.TabIndex" type="System.Int32, mscorlib">
    <value>52</value>
  </data>
  <data name="pinNameB_CTS.Text" xml:space="preserve">
    <value>CTS</value>
  </data>
  <data name="pinNameB_CTS.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_CTS.ToolTip" xml:space="preserve">
    <value>CTS - clear to send.</value>
  </data>
  <data name="&gt;&gt;pinNameB_CTS.Name" xml:space="preserve">
    <value>pinNameB_CTS</value>
  </data>
  <data name="&gt;&gt;pinNameB_CTS.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_CTS.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_CTS.ZOrder" xml:space="preserve">
    <value>8</value>
  </data>
  <data name="pinNameB_RTS.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_RTS.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 214</value>
  </data>
  <data name="pinNameB_RTS.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_RTS.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_RTS.TabIndex" type="System.Int32, mscorlib">
    <value>51</value>
  </data>
  <data name="pinNameB_RTS.Text" xml:space="preserve">
    <value>RTS</value>
  </data>
  <data name="pinNameB_RTS.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_RTS.ToolTip" xml:space="preserve">
    <value>RTS - request to send.</value>
  </data>
  <data name="&gt;&gt;pinNameB_RTS.Name" xml:space="preserve">
    <value>pinNameB_RTS</value>
  </data>
  <data name="&gt;&gt;pinNameB_RTS.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_RTS.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_RTS.ZOrder" xml:space="preserve">
    <value>9</value>
  </data>
  <data name="pinNameB_DCD.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_DCD.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 198</value>
  </data>
  <data name="pinNameB_DCD.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_DCD.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_DCD.TabIndex" type="System.Int32, mscorlib">
    <value>50</value>
  </data>
  <data name="pinNameB_DCD.Text" xml:space="preserve">
    <value>DCD</value>
  </data>
  <data name="pinNameB_DCD.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_DCD.ToolTip" xml:space="preserve">
    <value>DCD - data carrier detect.</value>
  </data>
  <data name="&gt;&gt;pinNameB_DCD.Name" xml:space="preserve">
    <value>pinNameB_DCD</value>
  </data>
  <data name="&gt;&gt;pinNameB_DCD.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_DCD.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_DCD.ZOrder" xml:space="preserve">
    <value>10</value>
  </data>
  <data name="pinNameB_DSR.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_DSR.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 182</value>
  </data>
  <data name="pinNameB_DSR.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_DSR.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_DSR.TabIndex" type="System.Int32, mscorlib">
    <value>49</value>
  </data>
  <data name="pinNameB_DSR.Text" xml:space="preserve">
    <value>DSR</value>
  </data>
  <data name="pinNameB_DSR.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_DSR.ToolTip" xml:space="preserve">
    <value>DSR - data set ready.</value>
  </data>
  <data name="&gt;&gt;pinNameB_DSR.Name" xml:space="preserve">
    <value>pinNameB_DSR</value>
  </data>
  <data name="&gt;&gt;pinNameB_DSR.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_DSR.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_DSR.ZOrder" xml:space="preserve">
    <value>11</value>
  </data>
  <data name="pinNameB_TX.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_TX.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 149</value>
  </data>
  <data name="pinNameB_TX.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_TX.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_TX.TabIndex" type="System.Int32, mscorlib">
    <value>48</value>
  </data>
  <data name="pinNameB_TX.Text" xml:space="preserve">
    <value>TX</value>
  </data>
  <data name="pinNameB_TX.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_TX.ToolTip" xml:space="preserve">
    <value>TX - transmit data.</value>
  </data>
  <data name="&gt;&gt;pinNameB_TX.Name" xml:space="preserve">
    <value>pinNameB_TX</value>
  </data>
  <data name="&gt;&gt;pinNameB_TX.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_TX.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_TX.ZOrder" xml:space="preserve">
    <value>12</value>
  </data>
  <data name="pinNameB_DTR.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_DTR.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 165</value>
  </data>
  <data name="pinNameB_DTR.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_DTR.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_DTR.TabIndex" type="System.Int32, mscorlib">
    <value>47</value>
  </data>
  <data name="pinNameB_DTR.Text" xml:space="preserve">
    <value>DTR</value>
  </data>
  <data name="pinNameB_DTR.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_DTR.ToolTip" xml:space="preserve">
    <value>DTR - data terminal ready.</value>
  </data>
  <data name="&gt;&gt;pinNameB_DTR.Name" xml:space="preserve">
    <value>pinNameB_DTR</value>
  </data>
  <data name="&gt;&gt;pinNameB_DTR.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_DTR.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_DTR.ZOrder" xml:space="preserve">
    <value>13</value>
  </data>
  <data name="pinNameB_RX.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="pinNameB_RX.Location" type="System.Drawing.Point, System.Drawing">
    <value>399, 133</value>
  </data>
  <data name="pinNameB_RX.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 0, 2, 0</value>
  </data>
  <data name="pinNameB_RX.Size" type="System.Drawing.Size, System.Drawing">
    <value>38, 16</value>
  </data>
  <data name="pinNameB_RX.TabIndex" type="System.Int32, mscorlib">
    <value>46</value>
  </data>
  <data name="pinNameB_RX.Text" xml:space="preserve">
    <value>RX</value>
  </data>
  <data name="pinNameB_RX.TextAlign" type="System.Drawing.ContentAlignment, System.Drawing">
    <value>MiddleLeft</value>
  </data>
  <data name="pinNameB_RX.ToolTip" xml:space="preserve">
    <value>RX - receive data.</value>
  </data>
  <data name="&gt;&gt;pinNameB_RX.Name" xml:space="preserve">
    <value>pinNameB_RX</value>
  </data>
  <data name="&gt;&gt;pinNameB_RX.Type" xml:space="preserve">
    <value>System.Windows.Forms.Label, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pinNameB_RX.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pinNameB_RX.ZOrder" xml:space="preserve">
    <value>14</value>
  </data>
  <data name="pairList.Location" type="System.Drawing.Point, System.Drawing">
    <value>9, 10</value>
  </data>
  <data name="pairList.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="pairList.Size" type="System.Drawing.Size, System.Drawing">
    <value>156, 318</value>
  </data>
  <data name="pairList.TabIndex" type="System.Int32, mscorlib">
    <value>23</value>
  </data>
  <data name="pairList.ToolTip" xml:space="preserve">
    <value>Current parameters.</value>
  </data>
  <data name="&gt;&gt;pairList.Name" xml:space="preserve">
    <value>pairList</value>
  </data>
  <data name="&gt;&gt;pairList.Type" xml:space="preserve">
    <value>System.Windows.Forms.TreeView, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;pairList.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;pairList.ZOrder" xml:space="preserve">
    <value>38</value>
  </data>
  <data name="buttonRemovePair.Location" type="System.Drawing.Point, System.Drawing">
    <value>88, 337</value>
  </data>
  <data name="buttonRemovePair.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="buttonRemovePair.Size" type="System.Drawing.Size, System.Drawing">
    <value>75, 21</value>
  </data>
  <data name="buttonRemovePair.TabIndex" type="System.Int32, mscorlib">
    <value>24</value>
  </data>
  <data name="buttonRemovePair.Text" xml:space="preserve">
    <value>Remove Pair</value>
  </data>
  <data name="buttonRemovePair.ToolTip" xml:space="preserve">
    <value>Remove the selected port pair.</value>
  </data>
  <data name="&gt;&gt;buttonRemovePair.Name" xml:space="preserve">
    <value>buttonRemovePair</value>
  </data>
  <data name="&gt;&gt;buttonRemovePair.Type" xml:space="preserve">
    <value>System.Windows.Forms.Button, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;buttonRemovePair.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;buttonRemovePair.ZOrder" xml:space="preserve">
    <value>37</value>
  </data>
  <data name="buttonAddPair.ImeMode" type="System.Windows.Forms.ImeMode, System.Windows.Forms">
    <value>NoControl</value>
  </data>
  <data name="buttonAddPair.Location" type="System.Drawing.Point, System.Drawing">
    <value>9, 337</value>
  </data>
  <data name="buttonAddPair.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="buttonAddPair.Size" type="System.Drawing.Size, System.Drawing">
    <value>75, 21</value>
  </data>
  <data name="buttonAddPair.TabIndex" type="System.Int32, mscorlib">
    <value>25</value>
  </data>
  <data name="buttonAddPair.Text" xml:space="preserve">
    <value>Add Pair</value>
  </data>
  <data name="buttonAddPair.ToolTip" xml:space="preserve">
    <value>Add a new port pair with default parameters.</value>
  </data>
  <data name="&gt;&gt;buttonAddPair.Name" xml:space="preserve">
    <value>buttonAddPair</value>
  </data>
  <data name="&gt;&gt;buttonAddPair.Type" xml:space="preserve">
    <value>System.Windows.Forms.Button, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;buttonAddPair.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;buttonAddPair.ZOrder" xml:space="preserve">
    <value>36</value>
  </data>
  <data name="buttonApply.Location" type="System.Drawing.Point, System.Drawing">
    <value>361, 337</value>
  </data>
  <data name="buttonApply.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="buttonApply.Size" type="System.Drawing.Size, System.Drawing">
    <value>75, 21</value>
  </data>
  <data name="buttonApply.TabIndex" type="System.Int32, mscorlib">
    <value>26</value>
  </data>
  <data name="buttonApply.Text" xml:space="preserve">
    <value>Apply</value>
  </data>
  <data name="buttonApply.ToolTip" xml:space="preserve">
    <value>Apply the changed parameters (highlighted with blue color).</value>
  </data>
  <data name="&gt;&gt;buttonApply.Name" xml:space="preserve">
    <value>buttonApply</value>
  </data>
  <data name="&gt;&gt;buttonApply.Type" xml:space="preserve">
    <value>System.Windows.Forms.Button, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;buttonApply.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;buttonApply.ZOrder" xml:space="preserve">
    <value>35</value>
  </data>
  <data name="buttonReset.Location" type="System.Drawing.Point, System.Drawing">
    <value>175, 337</value>
  </data>
  <data name="buttonReset.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="buttonReset.Size" type="System.Drawing.Size, System.Drawing">
    <value>75, 21</value>
  </data>
  <data name="buttonReset.TabIndex" type="System.Int32, mscorlib">
    <value>27</value>
  </data>
  <data name="buttonReset.Text" xml:space="preserve">
    <value>Reset</value>
  </data>
  <data name="buttonReset.ToolTip" xml:space="preserve">
    <value>Reload the current parameters and redraw the form.</value>
  </data>
  <data name="&gt;&gt;buttonReset.Name" xml:space="preserve">
    <value>buttonReset</value>
  </data>
  <data name="&gt;&gt;buttonReset.Type" xml:space="preserve">
    <value>System.Windows.Forms.Button, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;buttonReset.Parent" xml:space="preserve">
    <value>$this</value>
  </data>
  <data name="&gt;&gt;buttonReset.ZOrder" xml:space="preserve">
    <value>34</value>
  </data>
  <metadata name="$this.Localizable" type="System.Boolean, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>True</value>
  </metadata>
  <data name="$this.AutoScaleDimensions" type="System.Drawing.SizeF, System.Drawing">
    <value>6, 13</value>
  </data>
  <data name="$this.ClientSize" type="System.Drawing.Size, System.Drawing">
    <value>445, 366</value>
  </data>
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAIAICAQAAAAAADoAgAAJgAAABAQEAAAAAAAKAEAAA4DAAAoAAAAIAAAAEAAAAABAAQAAAAAAIAC
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAAAACAAIAAgIAAAMDAwACAgIAAAAD/AAD/
        AAAA//8A/wAAAP8A/wD//wAA////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHcA
        AAAAAAAAAAAAAAAAD/B3dwAAAAAAAAAAAAAAAA/wd3dwAAAAAAAAAAAAAAAP8Hd3dwAAAAAAAAAAAAAA
        D/B3d3dwERAAAAAAAAAAAA/wd3d3cHdxEQAAAAAAAAAP8Hd3d3B3d3cRAAAAAAAAD/B3d3dwERd3dxAA
        AAAAAA/wd3d3AAABEXdxAAAAAAAP8Hd3cAAAAAAXdxAAAAAAD/B3dwAAAAAAAXcQAAAAAAAAdwAAAAAA
        AAAXcQAAAAAAAAAAAAAAAAAAF3EAAAAAAAAAAAAAAAAAABdxAAAAAAAAAAAAAAAAAAAXcQAAAAAIgREA
        AAAAAAAAF3EAAAAAgRF3EQAAAAAAABdxAAAAAB/xd3cQAAAAAAF3EAAAAAAf8Xd3cQAAAAAXdxAAAAAA
        H/F3d3cQAAERd3EAAAAAAB/xd3d3cREXd3cQAAAAAAAf8Xd3d3F3d3cRAAAAAAAAH/F3d3dxd3ERAAAA
        AAAAAB/xd3d3cREQAAAAAAAAAAAf8Xd3dxAAAAAAAAAAAAAAH/F3d3EAAAAAAAAAAAAAAB/xd3cQAAAA
        AAAAAAAAAACBEXcRAAAAAAAAAAAAAAAAAIERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//////4/
        ///4D///8Af///AD///wAf//8AAf//AAA//wAAD/8AAAf/AB4D/wA/wf8Af+H/gP/w/+P/8P////D///
        /w/4P/8P8A//D/AH/h/wA/wf8AHgP/AAAH/wAAD/8AAD//AAH//wAf//8AP///AH///wD////D//////
        //8oAAAAEAAAACAAAAABAAQAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAgAAAAICAAIAA
        AACAAIAAgIAAAMDAwACAgIAAAAD/AAD/AAAA//8A/wAAAP8A/wD//wAA////AP/wAP//////8AB3D///
        ///w8Hdw//////Dwd3AAf///8PB3cAAA///w8Hdw/3AP//AAdw//9wD///AA////AP//8AD///8A//AA
        dw//9wD/8PB3cP9wD//w8HdwAAD///Dwd3AAf///8PB3cP/////wAHcP///////wAP//////AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
</value>
  </data>
  <data name="$this.Margin" type="System.Windows.Forms.Padding, System.Windows.Forms">
    <value>2, 2, 2, 2</value>
  </data>
  <data name="$this.StartPosition" type="System.Windows.Forms.FormStartPosition, System.Windows.Forms">
    <value>CenterScreen</value>
  </data>
  <data name="$this.Text" xml:space="preserve">
    <value>Setup for com0com</value>
  </data>
  <data name="&gt;&gt;toolTip1.Name" xml:space="preserve">
    <value>toolTip1</value>
  </data>
  <data name="&gt;&gt;toolTip1.Type" xml:space="preserve">
    <value>System.Windows.Forms.ToolTip, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="&gt;&gt;$this.Name" xml:space="preserve">
    <value>Form1</value>
  </data>
  <data name="&gt;&gt;$this.Type" xml:space="preserve">
    <value>System.Windows.Forms.Form, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>

# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/setup.vcproj

<?xml version="1.0" encoding="windows-1251"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8,00"
	Name="setupg"
	ProjectGUID="{6ACC2F57-86A2-41D4-8744-5982985E99DA}"
	RootNamespace="SetupApp"
	Keyword="ManagedCProj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			ManagedExtensions="2"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG"
				RuntimeLibrary="3"
				UsePrecompiledHeader="2"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="$(NoInherit)"
				OutputFile="$(OutDir)\setupg.exe"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				AssemblyDebug="1"
				SubSystem="2"
				EntryPointSymbol="main"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			ManagedExtensions="2"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG"
				RuntimeLibrary="2"
				UsePrecompiledHeader="2"
				WarningLevel="4"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalDependencies="$(NoInherit)"
				OutputFile="$(OutDir)\setupg.exe"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="2"
				EntryPointSymbol="main"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
		<AssemblyReference
			RelativePath="System.dll"
			AssemblyName="System, Version=2.0.0.0, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL"
		/>
		<AssemblyReference
			RelativePath="System.Data.dll"
			AssemblyName="System.Data, Version=2.0.0.0, PublicKeyToken=b77a5c561934e089, processorArchitecture=x86"
		/>
		<AssemblyReference
			RelativePath="System.Drawing.dll"
			AssemblyName="System.Drawing, Version=2.0.0.0, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL"
		/>
		<AssemblyReference
			RelativePath="System.Windows.Forms.dll"
			AssemblyName="System.Windows.Forms, Version=2.0.0.0, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL"
		/>
		<AssemblyReference
			RelativePath="System.XML.dll"
			AssemblyName="System.Xml, Version=2.0.0.0, PublicKeyToken=b77a5c561934e089, processorArchitecture=MSIL"
		/>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\AssemblyInfo.cpp"
				>
			</File>
			<File
				RelativePath=".\exec.cpp"
				>
			</File>
			<File
				RelativePath=".\pinmap.cpp"
				>
			</File>
			<File
				RelativePath=".\portprms.cpp"
				>
			</File>
			<File
				RelativePath=".\setup.cpp"
				>
			</File>
			<File
				RelativePath=".\stdafx.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\exec.h"
				>
			</File>
			<File
				RelativePath=".\Form1.h"
				FileType="3"
				>
				<File
					RelativePath=".\Form1.resX"
					SubType="Designer"
					>
				</File>
			</File>
			<File
				RelativePath=".\pinmap.h"
				>
			</File>
			<File
				RelativePath=".\portprms.h"
				>
			</File>
			<File
				RelativePath=".\resource.h"
				>
			</File>
			<File
				RelativePath=".\stdafx.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
			<File
				RelativePath=".\app.rc"
				>
			</File>
			<File
				RelativePath=".\com0com.ico"
				>
			</File>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/setup.cpp

/*
 * $Id: setup.cpp,v 1.1 2007/10/31 10:16:55 vfrolov Exp $
 *
 * Copyright (c) 2007 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: setup.cpp,v $
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 *
 */

#include "stdafx.h"
#include "portprms.h"
#include "pinmap.h"
#include "Form1.h"

using namespace SetupApp;

[STAThreadAttribute]
int main(array<System::String ^> ^/*args*/)
{
	// Enabling Windows XP visual effects before any controls are created
	Application::EnableVisualStyles();
	Application::SetCompatibleTextRenderingDefault(false); 

	// Create the main window and run it
	Application::Run(gcnew Form1());
	return 0;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/pinmap.h

/*
 * $Id: pinmap.h,v 1.1 2007/10/31 10:16:55 vfrolov Exp $
 *
 * Copyright (c) 2007 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: pinmap.h,v $
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 *
 */

#pragma once

namespace SetupApp {
  using namespace System;
  using namespace System::Drawing;
  using namespace System::Windows::Forms;
  using namespace System::Collections::Generic;

  ref class PinSource;
  ref class Pin;
  ref class PortPair;

  ref class PinMap {
    public:
      PinMap();
      void Init(PortPair ^pair);
      void Paint(PaintEventArgs ^e, Control ^control);
      void GetChanges(PortPair ^pair);

      void MouseInit();
      void MouseDown(MouseEventArgs ^e);
      void MouseMove(MouseEventArgs ^e);
      void MouseUp(MouseEventArgs ^e);
      void MouseDoubleClick(MouseEventArgs ^e);

    private:
      void Link(String ^pinName, String ^source, bool invert);

      Dictionary<String ^, PinSource ^> ^pinsOrg;
      Dictionary<String ^, Pin ^> ^pins;
      Point mb;
      Point me;
      String ^selected;
      bool down;
      bool up;
      bool doubleClick;
  };
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/exec.cpp

/*
 * $Id: exec.cpp,v 1.1 2007/10/31 10:16:55 vfrolov Exp $
 *
 * Copyright (c) 2007 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: exec.cpp,v $
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 *
 */

#include "stdafx.h"
#include "exec.h"

using namespace System;
using namespace System::Windows::Forms;

array<String ^> ^ExecCommand::ExecCommand(System::Windows::Forms::Control ^parent, String ^cmd)
{
  Cursor ^cursor = parent->Cursor;
  parent->Cursor = Cursors::WaitCursor;

  System::Diagnostics::Process ^setupc = gcnew System::Diagnostics::Process();
  setupc->StartInfo->FileName = "setupc.exe";

  setupc->StartInfo->Arguments = cmd->Trim();

  setupc->StartInfo->CreateNoWindow = true;
  setupc->StartInfo->UseShellExecute = false;
  setupc->StartInfo->RedirectStandardOutput = true;

  array<String ^> ^lines = gcnew array<String ^>(0);

  try {
    if (setupc->Start()) {
      for (;;) {
        String ^line = setupc->StandardOutput->ReadLine();
        if (!line)
          break;

        Array::Resize(lines, lines->Length + 1);
        lines[lines->Length - 1] = line->Trim();
      }

      setupc->WaitForExit();

      /*
      String ^msg = String::Format("\"{0} {1}\"\n\n{2}",
                                   setupc->StartInfo->FileName,
                                   setupc->StartInfo->Arguments,
                                   String::Join("\n", lines));

      MessageBox::Show(msg, "");
      */

      setupc->Close();
    }
  }
  catch (Exception ^e) {
    String ^msg = String::Format("\"{0} {1}\"\n\n{2}",
                                 setupc->StartInfo->FileName,
                                 setupc->StartInfo->Arguments,
                                 e->Message);
    MessageBox::Show(msg, "Error");
  }

  parent->Cursor = cursor;

  return lines;
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/AssemblyInfo.cpp

#include "stdafx.h"

using namespace System;
using namespace System::Reflection;
using namespace System::Runtime::CompilerServices;
using namespace System::Runtime::InteropServices;
using namespace System::Security::Permissions;

//
// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly:AssemblyTitleAttribute("setup")];
[assembly:AssemblyDescriptionAttribute("")];
[assembly:AssemblyConfigurationAttribute("")];
[assembly:AssemblyCompanyAttribute("Vyacheslav Frolov")];
[assembly:AssemblyProductAttribute("setup")];
[assembly:AssemblyCopyrightAttribute("Copyright (c) Vyacheslav Frolov 2007")];
[assembly:AssemblyTrademarkAttribute("")];
[assembly:AssemblyCultureAttribute("")];

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the value or you can default the Revision and Build Numbers
// by using the '*' as shown below:

[assembly:AssemblyVersionAttribute("1.0.*")];

[assembly:ComVisible(false)];

[assembly:CLSCompliantAttribute(true)];

[assembly:SecurityPermission(SecurityAction::RequestMinimum, UnmanagedCode = true)];


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/portprms.cpp

/*
 * $Id: portprms.cpp,v 1.3 2012/01/31 05:34:34 vfrolov Exp $
 *
 * Copyright (c) 2007-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: portprms.cpp,v $
 * Revision 1.3  2012/01/31 05:34:34  vfrolov
 * Added "use Ports class" option
 * Added waiting install completion
 *
 * Revision 1.2  2009/01/12 13:04:07  vfrolov
 * Added red painting InUse portnames
 *
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 */

#include "stdafx.h"
#include "portprms.h"
#include "exec.h"

using namespace SetupApp;
using namespace System;
using namespace System::Collections::Generic;


PortParams::PortParams(String ^str)
{
  array<Char> ^separator = {','};
  array<String ^> ^prms = str->Split(separator, StringSplitOptions::RemoveEmptyEntries);;

  for (int i = 0 ; i < prms->Length ; i++) {
    array<Char> ^separator = {'='};
    array<String ^> ^prm = prms[i]->Split(separator);

    if (prm->Length == 2) {
      this[prm[0]->ToLower()] = prm[1]->ToUpper();
    }
  }
}

String ^PortPairs::ParseLine(String ^line)
{
  array<Char> ^separator = {' '};
  array<String ^> ^fields = line->Split(separator, StringSplitOptions::RemoveEmptyEntries);

  if (fields->Length != 2)
    return nullptr;

  int iPort;

  if (fields[0]->StartsWith("CNCA")) {
    iPort = 0;
  }
  else
  if (fields[0]->StartsWith("CNCB")) {
    iPort = 1;
  }
  else {
    return nullptr;
  }

  String ^keyPair = fields[0]->Substring(4);

  if (!ContainsKey(keyPair))
    this[keyPair] = gcnew PortPair();

  this[keyPair]->Set(iPort, gcnew PortParams(fields[1]));

  return keyPair;
}

void PortPairs::Init()
{
  String ^cmd = "--detail-prms list";

  array<String ^> ^lines = ExecCommand::ExecCommand(parent, cmd);

  Clear();

  for (int i = 0 ; i < lines->Length ; i++)
    ParseLine(lines[i]);

  LoadBusyNames();
}

String ^PortPairs::AddPair()
{
  String ^res = nullptr;

  String ^cmd = "--detail-prms install - -";

  array<String ^> ^lines = ExecCommand::ExecCommand(parent, cmd);

  for (int i = 0 ; i < lines->Length ; i++) {
    String ^keyPair = ParseLine(lines[i]);

    if (res == nullptr)
      res = keyPair;
  }

  ExecCommand::ExecCommand(parent, "--wait +30");

  Init();

  return res;
}

void PortPairs::RemovePair(String ^keyPair)
{
  String ^cmd = String::Format("remove {0}", keyPair);

  ExecCommand::ExecCommand(parent, cmd);

  Init();
}

void PortPairs::ChangePair(String ^keyPair, PortPair ^pairChanges)
{
  for (int i = 0 ; i < 2 ; i++) {
    if (pairChanges[i] == nullptr || pairChanges[i]->Count == 0)
      continue;

    String ^cmd = "change";
    cmd += String::Format(" CNC{0}{1} ", (i == 0) ? "A" : "B", keyPair);

    for each (KeyValuePair<String ^, String ^> kvpPort in pairChanges[i])
      cmd += String::Format("{0}={1},", kvpPort.Key, kvpPort.Value);

    ExecCommand::ExecCommand(parent, cmd);
  }

  ExecCommand::ExecCommand(parent, "--wait +30");

  Init();
}

bool PortPairs::IsValidName(String ^name)
{
  if (busyNames == nullptr)
    return true;

  for each (String ^busyName in busyNames) {
    if (busyName->ToUpper() == name->ToUpper())
      return false;
  }

  return true;
}

void PortPairs::LoadBusyNames()
{
  String ^cmd = "busynames *";

  busyNames = ExecCommand::ExecCommand(parent, cmd);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/resource.h

//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by app.rc


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/exec.h

/*
 * $Id: exec.h,v 1.1 2007/10/31 10:16:55 vfrolov Exp $
 *
 * Copyright (c) 2007 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: exec.h,v $
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 *
 */

#pragma once

namespace ExecCommand {
  using namespace System;

  array<String ^> ^ExecCommand(System::Windows::Forms::Control ^parent, String ^cmd);
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/Form1.h

/*
 * $Id: Form1.h,v 1.8 2012/01/31 08:38:09 vfrolov Exp $
 *
 * Copyright (c) 2007-2012 Vyacheslav Frolov
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 * $Log: Form1.h,v $
 * Revision 1.8  2012/01/31 08:38:09  vfrolov
 * Use node name COM<n> instead COM#
 *
 * Revision 1.7  2012/01/31 05:34:34  vfrolov
 * Added "use Ports class" option
 * Added waiting install completion
 *
 * Revision 1.6  2010/05/27 11:16:46  vfrolov
 * Added ability to put the port to the Ports class
 *
 * Revision 1.5  2009/01/12 13:04:07  vfrolov
 * Added red painting InUse portnames
 *
 * Revision 1.4  2008/05/04 09:56:47  vfrolov
 * Implemented HiddenMode option
 *
 * Revision 1.3  2008/04/08 06:52:12  vfrolov
 * Added pin OUT2
 *
 * Revision 1.2  2007/11/20 12:29:40  vfrolov
 * Fixed appearance for Vista
 *
 * Revision 1.1  2007/10/31 10:16:55  vfrolov
 * Initial revision
 *
 */

#pragma once

namespace SetupApp {

    using namespace System::Collections::Generic;
	using namespace System;
	using namespace System::ComponentModel;
	using namespace System::Collections;
	using namespace System::Windows::Forms;
	using namespace System::Data;
	using namespace System::Drawing;

	/// <summary>
	/// Summary for Form1
	///
	/// WARNING: If you change the name of this class, you will need to change the
	///          'Resource File Name' property for the managed resource compiler tool
	///          associated with all .resx files this class depends on.  Otherwise,
	///          the designers will not be able to interact properly with localized
	///          resources associated with this form.
	/// </summary>
	public ref class Form1 : public System::Windows::Forms::Form
	{
    public:
		Form1(void)
		{
			InitializeComponent();
			//
			//TODO: Add the constructor code here
			//
		}

	protected:
		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		~Form1()
		{
			if (components)
			{
				delete components;
			}
		}

    private: System::Windows::Forms::TextBox^  PortNameB;
    private: System::Windows::Forms::TextBox^  PortNameA;
    private: System::Windows::Forms::PictureBox^  picturePinMap;
    private: System::Windows::Forms::ToolTip^  toolTip1;
    private: System::ComponentModel::IContainer^  components;
    private: System::Windows::Forms::Button^  buttonRemovePair;
    private: System::Windows::Forms::Button^  buttonAddPair;
    private: System::Windows::Forms::Button^  buttonApply;
    private: System::Windows::Forms::Button^  buttonReset;
    private: System::Windows::Forms::CheckBox^  EmuBrB;
    private: System::Windows::Forms::CheckBox^  EmuOverrunB;
    private: System::Windows::Forms::CheckBox^  PlugInModeB;
    private: System::Windows::Forms::CheckBox^  ExclusiveModeB;
    private: System::Windows::Forms::CheckBox^  ExclusiveModeA;
    private: System::Windows::Forms::CheckBox^  PlugInModeA;
    private: System::Windows::Forms::CheckBox^  EmuOverrunA;
    private: System::Windows::Forms::CheckBox^  EmuBrA;
    private: System::Windows::Forms::CheckBox^  HiddenModeA;
    private: System::Windows::Forms::CheckBox^  HiddenModeB;
    private: System::Windows::Forms::Label^  pinNameON;
    private: System::Windows::Forms::Label^  pinNameA_RX;
    private: System::Windows::Forms::Label^  pinNameA_DTR;
    private: System::Windows::Forms::Label^  pinNameA_TX;
    private: System::Windows::Forms::Label^  pinNameA_DSR;
    private: System::Windows::Forms::Label^  pinNameA_DCD;
    private: System::Windows::Forms::Label^  pinNameA_RTS;
    private: System::Windows::Forms::Label^  pinNameA_CTS;
    private: System::Windows::Forms::Label^  pinNameA_RI;
    private: System::Windows::Forms::Label^  pinNameA_OUT1;
    private: System::Windows::Forms::Label^  pinNameA_OUT2;
    private: System::Windows::Forms::Label^  pinNameA_OPEN;
    private: System::Windows::Forms::Label^  pinNameB_OPEN;
    private: System::Windows::Forms::Label^  pinNameB_OUT1;
    private: System::Windows::Forms::Label^  pinNameB_OUT2;
    private: System::Windows::Forms::Label^  pinNameB_RI;
    private: System::Windows::Forms::Label^  pinNameB_CTS;
    private: System::Windows::Forms::Label^  pinNameB_RTS;
    private: System::Windows::Forms::Label^  pinNameB_DCD;
    private: System::Windows::Forms::Label^  pinNameB_DSR;
    private: System::Windows::Forms::Label^  pinNameB_TX;
    private: System::Windows::Forms::Label^  pinNameB_DTR;
    private: System::Windows::Forms::Label^  pinNameB_RX;
    private: System::Windows::Forms::CheckBox^  UsePortsClassB;
    private: System::Windows::Forms::CheckBox^  UsePortsClassA;
    private: System::Windows::Forms::TreeView^  pairList;

	private:
		/// <summary>
		/// Required designer variable.
		/// </summary>


#pragma region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		void InitializeComponent(void)
		{
          this->components = (gcnew System::ComponentModel::Container());
          System::ComponentModel::ComponentResourceManager^  resources = (gcnew System::ComponentModel::ComponentResourceManager(Form1::typeid));
          this->PortNameB = (gcnew System::Windows::Forms::TextBox());
          this->PortNameA = (gcnew System::Windows::Forms::TextBox());
          this->UsePortsClassB = (gcnew System::Windows::Forms::CheckBox());
          this->UsePortsClassA = (gcnew System::Windows::Forms::CheckBox());
          this->pinNameON = (gcnew System::Windows::Forms::Label());
          this->picturePinMap = (gcnew System::Windows::Forms::PictureBox());
          this->toolTip1 = (gcnew System::Windows::Forms::ToolTip(this->components));
          this->EmuBrB = (gcnew System::Windows::Forms::CheckBox());
          this->EmuOverrunB = (gcnew System::Windows::Forms::CheckBox());
          this->PlugInModeB = (gcnew System::Windows::Forms::CheckBox());
          this->ExclusiveModeB = (gcnew System::Windows::Forms::CheckBox());
          this->ExclusiveModeA = (gcnew System::Windows::Forms::CheckBox());
          this->PlugInModeA = (gcnew System::Windows::Forms::CheckBox());
          this->EmuOverrunA = (gcnew System::Windows::Forms::CheckBox());
          this->EmuBrA = (gcnew System::Windows::Forms::CheckBox());
          this->HiddenModeA = (gcnew System::Windows::Forms::CheckBox());
          this->HiddenModeB = (gcnew System::Windows::Forms::CheckBox());
          this->pinNameA_RX = (gcnew System::Windows::Forms::Label());
          this->pinNameA_DTR = (gcnew System::Windows::Forms::Label());
          this->pinNameA_TX = (gcnew System::Windows::Forms::Label());
          this->pinNameA_DSR = (gcnew System::Windows::Forms::Label());
          this->pinNameA_DCD = (gcnew System::Windows::Forms::Label());
          this->pinNameA_RTS = (gcnew System::Windows::Forms::Label());
          this->pinNameA_CTS = (gcnew System::Windows::Forms::Label());
          this->pinNameA_RI = (gcnew System::Windows::Forms::Label());
          this->pinNameA_OUT1 = (gcnew System::Windows::Forms::Label());
          this->pinNameA_OUT2 = (gcnew System::Windows::Forms::Label());
          this->pinNameA_OPEN = (gcnew System::Windows::Forms::Label());
          this->pinNameB_OPEN = (gcnew System::Windows::Forms::Label());
          this->pinNameB_OUT1 = (gcnew System::Windows::Forms::Label());
          this->pinNameB_OUT2 = (gcnew System::Windows::Forms::Label());
          this->pinNameB_RI = (gcnew System::Windows::Forms::Label());
          this->pinNameB_CTS = (gcnew System::Windows::Forms::Label());
          this->pinNameB_RTS = (gcnew System::Windows::Forms::Label());
          this->pinNameB_DCD = (gcnew System::Windows::Forms::Label());
          this->pinNameB_DSR = (gcnew System::Windows::Forms::Label());
          this->pinNameB_TX = (gcnew System::Windows::Forms::Label());
          this->pinNameB_DTR = (gcnew System::Windows::Forms::Label());
          this->pinNameB_RX = (gcnew System::Windows::Forms::Label());
          this->pairList = (gcnew System::Windows::Forms::TreeView());
          this->buttonRemovePair = (gcnew System::Windows::Forms::Button());
          this->buttonAddPair = (gcnew System::Windows::Forms::Button());
          this->buttonApply = (gcnew System::Windows::Forms::Button());
          this->buttonReset = (gcnew System::Windows::Forms::Button());
          (cli::safe_cast<System::ComponentModel::ISupportInitialize^  >(this->picturePinMap))->BeginInit();
          this->SuspendLayout();
          // 
          // PortNameB
          // 
          resources->ApplyResources(this->PortNameB, L"PortNameB");
          this->PortNameB->Name = L"PortNameB";
          this->toolTip1->SetToolTip(this->PortNameB, resources->GetString(L"PortNameB.ToolTip"));
          this->PortNameB->TextChanged += gcnew System::EventHandler(this, &Form1::PortNameB_Changed);
          // 
          // PortNameA
          // 
          resources->ApplyResources(this->PortNameA, L"PortNameA");
          this->PortNameA->Name = L"PortNameA";
          this->toolTip1->SetToolTip(this->PortNameA, resources->GetString(L"PortNameA.ToolTip"));
          this->PortNameA->TextChanged += gcnew System::EventHandler(this, &Form1::PortNameA_Changed);
          // 
          // UsePortsClassB
          // 
          resources->ApplyResources(this->UsePortsClassB, L"UsePortsClassB");
          this->UsePortsClassB->Name = L"UsePortsClassB";
          this->toolTip1->SetToolTip(this->UsePortsClassB, resources->GetString(L"UsePortsClassB.ToolTip"));
          this->UsePortsClassB->UseVisualStyleBackColor = true;
          this->UsePortsClassB->CheckedChanged += gcnew System::EventHandler(this, &Form1::UsePortsClassB_Changed);
          // 
          // UsePortsClassA
          // 
          resources->ApplyResources(this->UsePortsClassA, L"UsePortsClassA");
          this->UsePortsClassA->Name = L"UsePortsClassA";
          this->toolTip1->SetToolTip(this->UsePortsClassA, resources->GetString(L"UsePortsClassA.ToolTip"));
          this->UsePortsClassA->UseVisualStyleBackColor = true;
          this->UsePortsClassA->CheckedChanged += gcnew System::EventHandler(this, &Form1::UsePortsClassA_Changed);
          // 
          // pinNameON
          // 
          resources->ApplyResources(this->pinNameON, L"pinNameON");
          this->pinNameON->Name = L"pinNameON";
          this->toolTip1->SetToolTip(this->pinNameON, resources->GetString(L"pinNameON.ToolTip"));
          // 
          // picturePinMap
          // 
          this->picturePinMap->BackColor = System::Drawing::SystemColors::Control;
          this->picturePinMap->Cursor = System::Windows::Forms::Cursors::Hand;
          resources->ApplyResources(this->picturePinMap, L"picturePinMap");
          this->picturePinMap->Name = L"picturePinMap";
          this->picturePinMap->TabStop = false;
          this->toolTip1->SetToolTip(this->picturePinMap, resources->GetString(L"picturePinMap.ToolTip"));
          this->picturePinMap->MouseLeave += gcnew System::EventHandler(this, &Form1::picturePinMap_MouseLeave);
          this->picturePinMap->MouseMove += gcnew System::Windows::Forms::MouseEventHandler(this, &Form1::picturePinMap_MouseMove);
          this->picturePinMap->MouseDoubleClick += gcnew System::Windows::Forms::MouseEventHandler(this, &Form1::picturePinMap_MouseDoubleClick);
          this->picturePinMap->MouseDown += gcnew System::Windows::Forms::MouseEventHandler(this, &Form1::picturePinMap_MouseDown);
          this->picturePinMap->Paint += gcnew System::Windows::Forms::PaintEventHandler(this, &Form1::picturePinMap_Paint);
          this->picturePinMap->MouseUp += gcnew System::Windows::Forms::MouseEventHandler(this, &Form1::picturePinMap_MouseUp);
          // 
          // EmuBrB
          // 
          resources->ApplyResources(this->EmuBrB, L"EmuBrB");
          this->EmuBrB->Name = L"EmuBrB";
          this->toolTip1->SetToolTip(this->EmuBrB, resources->GetString(L"EmuBrB.ToolTip"));
          this->EmuBrB->UseVisualStyleBackColor = true;
          this->EmuBrB->CheckedChanged += gcnew System::EventHandler(this, &Form1::EmuBrB_Changed);
          // 
          // EmuOverrunB
          // 
          resources->ApplyResources(this->EmuOverrunB, L"EmuOverrunB");
          this->EmuOverrunB->Name = L"EmuOverrunB";
          this->toolTip1->SetToolTip(this->EmuOverrunB, resources->GetString(L"EmuOverrunB.ToolTip"));
          this->EmuOverrunB->UseVisualStyleBackColor = true;
          this->EmuOverrunB->CheckedChanged += gcnew System::EventHandler(this, &Form1::EmuOverrunB_Changed);
          // 
          // PlugInModeB
          // 
          resources->ApplyResources(this->PlugInModeB, L"PlugInModeB");
          this->PlugInModeB->Name = L"PlugInModeB";
          this->toolTip1->SetToolTip(this->PlugInModeB, resources->GetString(L"PlugInModeB.ToolTip"));
          this->PlugInModeB->UseVisualStyleBackColor = true;
          this->PlugInModeB->CheckedChanged += gcnew System::EventHandler(this, &Form1::PlugInModeB_Changed);
          // 
          // ExclusiveModeB
          // 
          resources->ApplyResources(this->ExclusiveModeB, L"ExclusiveModeB");
          this->ExclusiveModeB->Name = L"ExclusiveModeB";
          this->toolTip1->SetToolTip(this->ExclusiveModeB, resources->GetString(L"ExclusiveModeB.ToolTip"));
          this->ExclusiveModeB->UseVisualStyleBackColor = true;
          this->ExclusiveModeB->CheckedChanged += gcnew System::EventHandler(this, &Form1::ExclusiveModeB_Changed);
          // 
          // ExclusiveModeA
          // 
          resources->ApplyResources(this->ExclusiveModeA, L"ExclusiveModeA");
          this->ExclusiveModeA->Name = L"ExclusiveModeA";
          this->toolTip1->SetToolTip(this->ExclusiveModeA, resources->GetString(L"ExclusiveModeA.ToolTip"));
          this->ExclusiveModeA->UseVisualStyleBackColor = true;
          this->ExclusiveModeA->CheckedChanged += gcnew System::EventHandler(this, &Form1::ExclusiveModeA_Changed);
          // 
          // PlugInModeA
          // 
          resources->ApplyResources(this->PlugInModeA, L"PlugInModeA");
          this->PlugInModeA->Name = L"PlugInModeA";
          this->toolTip1->SetToolTip(this->PlugInModeA, resources->GetString(L"PlugInModeA.ToolTip"));
          this->PlugInModeA->UseVisualStyleBackColor = true;
          this->PlugInModeA->CheckedChanged += gcnew System::EventHandler(this, &Form1::PlugInModeA_Changed);
          // 
          // EmuOverrunA
          // 
          resources->ApplyResources(this->EmuOverrunA, L"EmuOverrunA");
          this->EmuOverrunA->Name = L"EmuOverrunA";
          this->toolTip1->SetToolTip(this->EmuOverrunA, resources->GetString(L"EmuOverrunA.ToolTip"));
          this->EmuOverrunA->UseVisualStyleBackColor = true;
          this->EmuOverrunA->CheckedChanged += gcnew System::EventHandler(this, &Form1::EmuOverrunA_Changed);
          // 
          // EmuBrA
          // 
          resources->ApplyResources(this->EmuBrA, L"EmuBrA");
          this->EmuBrA->Name = L"EmuBrA";
          this->toolTip1->SetToolTip(this->EmuBrA, resources->GetString(L"EmuBrA.ToolTip"));
          this->EmuBrA->UseVisualStyleBackColor = true;
          this->EmuBrA->CheckedChanged += gcnew System::EventHandler(this, &Form1::EmuBrA_Changed);
          // 
          // HiddenModeA
          // 
          resources->ApplyResources(this->HiddenModeA, L"HiddenModeA");
          this->HiddenModeA->Name = L"HiddenModeA";
          this->toolTip1->SetToolTip(this->HiddenModeA, resources->GetString(L"HiddenModeA.ToolTip"));
          this->HiddenModeA->UseVisualStyleBackColor = true;
          this->HiddenModeA->CheckedChanged += gcnew System::EventHandler(this, &Form1::HiddenModeA_Changed);
          // 
          // HiddenModeB
          // 
          resources->ApplyResources(this->HiddenModeB, L"HiddenModeB");
          this->HiddenModeB->Name = L"HiddenModeB";
          this->toolTip1->SetToolTip(this->HiddenModeB, resources->GetString(L"HiddenModeB.ToolTip"));
          this->HiddenModeB->UseVisualStyleBackColor = true;
          this->HiddenModeB->CheckedChanged += gcnew System::EventHandler(this, &Form1::HiddenModeB_Changed);
          // 
          // pinNameA_RX
          // 
          resources->ApplyResources(this->pinNameA_RX, L"pinNameA_RX");
          this->pinNameA_RX->Name = L"pinNameA_RX";
          this->toolTip1->SetToolTip(this->pinNameA_RX, resources->GetString(L"pinNameA_RX.ToolTip"));
          // 
          // pinNameA_DTR
          // 
          resources->ApplyResources(this->pinNameA_DTR, L"pinNameA_DTR");
          this->pinNameA_DTR->Name = L"pinNameA_DTR";
          this->toolTip1->SetToolTip(this->pinNameA_DTR, resources->GetString(L"pinNameA_DTR.ToolTip"));
          // 
          // pinNameA_TX
          // 
          resources->ApplyResources(this->pinNameA_TX, L"pinNameA_TX");
          this->pinNameA_TX->Name = L"pinNameA_TX";
          this->toolTip1->SetToolTip(this->pinNameA_TX, resources->GetString(L"pinNameA_TX.ToolTip"));
          // 
          // pinNameA_DSR
          // 
          resources->ApplyResources(this->pinNameA_DSR, L"pinNameA_DSR");
          this->pinNameA_DSR->Name = L"pinNameA_DSR";
          this->toolTip1->SetToolTip(this->pinNameA_DSR, resources->GetString(L"pinNameA_DSR.ToolTip"));
          // 
          // pinNameA_DCD
          // 
          resources->ApplyResources(this->pinNameA_DCD, L"pinNameA_DCD");
          this->pinNameA_DCD->Name = L"pinNameA_DCD";
          this->toolTip1->SetToolTip(this->pinNameA_DCD, resources->GetString(L"pinNameA_DCD.ToolTip"));
          // 
          // pinNameA_RTS
          // 
          resources->ApplyResources(this->pinNameA_RTS, L"pinNameA_RTS");
          this->pinNameA_RTS->Name = L"pinNameA_RTS";
          this->toolTip1->SetToolTip(this->pinNameA_RTS, resources->GetString(L"pinNameA_RTS.ToolTip"));
          // 
          // pinNameA_CTS
          // 
          resources->ApplyResources(this->pinNameA_CTS, L"pinNameA_CTS");
          this->pinNameA_CTS->Name = L"pinNameA_CTS";
          this->toolTip1->SetToolTip(this->pinNameA_CTS, resources->GetString(L"pinNameA_CTS.ToolTip"));
          // 
          // pinNameA_RI
          // 
          resources->ApplyResources(this->pinNameA_RI, L"pinNameA_RI");
          this->pinNameA_RI->Name = L"pinNameA_RI";
          this->toolTip1->SetToolTip(this->pinNameA_RI, resources->GetString(L"pinNameA_RI.ToolTip"));
          // 
          // pinNameA_OUT1
          // 
          resources->ApplyResources(this->pinNameA_OUT1, L"pinNameA_OUT1");
          this->pinNameA_OUT1->Name = L"pinNameA_OUT1";
          this->toolTip1->SetToolTip(this->pinNameA_OUT1, resources->GetString(L"pinNameA_OUT1.ToolTip"));
          // 
          // pinNameA_OUT2
          // 
          resources->ApplyResources(this->pinNameA_OUT2, L"pinNameA_OUT2");
          this->pinNameA_OUT2->Name = L"pinNameA_OUT2";
          this->toolTip1->SetToolTip(this->pinNameA_OUT2, resources->GetString(L"pinNameA_OUT2.ToolTip"));
          // 
          // pinNameA_OPEN
          // 
          resources->ApplyResources(this->pinNameA_OPEN, L"pinNameA_OPEN");
          this->pinNameA_OPEN->Name = L"pinNameA_OPEN";
          this->toolTip1->SetToolTip(this->pinNameA_OPEN, resources->GetString(L"pinNameA_OPEN.ToolTip"));
          // 
          // pinNameB_OPEN
          // 
          resources->ApplyResources(this->pinNameB_OPEN, L"pinNameB_OPEN");
          this->pinNameB_OPEN->Name = L"pinNameB_OPEN";
          this->toolTip1->SetToolTip(this->pinNameB_OPEN, resources->GetString(L"pinNameB_OPEN.ToolTip"));
          // 
          // pinNameB_OUT1
          // 
          resources->ApplyResources(this->pinNameB_OUT1, L"pinNameB_OUT1");
          this->pinNameB_OUT1->Name = L"pinNameB_OUT1";
          this->toolTip1->SetToolTip(this->pinNameB_OUT1, resources->GetString(L"pinNameB_OUT1.ToolTip"));
          // 
          // pinNameB_OUT2
          // 
          resources->ApplyResources(this->pinNameB_OUT2, L"pinNameB_OUT2");
          this->pinNameB_OUT2->Name = L"pinNameB_OUT2";
          this->toolTip1->SetToolTip(this->pinNameB_OUT2, resources->GetString(L"pinNameB_OUT2.ToolTip"));
          // 
          // pinNameB_RI
          // 
          resources->ApplyResources(this->pinNameB_RI, L"pinNameB_RI");
          this->pinNameB_RI->Name = L"pinNameB_RI";
          this->toolTip1->SetToolTip(this->pinNameB_RI, resources->GetString(L"pinNameB_RI.ToolTip"));
          // 
          // pinNameB_CTS
          // 
          resources->ApplyResources(this->pinNameB_CTS, L"pinNameB_CTS");
          this->pinNameB_CTS->Name = L"pinNameB_CTS";
          this->toolTip1->SetToolTip(this->pinNameB_CTS, resources->GetString(L"pinNameB_CTS.ToolTip"));
          // 
          // pinNameB_RTS
          // 
          resources->ApplyResources(this->pinNameB_RTS, L"pinNameB_RTS");
          this->pinNameB_RTS->Name = L"pinNameB_RTS";
          this->toolTip1->SetToolTip(this->pinNameB_RTS, resources->GetString(L"pinNameB_RTS.ToolTip"));
          // 
          // pinNameB_DCD
          // 
          resources->ApplyResources(this->pinNameB_DCD, L"pinNameB_DCD");
          this->pinNameB_DCD->Name = L"pinNameB_DCD";
          this->toolTip1->SetToolTip(this->pinNameB_DCD, resources->GetString(L"pinNameB_DCD.ToolTip"));
          // 
          // pinNameB_DSR
          // 
          resources->ApplyResources(this->pinNameB_DSR, L"pinNameB_DSR");
          this->pinNameB_DSR->Name = L"pinNameB_DSR";
          this->toolTip1->SetToolTip(this->pinNameB_DSR, resources->GetString(L"pinNameB_DSR.ToolTip"));
          // 
          // pinNameB_TX
          // 
          resources->ApplyResources(this->pinNameB_TX, L"pinNameB_TX");
          this->pinNameB_TX->Name = L"pinNameB_TX";
          this->toolTip1->SetToolTip(this->pinNameB_TX, resources->GetString(L"pinNameB_TX.ToolTip"));
          // 
          // pinNameB_DTR
          // 
          resources->ApplyResources(this->pinNameB_DTR, L"pinNameB_DTR");
          this->pinNameB_DTR->Name = L"pinNameB_DTR";
          this->toolTip1->SetToolTip(this->pinNameB_DTR, resources->GetString(L"pinNameB_DTR.ToolTip"));
          // 
          // pinNameB_RX
          // 
          resources->ApplyResources(this->pinNameB_RX, L"pinNameB_RX");
          this->pinNameB_RX->Name = L"pinNameB_RX";
          this->toolTip1->SetToolTip(this->pinNameB_RX, resources->GetString(L"pinNameB_RX.ToolTip"));
          // 
          // pairList
          // 
          this->pairList->HideSelection = false;
          resources->ApplyResources(this->pairList, L"pairList");
          this->pairList->Name = L"pairList";
          this->toolTip1->SetToolTip(this->pairList, resources->GetString(L"pairList.ToolTip"));
          this->pairList->AfterSelect += gcnew System::Windows::Forms::TreeViewEventHandler(this, &Form1::pairsList_AfterSelect);
          this->pairList->BeforeSelect += gcnew System::Windows::Forms::TreeViewCancelEventHandler(this, &Form1::pairsList_BeforeSelect);
          // 
          // buttonRemovePair
          // 
          resources->ApplyResources(this->buttonRemovePair, L"buttonRemovePair");
          this->buttonRemovePair->Name = L"buttonRemovePair";
          this->toolTip1->SetToolTip(this->buttonRemovePair, resources->GetString(L"buttonRemovePair.ToolTip"));
          this->buttonRemovePair->UseVisualStyleBackColor = true;
          this->buttonRemovePair->Click += gcnew System::EventHandler(this, &Form1::buttonRemovePair_Click);
          // 
          // buttonAddPair
          // 
          resources->ApplyResources(this->buttonAddPair, L"buttonAddPair");
          this->buttonAddPair->Name = L"buttonAddPair";
          this->toolTip1->SetToolTip(this->buttonAddPair, resources->GetString(L"buttonAddPair.ToolTip"));
          this->buttonAddPair->UseVisualStyleBackColor = true;
          this->buttonAddPair->Click += gcnew System::EventHandler(this, &Form1::buttonAddPair_Click);
          // 
          // buttonApply
          // 
          resources->ApplyResources(this->buttonApply, L"buttonApply");
          this->buttonApply->Name = L"buttonApply";
          this->toolTip1->SetToolTip(this->buttonApply, resources->GetString(L"buttonApply.ToolTip"));
          this->buttonApply->UseVisualStyleBackColor = true;
          this->buttonApply->Click += gcnew System::EventHandler(this, &Form1::buttonApply_Click);
          // 
          // buttonReset
          // 
          resources->ApplyResources(this->buttonReset, L"buttonReset");
          this->buttonReset->Name = L"buttonReset";
          this->toolTip1->SetToolTip(this->buttonReset, resources->GetString(L"buttonReset.ToolTip"));
          this->buttonReset->UseVisualStyleBackColor = true;
          this->buttonReset->Click += gcnew System::EventHandler(this, &Form1::buttonReset_Click);
          // 
          // Form1
          // 
          resources->ApplyResources(this, L"$this");
          this->AutoScaleMode = System::Windows::Forms::AutoScaleMode::Font;
          this->Controls->Add(this->UsePortsClassA);
          this->Controls->Add(this->UsePortsClassB);
          this->Controls->Add(this->HiddenModeA);
          this->Controls->Add(this->HiddenModeB);
          this->Controls->Add(this->pinNameB_OPEN);
          this->Controls->Add(this->pinNameB_OUT1);
          this->Controls->Add(this->pinNameB_OUT2);
          this->Controls->Add(this->pinNameB_RI);
          this->Controls->Add(this->pinNameB_CTS);
          this->Controls->Add(this->pinNameB_RTS);
          this->Controls->Add(this->pinNameB_DCD);
          this->Controls->Add(this->pinNameB_DSR);
          this->Controls->Add(this->pinNameB_TX);
          this->Controls->Add(this->pinNameB_DTR);
          this->Controls->Add(this->pinNameB_RX);
          this->Controls->Add(this->pinNameA_OPEN);
          this->Controls->Add(this->pinNameA_OUT1);
          this->Controls->Add(this->pinNameA_OUT2);
          this->Controls->Add(this->pinNameA_RI);
          this->Controls->Add(this->pinNameA_CTS);
          this->Controls->Add(this->pinNameA_RTS);
          this->Controls->Add(this->pinNameA_DCD);
          this->Controls->Add(this->pinNameA_DSR);
          this->Controls->Add(this->pinNameA_TX);
          this->Controls->Add(this->pinNameA_DTR);
          this->Controls->Add(this->pinNameA_RX);
          this->Controls->Add(this->ExclusiveModeA);
          this->Controls->Add(this->PlugInModeA);
          this->Controls->Add(this->EmuOverrunA);
          this->Controls->Add(this->EmuBrA);
          this->Controls->Add(this->ExclusiveModeB);
          this->Controls->Add(this->PlugInModeB);
          this->Controls->Add(this->EmuOverrunB);
          this->Controls->Add(this->EmuBrB);
          this->Controls->Add(this->buttonReset);
          this->Controls->Add(this->buttonApply);
          this->Controls->Add(this->buttonAddPair);
          this->Controls->Add(this->buttonRemovePair);
          this->Controls->Add(this->pairList);
          this->Controls->Add(this->PortNameB);
          this->Controls->Add(this->PortNameA);
          this->Controls->Add(this->pinNameON);
          this->Controls->Add(this->picturePinMap);
          this->FormBorderStyle = System::Windows::Forms::FormBorderStyle::FixedDialog;
          this->MaximizeBox = false;
          this->Name = L"Form1";
          this->Load += gcnew System::EventHandler(this, &Form1::this_Load);
          (cli::safe_cast<System::ComponentModel::ISupportInitialize^  >(this->picturePinMap))->EndInit();
          this->ResumeLayout(false);
          this->PerformLayout();

        }
#pragma endregion

    private:

        String ^GetControlValue(CheckBox ^control) {
          return control->Checked ? "YES" : "NO";
        }

        Void SetControlValue(CheckBox ^control, String ^value) {
          control->Checked = (value->ToUpper() == "YES") ? true : false;
        }

        /////////////////////////////////////////////////////////////////////
        #define DeclareControlPair(controlClass, control) \
          array<controlClass ^> ^control##_pair; \
          Void control##_Init() { \
            control##_pair = gcnew array<controlClass ^>{control##A, control##B}; \
          } \
          Void control##A_Changed(Object ^/*sender*/, EventArgs ^/*e*/) { \
            control##_Changed(0); \
          } \
          Void control##B_Changed(Object ^/*sender*/, EventArgs ^/*e*/) { \
            control##_Changed(1); \
          } \

        #define DeclareControlPairCheckBox(control) \
          DeclareControlPair(CheckBox, control) \
          Void control##_Changed(int i) { \
            try { \
              String ^key = (gcnew String(#control))->ToLower(); \
              String ^value = GetControlValue(control##_pair[i])->ToUpper(); \
              if (pairs[pairList->SelectedNode->Name][i][key] != value) { \
                control##_pair[i]->ForeColor = Color::Blue; \
                return; \
              } \
            } \
            catch (Exception^ /*e*/) { \
            } \
            control##_pair[i]->ForeColor = System::Drawing::SystemColors::ControlText; \
          } \
          Void control##_GetChanges(int i, PortPair ^portChanges) { \
            try { \
              String ^key = (gcnew String(#control))->ToLower(); \
              String ^value = GetControlValue(control##_pair[i])->ToUpper(); \
              if (pairs[pairList->SelectedNode->Name][i][key] != value) \
                portChanges[i][key] = value; \
            } \
            catch (Exception^ /*e*/) { \
            } \
          } \
          Void control##_Reset(int i) { \
            try { \
              String ^key = (gcnew String(#control))->ToLower(); \
              SetControlValue(control##_pair[i], pairs[pairList->SelectedNode->Name][i][key]); \
            } \
            catch (Exception^ /*e*/) { \
              SetControlValue(control##_pair[i], ""); \
            } \
            control##_Changed(i); \
          } \
        /////////////////////////////////////////////////////////////////////

    private:

        DeclareControlPair(TextBox, PortName)
        DeclareControlPair(CheckBox, UsePortsClass)

        Void PortName_GetCurrent(int i, String ^&name, bool &enabled, bool &checked) {
          try {
            name = pairs[pairList->SelectedNode->Name][i][(gcnew String("PortName"))->ToLower()];

            if (name->ToUpper() == "COM#") {
              checked = true;

              try {
                name = pairs[pairList->SelectedNode->Name][i][(gcnew String("RealPortName"))->ToLower()];
                enabled = true;
              }
              catch (Exception^ /*e*/) {
                name = "";
                enabled = false;
              }
            } else {
              checked = false;
              enabled = true;
            }
          }
          catch (Exception^ /*e*/) {
            checked = false;
            name = "";
            enabled = true;
          }
        }

        Void PortName_Changed(int i) {
          String ^name = gcnew String("");
          bool enabled;
          bool checked;

          PortName_GetCurrent(i, name, enabled, checked);

          String ^value = PortName_pair[i]->Text->ToUpper();

          if (name != value) {
            PortName_pair[i]->ForeColor = (pairs->IsValidName(value) ? Color::Blue : Color::Red);
          } else {
            PortName_pair[i]->ForeColor = System::Drawing::SystemColors::ControlText;
          }

          if (!checked != !UsePortsClass_pair[i]->Checked) {
            UsePortsClass_pair[i]->ForeColor = Color::Blue;
          } else {
            UsePortsClass_pair[i]->ForeColor = System::Drawing::SystemColors::ControlText;
          }

          PortName_pair[i]->Enabled = (!UsePortsClass_pair[i]->Checked || (checked && enabled));
        }

        Void PortName_GetChanges(int i, PortPair ^portChanges) {
          String ^name = gcnew String("");
          bool enabled;
          bool checked;

          PortName_GetCurrent(i, name, enabled, checked);

          String ^value = PortName_pair[i]->Text->ToUpper();

          if (UsePortsClass_pair[i]->Checked) {
            if (checked) {
              if (name != value) {
                portChanges[i][(gcnew String("RealPortName"))->ToLower()] = value;
              }
            } else {
              portChanges[i][(gcnew String("PortName"))->ToLower()] = "COM#";
            }
          } else {
            if (checked) {
              portChanges[i][(gcnew String("PortName"))->ToLower()] = value;
            } else {
              if (name != value) {
                portChanges[i][(gcnew String("PortName"))->ToLower()] = value;
              }
            }
          }
        }

        Void PortName_Reset(int i) {
          String ^name = gcnew String("");
          bool enabled;
          bool checked;

          PortName_GetCurrent(i, name, enabled, checked);

          PortName_pair[i]->Text = name;
          PortName_pair[i]->Enabled = enabled;
          UsePortsClass_pair[i]->Checked = checked;

          PortName_Changed(i);
        }

        Void UsePortsClass_Changed(int i) {
          String ^name = gcnew String("");
          bool enabled;
          bool checked;

          PortName_GetCurrent(i, name, enabled, checked);

          if (checked || !UsePortsClass_pair[i]->Checked) {
            if (!UsePortsClass_pair[i]->Checked && name == "") {
              PortName_pair[i]->Text = "-";
            } else {
              PortName_pair[i]->Text = name;
            }
          } else {
            PortName_pair[i]->Text = "";
          }

          PortName_Changed(i);
        }

        Void UsePortsClass_GetChanges(int /*i*/, PortPair ^/*portChanges*/) {
        }

        Void UsePortsClass_Reset(int /*i*/) {
        }

        DeclareControlPairCheckBox(EmuBr)
        DeclareControlPairCheckBox(EmuOverrun)
        DeclareControlPairCheckBox(PlugInMode)
        DeclareControlPairCheckBox(ExclusiveMode)
        DeclareControlPairCheckBox(HiddenMode)

        #define ForEachControlPair(func) \
          PortName_##func; \
          UsePortsClass_##func; \
          EmuBr_##func; \
          EmuOverrun_##func; \
          PlugInMode_##func; \
          ExclusiveMode_##func; \
          HiddenMode_##func; \

    private:

        Void Reset() {
          pairList->BeginUpdate();

          for each (TreeNode ^pair in pairList->Nodes) {
            if (!pairs->ContainsKey(pair->Name) ||
                pairs[pair->Name][0] == nullptr ||
                pairs[pair->Name][1] == nullptr)
            {
              pairList->Nodes->Remove(pair);
            }
          }

          for each (KeyValuePair<String ^, PortPair ^> kvpPair in pairs) {
            if (kvpPair.Value[0] == nullptr || kvpPair.Value[1] == nullptr)
              continue;

            TreeNode ^pair;
            bool pairExpand;

            if (pairList->Nodes->ContainsKey(kvpPair.Key)) {
              pair = pairList->Nodes[kvpPair.Key];
              pairExpand = pair->IsExpanded;
            } else {
              pair = pairList->Nodes->Add(kvpPair.Key, String::Format(
                  "Virtual Port Pair {0}", kvpPair.Key));
              pairExpand = true;
            }

            bool portExpand[2];

            for (int i = 0 ; i < 2 ; i++) {
              try {
                portExpand[i] = pair->Nodes[i]->IsExpanded;
              }
              catch (Exception^ /*e*/) {
                portExpand[i] = false;
              }
            }

            pair->Nodes->Clear();

            for (int i = 0 ; i < 2 ; i++) {
              TreeNode ^port;

              try {
                String ^name = kvpPair.Value[i][(gcnew String("PortName"))->ToLower()];

                if (name == "COM#") {
                  try {
                    name = kvpPair.Value[i][(gcnew String("RealPortName"))->ToLower()];
                  }
                  catch (Exception^ /*e*/) {
                  }
                }

                port = pair->Nodes->Add(name);
              }
              catch (Exception^ /*e*/) {
                port = pair->Nodes->Add(String::Format("CNC{0}{1}", (i == 0) ? "A" : "B", kvpPair.Key));
              }

              for each (KeyValuePair<String ^, String ^> kvpPort in kvpPair.Value[i]) {
                port->Nodes->Add(String::Format("{0}={1}", kvpPort.Key, kvpPort.Value));
              }

              if (portExpand[i])
                port->Expand();
            }

            if (pairExpand)
              pair->Expand();
          }

          if (pairList->SelectedNode == nullptr) {
            try {
              pairList->SelectedNode = pairList->Nodes[0];
            }
            catch (Exception^ /*e*/) {
            }
          }

          pairList->EndUpdate();

          try {
            pinMap->Init(pairs[pairList->SelectedNode->Name]);
          }
          catch (Exception^ /*e*/) {
            pinMap->Init(nullptr);
          }

          picturePinMap->Invalidate();

          for (int i = 0 ; i < 2 ; i++) {
            ForEachControlPair(Reset(i))
          }
        }

        PortPair ^GetChanges() {
          PortPair ^portChanges = gcnew PortPair;

          pinMap->GetChanges(portChanges);

          for (int i = 0 ; i < 2 ; i++) {
            ForEachControlPair(GetChanges(i, portChanges))
          }

          return portChanges;
        }

        bool SaveChanges() {
          if (!pairList->SelectedNode)
            return true;

          PortPair ^portChanges = GetChanges();

          if (!portChanges->IsEmpty()) {
            String^ msg = String::Format(
                "The parameters of \"{0}\" were changed.\n"
                "Would you like to apply the changes?",
                pairList->SelectedNode->Text);

            System::Windows::Forms::DialogResult res;

            res = MessageBox::Show(this, msg, "Apply", MessageBoxButtons::YesNoCancel);

            if (res == System::Windows::Forms::DialogResult::Cancel) {
              return false;
            }
            else
            if (res == System::Windows::Forms::DialogResult::Yes) {
              pairs->ChangePair(pairList->SelectedNode->Name, portChanges);

              Reset();
            }
          }

          return true;
        }

	private:

        PinMap ^pinMap;
        PortPairs ^pairs;

        Void this_Load(Object ^/*sender*/, EventArgs ^/*e*/) {
          ForEachControlPair(Init())

          pinMap = gcnew PinMap;
          pairs = gcnew PortPairs(this);

          pairs->Init();
          Reset();
        }

    private:

        Void picturePinMap_Paint(Object ^/*sender*/, PaintEventArgs ^e) {
            pinMap->Paint(e, picturePinMap);
        }

        Void picturePinMap_MouseDown(Object ^/*sender*/, MouseEventArgs ^e) {
            pinMap->MouseDown(e);
            picturePinMap->Invalidate();
        }

        Void picturePinMap_MouseMove(Object ^/*sender*/, MouseEventArgs ^e) {
            pinMap->MouseMove(e);
            picturePinMap->Invalidate();
        }

        Void picturePinMap_MouseUp(Object ^/*sender*/, MouseEventArgs ^e) {
            pinMap->MouseUp(e);
            picturePinMap->Invalidate();
        }

        Void picturePinMap_MouseDoubleClick(Object ^/*sender*/, MouseEventArgs ^e) {
            pinMap->MouseDoubleClick(e);
            picturePinMap->Invalidate();
        }

        Void picturePinMap_MouseLeave(Object ^/*sender*/, EventArgs ^/*e*/) {
            pinMap->MouseInit();
            picturePinMap->Invalidate();
        }

    private:

        Void pairsList_BeforeSelect(Object ^/*sender*/, TreeViewCancelEventArgs ^e) {
          if (!SaveChanges())
            e->Cancel = true;
        }

        Void pairsList_AfterSelect(Object ^/*sender*/, TreeViewEventArgs ^/*e*/) {
          Reset();
        }

    private:

        Void buttonApply_Click(Object ^/*sender*/, EventArgs ^/*e*/) {
          if (pairList->SelectedNode) {
            pairs->ChangePair(pairList->SelectedNode->Name, GetChanges());
            Reset();
          }
        }

        Void buttonRemovePair_Click(Object ^/*sender*/, EventArgs ^/*e*/) {
          if (pairList->SelectedNode != nullptr) {
            String^ msg = String::Format(
                "Would you like to remove \"{0}\"?",
                pairList->SelectedNode->Text);

            System::Windows::Forms::DialogResult res;

            res = MessageBox::Show(this, msg, "", MessageBoxButtons::YesNo);

            if (res == System::Windows::Forms::DialogResult::Yes) {
              pairs->RemovePair(pairList->SelectedNode->Name);
              Reset();
            }
          }
        }

        Void buttonAddPair_Click(Object ^/*sender*/, EventArgs ^/*e*/) {
          if (!SaveChanges())
            return;

          String ^key = pairs->AddPair();

          Reset();

          try {
            pairList->SelectedNode = pairList->Nodes[key];
          }
          catch (Exception^ /*e*/) {
          }
        }

        Void buttonReset_Click(Object ^/*sender*/, EventArgs ^/*e*/) {
          pairs->Init();
          Reset();
        }
    };
}


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/stdafx.cpp

// stdafx.cpp : source file that includes just the standard includes
// setup.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"




# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/setupg/.cvsignore

*.ncb
*.sln
*.user
*.suo
Release
Debug


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/ReadMe.txt

                 =============================
                 Null-modem emulator (com0com)
                 =============================

INTRODUCTION
============

The Null-modem emulator is an open source kernel-mode virtual serial
port driver for Windows, available freely under GPL license.
You can create an unlimited number of virtual COM port
pairs and use any pair to connect one application to another.
Each COM port pair provides two COM ports with default names starting
at CNCA0 and CNCB0. The output to one port is the input from other
port and vice versa.

Usually one port of the pair is used by Windows application that
requires a COM port to communicate with a device and other port is
used by device emulation program.

For example, to send/receive faxes over IP you can connect Windows Fax
application to CNCA0 port and t38modem (http://t38modem.sourceforge.net/)
to CNCB0 port. In this case the t38modem is a fax modem emulation program.

In conjunction with the hub4com the com0com allows you to
  - handle data and signals from a single real serial device by a number of
    different applications. For example, several applications can share data
    from one GPS device;
  - use real serial ports of remote computer like if they exist on the local
    computer (supports RFC 2217).

The homepage for com0com project is http://com0com.sourceforge.net/.


INSTALLING
==========

NOTE (x64-based Windows Vista/Windows Server 2008/Windows 7/8):
  The com0com.sys is a test-signed kernel-mode driver that will not load by
  default. To enable test signing, enter command:

    bcdedit.exe -set TESTSIGNING ON

  and reboot the computer.

NOTE:
  Enabling test signing will impair computer security.

Simply run the installer (setup.exe). An installation wizard will guide
you through the required steps.
If the Found New Hardware Wizard will pop up then
  - select "No, not this time" and click Next;
  - select "Install the software automatically (Recommended)" and click Next.
The one COM port pair with names CNCA0 and CNCB0 will be available on your
system after the installation.

You can add more pairs with the Setup Command Prompt:

  1. Launch the Setup Command Prompt shortcut.
  2. Enter the install command, for example:

       command> install - -

The system will create 3 new virtual devices. One of the devices has
name "com0com - bus for serial port pair emulator" and other two of
them have name "com0com - serial port emulator" and located on CNCAn
and CNCBn ports.

To get more info enter the help command, for example:

       command> help

Alternatively to setup ports you can invoke GUI-based setup utility by
launching Setup shortcut (Microsoft .NET Framework 2.0 is required).

TESTING
=======

  1. Start the HyperTerminal on CNCA0 port.
  2. Start the HyperTerminal on CNCB0 port.
  3. The output to CNCA0 port should be the input from CNCB0 port and
     vice versa.


UNINSTALLING
============

Simply launch the com0com's Uninstall shortcut in the Start Menu or remove
the "Null-modem emulator (com0com)" entry from the "Add/Remove Programs"
section in the Control Panel. An uninstallation wizard will guide
you through the required steps.

HINT: To uninstall the old version of com0com (distributed w/o installer)
install the new one and then uninstall it.


FAQs & HOWTOs
=============

Q. Is it possible to run com0com on Windows 9x platform?
A. No, it is not possible. You need Windows 2000 platform or newer.

Q. Is it possible to install or uninstall com0com silently (with no user
   intervention and no user interface)?
A. Yes, it's possible with /S option, for example:

     setup.exe /S
     "%ProgramFiles%\com0com\uninstall.exe" /S

   You can specify the installation directory with /D option, for example:

     setup.exe /S /D=C:\Program Files\com0com

   NOTE: Silent installation of com0com will not install any port pairs by
         default {it can be overriden by setting CNC_INSTALL_CNCA0_CNCB0_PORTS
         and/or CNC_INSTALL_COMX_COMX_PORTS environment variables).

Q. What are the other setup.exe command line options?
A. The command line options of setup.exe and uninstall.exe listed in
   NSIS Users Manual, section 3.2 Installer Usage:

     http://nsis.sourceforge.net/Docs/Chapter3.html#3.2

   Additionally the following environment variables can be used.

   To change behaviour of setup.exe:

     CNC_INSTALL_START_MENU_SHORTCUTS={YES|NO}   - select/unselect "Start Menu Shortcuts"
     CNC_INSTALL_CNCA0_CNCB0_PORTS={YES|NO}      - select/unselect "CNCA0 <-> CNCB0"
     CNC_INSTALL_COMX_COMX_PORTS={YES|NO}        - select/unselect "COM# <-> COM#"
     CNC_INSTALL_SKIP_SETUP_PREINSTALL={YES|NO}  - skip preinstalling/updating driver

   To change behaviour of uninstall.exe:

     CNC_UNINSTALL_SKIP_SETUP_UNINSTALL={YES|NO} - skip uninstalling devices and driver

Q. Is it possible to change the names CNCA0 and CNCB0 to COM8 and COM9?
A. Yes, it's possible. To change the names:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change commands, for example:

      command> change CNCA0 PortName=COM8
      command> change CNCB0 PortName=COM9

   Alternatively you can set names to 'COM#', for example:

      command> change CNCA0 PortName=COM#
      command> change CNCB0 PortName=COM#

   If parameter 'PortName=COM#' is used then the Ports class installer will be
   invoked to set the real port name. The Ports class installer selects the COM
   port number and sets the real port name to COM<n>, where <n> is the selected
   port number. After installing the Ports class port you can use the list
   command to get the real port name and the parameter RealPortName=COM<n> to
   change the real port name, for example:

      command> list
             CNCA0 PortName=COM#,RealPortName=COM3
             CNCB0 PortName=COM#,RealPortName=COM4
      command> change CNCA0 RealPortName=COM8
      command> change CNCB0 RealPortName=COM9
      command> list
             CNCA0 PortName=COM#,RealPortName=COM8
             CNCB0 PortName=COM#,RealPortName=COM9

Q. The baud rate setting does not seem to make a difference: data is always
   transferred at the same speed. How to enable the baud rate emulation?
A. To enable baud rate emulation for transferring data from CNCA0 to CNCB0:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change command, for example:

      command> change CNCA0 EmuBR=yes

Q. The HyperTerminal test succeeds, but I get a failure when trying to open the
   port with CreateFile("CNCA0", ...). GetLastError() returns ERROR_FILE_NOT_FOUND.
A. You must prefix the port name with the special characters "\\.\". Try to open
   the port with CreateFile("\\\\.\\CNCA0", ...).

Q. My application hangs during its startup when it sends anything to one paired
   COM port. The only way to unhang it is to start HyperTerminal, which is connected
   to the other paired COM port. I didn't have this problem with physical serial
   ports.
A. Your application can hang because receive buffer overrun is disabled by
   default. You can fix the problem by enabling receive buffer overrun for the
   receiving port. Also, to prevent some flow control issues you need to enable
   baud rate emulation for the sending port. So, if your application use port CNCA0
   and other paired port is CNCB0, then:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change commands, for example:

      command> change CNCB0 EmuOverrun=yes
      command> change CNCA0 EmuBR=yes

Q. When the corresponding port of a pair is not open, some characters will remain
   in the ouput buffer of the sending port and be output upon the next connection.
   Any clue on a possible workaround?
A. It's a correct behavior if receive buffer overrun is disabled (by default). If
   you need behavior where those characters should be lost (like real null modem do)
   then enable receive buffer overrun for the receiving port. Also, to prevent some
   flow control issues enable baud rate emulation for the sending port. So, if
   sending port is CNCA0 and receiving port is CNCB0, then:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change commands, for example:

      command> change CNCB0 EmuOverrun=yes
      command> change CNCA0 EmuBR=yes

Q. I have to write an application connected to one side of the com0com port pair,
   and I don't want users to 'see' all the virtual ports created by com0com, but
   only the really available ones.
A. if your application use port CNCB0 and other (used by users) paired port is CNCA0,
   then CNCB0 can be 'hidden' and CNCA0 can be 'shown' on opening CNCB0 by your
   application. To enable it:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change commands:

      command> change CNCB0 ExclusiveMode=yes
      command> change CNCA0 PlugInMode=yes

Q. When I add a port pair, why does Windows XP always pops up a Found New Hardware
   Wizard? The drivers are already there and it can install them silently in the
   background and report when the device is ready.
A. It's because there is not signed com0com.cat catalog file. It can be created on
   your test computer by this way:

   1. Create a catalog file, for example:

      cd "C:\Program Files\com0com"
      inf2cat /driver:. /os:XP_X86

   2. Create a test certificate, for example:

      makecert -r -n "CN=com0com (test)" -sv com0com.pvk com0com.cer
      pvk2pfx -pvk com0com.pvk -spc com0com.cer -pfx com0com.pfx

   3. Sign the catalog file by test certificate, for example:

      signtool sign /v /f com0com.pfx com0com.cat

   4. Install a test certificate to the Trusted Root Certification Authorities
      certificate store and the Trusted Publishers certificate store, for example:

      certmgr -add com0com.cer -s -r localMachine root
      certmgr -add com0com.cer -s -r localMachine trustedpublisher

   The inf2cat, makecert, pvk2pfx, signtool and certmgr tools are included in the
   Windows Driver Kit (WDK).

   Alternatively you can cancel Found New Hardware Wizard and install driver by
   update command, for example:

      setupc install - -
      setupc update

   Additionally you can temporary suppress Plug and Play-related UI messages, for
   example:

      reg add HKLM\Software\Policies\Microsoft\Windows\DeviceInstall\Settings /v SuppressNewHWUI /t REG_DWORD /d 1 /f
      setupc install - -
      setupc update
      reg add HKLM\Software\Policies\Microsoft\Windows\DeviceInstall\Settings /v SuppressNewHWUI /t REG_DWORD /d 0 /f

   See http://support.microsoft.com/kb/938596 for more info.

Q. How to monitor and get the paired port settings (baud rate, byte size, parity
   and stop bits)?
A. It can be done with extended IOCTL_SERIAL_LSRMST_INSERT. See example in

   http://com0com.sourceforge.net/examples/LSRMST_INSERT/tstser.cpp

Q. To transfer state to CTS and DSR they wired to RTS and DTR. How to transfer
   state to DCD and RING?
A. The OUT1 can be wired to DCD and OUT2 to RING. Use extended
   IOCTL_SERIAL_SET_MODEM_CONTROL and IOCTL_SERIAL_GET_MODEM_CONTROL to change
   state of OUT1 and OUT2.  See example in

   http://com0com.sourceforge.net/examples/MODEM_CONTROL/tstser.cpp

Q. What version am I running?
A. In the device manager, the driver properties page shows the version and date
   of the INF files, while the driver details page shows a version of
   com0com.sys file. The version of com0com.sys file is the version that you
   are running.

Q. I'm able to use some application to talk to some hardware using com2tcp when
   both the com2tcp 'server' and 'client' are running on the same computer.
   When I try to move the client to a remote computer the application gives me
   a timeout message and has no settings to increase the timeout. How to fix
   the problem?
A. Try to ajust AddRTTO and AddRITO params for application's COM port:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change command, for example:

      command> change CNCA0 AddRTTO=100,AddRITO=100

Q. I would like to be able to add, remove and rename virtual comm ports from my
   own custom application. Is there an API that I can use or some command line
   utility that will do the job?
A. The setupc.exe is a command line utility that will do the job. To get more
   info enter:

      setupc help

   BTW: The setupg.exe is a GUI wrapper for setupc.exe.

Q. I need to use com0com ports with an application that doesn't recognize
   com0com ports as "real" com ports. It does not see a com0com port even
   though I have changed it's name to COMx. Is there a com0com settings that
   will make the port appear to be a "real" com port?
A. Yes, it is. You should put the port to the Ports class, for example:

   1. Launch the Setup Command Prompt shortcut.
   2. Install the pair of ports, were one of them has name COM#, for example:

      command> install PortName=COM# -

Q. I have to somehow add a "fake" PNP device in device manager and have it
   connected under COM3. I use PNPComSimulator (http://www.bds.dogma.net/pnp_part2.htm),
   which can fake a PNP Serial device's response when polled by DevManager.
   Is it possible to have the device manager look for PNP equipement via com0com?
A. Yes, it is. The simplest way is to put the port to the Ports class, for example:

   1. Launch the Setup Command Prompt shortcut.
   2. Install the pair of ports, were one of them has name COM#, for example:

      command> install 0 PortName=COM# -

   After installing the Ports class port you can use the list command to get
   the real port name, for example:

      command> list
             CNCA0 PortName=COM#,RealPortName=COM3
             CNCB0 PortName=-

Q. Is it possible to configure the com0com to randomly corrupt the data? It
   would be nice to have this feature so that we can test our application
   robustness.
A. Yes, it's possible by setting EmuNoise parameter:

   1. Launch the Setup Command Prompt shortcut.
   2. Enter the change command, for example:

      command> change CNCA0 EmuNoise=0.00001,EmuBR=yes,EmuOverrun=yes
      command> change CNCB0 EmuNoise=0.00001,EmuBR=yes,EmuOverrun=yes

   Now each character frame (including idle frames) will be corrupted with
   probability 0.00001.

Q. What is the maximum number of port pairs that can be defined?
A. It depends from your system. The com0com itself has internal limit
   1000000 port pairs.

Q. In my application, users could be installing up to 250 com port pairs.
   Initially, the installation is fairly quick, but each additional com port
   generally takes longer to install than the previous one. It quickly
   becomes unacceptable for a user to be expected to wait for the installation.
A. It's because the installing of each next port pair requires to update driver
   for all installed pairs. You can speed up installing of multiple com port
   pairs by using install commands with --no-update option and then use
   install command w/o --no-update option, for example:

      command> --no-update install - -
      command> --no-update install - -
      ...
      command> --no-update install - -
      command> install

   The example of the batch program:

      cd /D "%ProgramFiles%\com0com"
      FOR /L %%i IN (0,1,249) DO setupc --no-update install - -
      setupc install

Q. I am using the 64-bit version of com0com and I am having trouble. I'd like
   to debug this, but I can not find any free serial port monitor software,
   like portmon that works with a 64-bit OS. Does anyone know of any?
A. You can try to use internal com0com's tracing for debuging:

      - get trace.reg file from com0com's source;
      - import trace.reg to the Registry;
      - reload driver (or reboot system);
      - do your tests and watch results in C:\com0com.log file.

   To disable tracing reinstall com0com or import trace_disable.reg to the
   Registry and reload driver.


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/Building.txt

                 =============================
                 Null-modem emulator (com0com)
                 =============================

PREREQUISITES
=============

You will need the following to build com0com from source code:

1.  Microsoft Windows Driver Development Kit (DDK) or Windows Driver Kit (WDK).
    When the DDK/WDK is installed, it defines the Start menu shortcuts for
    several different build environments. To open a DDK/WDK build environment
    window choose one of the environment shortcuts.

    NOTE: Microsoft removed Windows 2000 from its list of supported platforms
    for the new WDKs. So for Windows 2000 you'll need one of the previous
    releases of the DDK/WDK:

    6001.18002 - WDK for Windows Server 2008.
                 This WDK provides a Windows 2000 build environment for the
                 development of drivers targeting Windows 2000.
                 (6.1.6001.18002.081017-1400_wdksp-WDK18002SP_EN_DVD.iso).
    1830       - DDK for Windows Server 2003 SP1.
                 This DDK can be installed to Windows 2000.
                 (1830_usa_ddk.iso).

2.  Microsoft Visual C++ 2005 Express Edition (MSVC).
    It's required for building the GUI-based setup utility.
    When the MSVC is installed, it defines the Start menu shortcut for
    build environment. To open a MSVC build environment window choose it.

3.  Nullsoft Scriptable Install System (http://nsis.sourceforge.net/).
    It's required for building the installer.


BUILDING
========

1.  Build the driver.

    For example execute in the DDK/WDK build environment window:

      cd C:\com0com
      build -wcZ -M 1

    It will create the com0com.sys, setup.dll and setupc.exe files in the
    C:\com0com\<CPU>\ directory, where <CPU> is i386, ia64 or amd64
    and depends from choosen DDK build environment.

2.  If you build driver for x64-based versions of
    Windows Vista/Windows Server 2008/Windows 7/8 then create
    a test certificate and sign com0com.sys file.

    For example execute in the WDK build environment window:

      mkdir C:\com0com\cert
      cd C:\com0com\cert
      makecert -r -n "CN=com0com (test)" -sv com0com.pvk com0com.cer
      pvk2pfx -pvk com0com.pvk -spc com0com.cer -pfx com0com.pfx
      signtool sign /v /f com0com.pfx /t "http://timestamp.verisign.com/scripts/timestamp.dll" ..\amd64\com0com.sys

    It will test-sign the C:\com0com\amd64\com0com.sys file.

3.  Build the GUI-based setup utility.

    For example execute in the MSVC build environment window:

      vcbuild C:\com0com\setupg\setup.vcproj Release

    It will create the C:\com0com\setupg\Release\setupg.exe file.

4.  If you build driver for Windows Vista/Windows Server 2008/Windows 7/8 then
    embed requireAdministrator.manifest to the executables.

    For example execute in the MSVC build environment window:

      mt.exe -manifest C:\com0com\requireAdministrator.manifest -updateresource:"C:\com0com\setupg\Release\setupg.exe";#1
      mt.exe -manifest C:\com0com\requireAdministrator.manifest -outputresource:"C:\com0com\<CPU>\setupc.exe";#1

    where <CPU> is i386, ia64 or amd64

5.  Build the installer.

    For example execute in the DDK build environment window:

      "C:\Program Files\NSIS\makensis.exe" /V2 "C:\com0com\NSIS\install.nsi"

    It will create the installer in the C:\com0com\<CPU>\setup.exe file.


FAQs & HOWTOs
=============

Q. Is it possible to build a single installer suitable for both 32-bit and 64-bit systems?
A. Yes, it is possible. Use /DADD_TARGET_CPU_<CPU> and /DOUTPUT_FILE=<path> options, for example:

      "C:\Program Files\NSIS\makensis.exe" /V2 /DADD_TARGET_CPU_i386 /DADD_TARGET_CPU_amd64 /DOUTPUT_FILE="C:\com0com\setup.exe" "C:\com0com\NSIS\install.nsi"

    It will create the installer in the C:\com0com\setup.exe file suitable for both 32-bit and 64-bit systems.


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/comport.inf

;******************************************************************************
;
; comport.inf
;
; Installation file for the Null-modem emulator driver.
;
; Copyright (c) 2010-2012 Vyacheslav Frolov
;
;******************************************************************************

[Version]
Signature = "$Windows NT$"
Provider = %VF%
Class = Ports
ClassGUID = {4D36E978-E325-11CE-BFC1-08002BE10318}
CatalogFile = com0com.cat
;           MM/DD/YYYY
DriverVer = 06/04/2012,3.0.0.0
UninstallInfTag = {df799e12-3c56-421b-b298-b6d3642bc878}

;******************************************************************************
;
; Driver information
;
;******************************************************************************

[Manufacturer]
%VF% = com0com, NTx86, NTia64, NTamd64

[ControlFlags]
ExcludeFromSelect = com0com\comport

[com0com]
%com0com.PortDesc% = com0com_inst_port, com0com\comport

[com0com.NTx86]
%com0com.PortDesc% = com0com_inst_port, com0com\comport

[com0com.NTia64]
%com0com.PortDesc% = com0com_inst_port, com0com\comport

[com0com.NTamd64]
%com0com.PortDesc% = com0com_inst_port, com0com\comport

;******************************************************************************
;
; Port install section
;
;******************************************************************************

[com0com_inst_port]
AddReg = com0com_AddReg
Include = msports.inf
Needs = SerialEnumerator.NT

[com0com_inst_port.Services]
AddService = com0com, %SPSVCINST_ASSOCSERVICE%, com0com_Service_Inst, com0com_EventLog_Inst
Include = msports.inf
Needs = SerialEnumerator.NT.Services

[com0com_inst_port.HW]
AddReg = com0com_HW_AddReg

[com0com_AddReg]
;HKR,,PortSubClass,1,01
;HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"

[com0com_HW_AddReg]
HKR,,"UpperFilters",0x00010000,"serenum"

;******************************************************************************
;
; Common section
;
;******************************************************************************

[com0com_Service_Inst]
DisplayName    = %com0com.SrvDesc%
ServiceType    = %SERVICE_KERNEL_DRIVER%
StartType      = %SERVICE_DEMAND_START%
ErrorControl   = %SERVICE_ERROR_NORMAL%
ServiceBinary  = %12%\com0com.sys

[com0com_EventLog_Inst]
AddReg = com0com_EventLog_AddReg

[com0com_EventLog_AddReg]
HKR,,EventMessageFile,%REG_EXPAND_SZ%,"%%SystemRoot%%\System32\IoLogMsg.dll;%%SystemRoot%%\System32\drivers\com0com.sys"
HKR,,TypesSupported,%REG_DWORD%,7

;******************************************************************************
;
; Strings
;
;******************************************************************************

[Strings]

SPSVCINST_ASSOCSERVICE = 0x00000002

REG_EXPAND_SZ          = 0x00020000
REG_DWORD              = 0x00010001

SERVICE_KERNEL_DRIVER  = 1
SERVICE_DEMAND_START   = 3
SERVICE_ERROR_NORMAL   = 1

VF = "Vyacheslav Frolov"
com0com.PortDesc = "com0com - serial port emulator"
com0com.SrvDesc = "com0com - emulates the serial ports interconnected via a null-modem cable"

;******************************************************************************


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/dirs

DIRS= \
    sys \
    setup \
    setupc \


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/license.txt

GNU GENERAL PUBLIC LICENSE
Version 2, June 1991 

Copyright (C) 1989, 1991 Free Software Foundation, Inc.  
59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

Preamble
The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too. 

When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things. 

To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it. 

For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. 

We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software. 

Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations. 

Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all. 

The precise terms and conditions for copying, distribution and modification follow. 

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
0. This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you". 

Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does. 

1. You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program. 

You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee. 

2. You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: 


a) You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change. 

b) You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License. 

c) If the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.) 
These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it. 
Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program. 

In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. 

3. You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following: 

a) Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or, 

b) Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or, 

c) Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.) 
The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable. 
If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code. 

4. You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 

5. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it. 

6. Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License. 

7. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program. 

If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances. 

It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice. 

This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License. 

8. If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License. 

9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. 

Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation. 

10. If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally. 

NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 

12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 


END OF TERMS AND CONDITIONS


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/.cvsignore

*.log
i386
ia64
amd64


# File: /Users/calaeuscaelum/Downloads/com0com-3.0.0.0/trace.reg

Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\com0com\Trace]
"TraceFile"="\\??\\C:\\com0com.log"

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\com0com\Trace\Enable]
"Read"=dword:FFFFFFFF
"Write"=dword:FFFFFFFF
"GetTimeouts"=dword:FFFFFFFF
"SetTimeouts"=dword:FFFFFFFF
"GetCommStatus"=dword:FFFFFFFF
"GetModemStatus"=dword:FFFFFFFF
"ModemStatus"=dword:FFFFFFFF


